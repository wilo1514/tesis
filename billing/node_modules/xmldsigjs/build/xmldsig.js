var XmlDSigJs = (function (exports) {
  'use strict';

  function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
  function _arrayWithHoles(r) {
    if (Array.isArray(r)) return r;
  }
  function _arrayWithoutHoles(r) {
    if (Array.isArray(r)) return _arrayLikeToArray(r);
  }
  function _assertThisInitialized(e) {
    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  function asyncGeneratorStep(n, t, e, r, o, a, c) {
    try {
      var i = n[a](c),
        u = i.value;
    } catch (n) {
      return void e(n);
    }
    i.done ? t(u) : Promise.resolve(u).then(r, o);
  }
  function _asyncToGenerator(n) {
    return function () {
      var t = this,
        e = arguments;
      return new Promise(function (r, o) {
        var a = n.apply(t, e);
        function _next(n) {
          asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
        }
        function _throw(n) {
          asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
        }
        _next(void 0);
      });
    };
  }
  function _callSuper(t, o, e) {
    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
  }
  function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
  }
  function _construct(t, e, r) {
    if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
    var o = [null];
    o.push.apply(o, e);
    var p = new (t.bind.apply(t, o))();
    return r && _setPrototypeOf(p, r.prototype), p;
  }
  function _defineProperties(e, r) {
    for (var t = 0; t < r.length; t++) {
      var o = r[t];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
      writable: !1
    }), e;
  }
  function _createForOfIteratorHelper(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (!t) {
      if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
        t && (r = t);
        var n = 0,
          F = function () {};
        return {
          s: F,
          n: function () {
            return n >= r.length ? {
              done: !0
            } : {
              done: !1,
              value: r[n++]
            };
          },
          e: function (r) {
            throw r;
          },
          f: F
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o,
      a = !0,
      u = !1;
    return {
      s: function () {
        t = t.call(r);
      },
      n: function () {
        var r = t.next();
        return a = r.done, r;
      },
      e: function (r) {
        u = !0, o = r;
      },
      f: function () {
        try {
          a || null == t.return || t.return();
        } finally {
          if (u) throw o;
        }
      }
    };
  }
  function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
      value: t,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[r] = t, e;
  }
  function _get() {
    return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) {
      var p = _superPropBase(e, t);
      if (p) {
        var n = Object.getOwnPropertyDescriptor(p, t);
        return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
      }
    }, _get.apply(null, arguments);
  }
  function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t);
    }, _getPrototypeOf(t);
  }
  function _inherits(t, e) {
    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t,
        writable: !0,
        configurable: !0
      }
    }), Object.defineProperty(t, "prototype", {
      writable: !1
    }), e && _setPrototypeOf(t, e);
  }
  function _isNativeFunction(t) {
    try {
      return -1 !== Function.toString.call(t).indexOf("[native code]");
    } catch (n) {
      return "function" == typeof t;
    }
  }
  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    } catch (t) {}
    return (_isNativeReflectConstruct = function () {
      return !!t;
    })();
  }
  function _iterableToArray(r) {
    if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
  }
  function _iterableToArrayLimit(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
      var e,
        n,
        i,
        u,
        a = [],
        f = !0,
        o = !1;
      try {
        if (i = (t = t.call(r)).next, 0 === l) {
          if (Object(t) !== t) return;
          f = !1;
        } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
      } catch (r) {
        o = !0, n = r;
      } finally {
        try {
          if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
        } finally {
          if (o) throw n;
        }
      }
      return a;
    }
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _objectDestructuringEmpty(t) {
    if (null == t) throw new TypeError("Cannot destructure " + t);
  }
  function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r) {
        return Object.getOwnPropertyDescriptor(e, r).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread2(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
        _defineProperty(e, r, t[r]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
      });
    }
    return e;
  }
  function _objectWithoutProperties(e, t) {
    if (null == e) return {};
    var o,
      r,
      i = _objectWithoutPropertiesLoose(e, t);
    if (Object.getOwnPropertySymbols) {
      var s = Object.getOwnPropertySymbols(e);
      for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
      if (e.includes(n)) continue;
      t[n] = r[n];
    }
    return t;
  }
  function _possibleConstructorReturn(t, e) {
    if (e && ("object" == typeof e || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(t);
  }
  function _regeneratorRuntime() {
    _regeneratorRuntime = function () {
      return e;
    };
    var t,
      e = {},
      r = Object.prototype,
      n = r.hasOwnProperty,
      o = Object.defineProperty || function (t, e, r) {
        t[e] = r.value;
      },
      i = "function" == typeof Symbol ? Symbol : {},
      a = i.iterator || "@@iterator",
      c = i.asyncIterator || "@@asyncIterator",
      u = i.toStringTag || "@@toStringTag";
    function define(t, e, r) {
      return Object.defineProperty(t, e, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), t[e];
    }
    try {
      define({}, "");
    } catch (t) {
      define = function (t, e, r) {
        return t[e] = r;
      };
    }
    function wrap(t, e, r, n) {
      var i = e && e.prototype instanceof Generator ? e : Generator,
        a = Object.create(i.prototype),
        c = new Context(n || []);
      return o(a, "_invoke", {
        value: makeInvokeMethod(t, r, c)
      }), a;
    }
    function tryCatch(t, e, r) {
      try {
        return {
          type: "normal",
          arg: t.call(e, r)
        };
      } catch (t) {
        return {
          type: "throw",
          arg: t
        };
      }
    }
    e.wrap = wrap;
    var h = "suspendedStart",
      l = "suspendedYield",
      f = "executing",
      s = "completed",
      y = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var p = {};
    define(p, a, function () {
      return this;
    });
    var d = Object.getPrototypeOf,
      v = d && d(d(values([])));
    v && v !== r && n.call(v, a) && (p = v);
    var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
    function defineIteratorMethods(t) {
      ["next", "throw", "return"].forEach(function (e) {
        define(t, e, function (t) {
          return this._invoke(e, t);
        });
      });
    }
    function AsyncIterator(t, e) {
      function invoke(r, o, i, a) {
        var c = tryCatch(t[r], t, o);
        if ("throw" !== c.type) {
          var u = c.arg,
            h = u.value;
          return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
            invoke("next", t, i, a);
          }, function (t) {
            invoke("throw", t, i, a);
          }) : e.resolve(h).then(function (t) {
            u.value = t, i(u);
          }, function (t) {
            return invoke("throw", t, i, a);
          });
        }
        a(c.arg);
      }
      var r;
      o(this, "_invoke", {
        value: function (t, n) {
          function callInvokeWithMethodAndArg() {
            return new e(function (e, r) {
              invoke(t, n, e, r);
            });
          }
          return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(e, r, n) {
      var o = h;
      return function (i, a) {
        if (o === f) throw Error("Generator is already running");
        if (o === s) {
          if ("throw" === i) throw a;
          return {
            value: t,
            done: !0
          };
        }
        for (n.method = i, n.arg = a;;) {
          var c = n.delegate;
          if (c) {
            var u = maybeInvokeDelegate(c, n);
            if (u) {
              if (u === y) continue;
              return u;
            }
          }
          if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
            if (o === h) throw o = s, n.arg;
            n.dispatchException(n.arg);
          } else "return" === n.method && n.abrupt("return", n.arg);
          o = f;
          var p = tryCatch(e, r, n);
          if ("normal" === p.type) {
            if (o = n.done ? s : l, p.arg === y) continue;
            return {
              value: p.arg,
              done: n.done
            };
          }
          "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
        }
      };
    }
    function maybeInvokeDelegate(e, r) {
      var n = r.method,
        o = e.iterator[n];
      if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
      var i = tryCatch(o, e.iterator, r.arg);
      if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
      var a = i.arg;
      return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
    }
    function pushTryEntry(t) {
      var e = {
        tryLoc: t[0]
      };
      1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
    }
    function resetTryEntry(t) {
      var e = t.completion || {};
      e.type = "normal", delete e.arg, t.completion = e;
    }
    function Context(t) {
      this.tryEntries = [{
        tryLoc: "root"
      }], t.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(e) {
      if (e || "" === e) {
        var r = e[a];
        if (r) return r.call(e);
        if ("function" == typeof e.next) return e;
        if (!isNaN(e.length)) {
          var o = -1,
            i = function next() {
              for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
              return next.value = t, next.done = !0, next;
            };
          return i.next = i;
        }
      }
      throw new TypeError(typeof e + " is not iterable");
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: !0
    }), o(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: !0
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
      var e = "function" == typeof t && t.constructor;
      return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
    }, e.mark = function (t) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
    }, e.awrap = function (t) {
      return {
        __await: t
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
      return this;
    }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
      void 0 === i && (i = Promise);
      var a = new AsyncIterator(wrap(t, r, n, o), i);
      return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
        return t.done ? t.value : a.next();
      });
    }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
      return this;
    }), define(g, "toString", function () {
      return "[object Generator]";
    }), e.keys = function (t) {
      var e = Object(t),
        r = [];
      for (var n in e) r.push(n);
      return r.reverse(), function next() {
        for (; r.length;) {
          var t = r.pop();
          if (t in e) return next.value = t, next.done = !1, next;
        }
        return next.done = !0, next;
      };
    }, e.values = values, Context.prototype = {
      constructor: Context,
      reset: function (e) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
      },
      stop: function () {
        this.done = !0;
        var t = this.tryEntries[0].completion;
        if ("throw" === t.type) throw t.arg;
        return this.rval;
      },
      dispatchException: function (e) {
        if (this.done) throw e;
        var r = this;
        function handle(n, o) {
          return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
        }
        for (var o = this.tryEntries.length - 1; o >= 0; --o) {
          var i = this.tryEntries[o],
            a = i.completion;
          if ("root" === i.tryLoc) return handle("end");
          if (i.tryLoc <= this.prev) {
            var c = n.call(i, "catchLoc"),
              u = n.call(i, "finallyLoc");
            if (c && u) {
              if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
              if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
            } else if (c) {
              if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            } else {
              if (!u) throw Error("try statement without catch or finally");
              if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
            }
          }
        }
      },
      abrupt: function (t, e) {
        for (var r = this.tryEntries.length - 1; r >= 0; --r) {
          var o = this.tryEntries[r];
          if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
            var i = o;
            break;
          }
        }
        i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
        var a = i ? i.completion : {};
        return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
      },
      complete: function (t, e) {
        if ("throw" === t.type) throw t.arg;
        return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
      },
      finish: function (t) {
        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
          var r = this.tryEntries[e];
          if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
        }
      },
      catch: function (t) {
        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
          var r = this.tryEntries[e];
          if (r.tryLoc === t) {
            var n = r.completion;
            if ("throw" === n.type) {
              var o = n.arg;
              resetTryEntry(r);
            }
            return o;
          }
        }
        throw Error("illegal catch attempt");
      },
      delegateYield: function (e, r, n) {
        return this.delegate = {
          iterator: values(e),
          resultName: r,
          nextLoc: n
        }, "next" === this.method && (this.arg = t), y;
      }
    }, e;
  }
  function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
      return t.__proto__ = e, t;
    }, _setPrototypeOf(t, e);
  }
  function _slicedToArray(r, e) {
    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
  }
  function _superPropBase(t, o) {
    for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)););
    return t;
  }
  function _superPropGet(t, e, r, o) {
    var p = _get(_getPrototypeOf(1 & o ? t.prototype : t), e, r);
    return 2 & o ? function (t) {
      return p.apply(r, t);
    } : p;
  }
  function _toConsumableArray(r) {
    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
  }
  function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _typeof(o) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
      return typeof o;
    } : function (o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
  }
  function _unsupportedIterableToArray(r, a) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
  }
  function _wrapNativeSuper(t) {
    var r = "function" == typeof Map ? new Map() : void 0;
    return _wrapNativeSuper = function (t) {
      if (null === t || !_isNativeFunction(t)) return t;
      if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
      if (void 0 !== r) {
        if (r.has(t)) return r.get(t);
        r.set(t, Wrapper);
      }
      function Wrapper() {
        return _construct(t, arguments, _getPrototypeOf(this).constructor);
      }
      return Wrapper.prototype = Object.create(t.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      }), _setPrototypeOf(Wrapper, t);
    }, _wrapNativeSuper(t);
  }

  var _excluded = ["name", "optional", "primitiveSchema"],
    _excluded2 = ["value"],
    _excluded3 = ["isHexOnly"],
    _excluded4 = ["value", "isIndefiniteForm"],
    _excluded5 = ["value"],
    _excluded6 = ["isConstructed"],
    _excluded7 = ["idBlock", "lenBlock"],
    _excluded8 = ["unusedBits", "isConstructed"],
    _excluded9 = ["idBlock", "lenBlock"],
    _excluded10 = ["value"],
    _excluded11 = ["valueDec", "isFirstSid"],
    _excluded12 = ["value"],
    _excluded13 = ["valueDec"],
    _excluded14 = ["value"],
    _excluded15 = ["value", "valueDate"],
    _excluded16 = ["value"],
    _excluded17 = ["value", "local"];
  var ELEMENT = "element";
  var ATTRIBUTE = "attribute";
  var CONTENT$1 = "content";
  var MAX = 1e9;
  function assign$1(target) {
    for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      sources[_key - 1] = arguments[_key];
    }
    var res = arguments[0];
    for (var i = 1; i < arguments.length; i++) {
      var obj = arguments[i];
      for (var prop in obj) {
        if (!obj.hasOwnProperty(prop)) {
          continue;
        }
        res[prop] = obj[prop];
      }
    }
    return res;
  }
  function XmlElement(params) {
    return function (target) {
      var t = target;
      t.localName = params.localName || t.name;
      t.namespaceURI = params.namespaceURI || t.namespaceURI || null;
      t.prefix = params.prefix || t.prefix || null;
      t.parser = params.parser || t.parser;
      if (t.target !== t) {
        t.items = assign$1({}, t.items);
      }
      t.target = target;
    };
  }
  function XmlChildElement() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return function (target, propertyKey) {
      var t = target.constructor;
      var key = propertyKey;
      if (!t.items) {
        t.items = {};
      }
      if (t.target !== t) {
        t.items = assign$1({}, t.items);
      }
      t.target = target;
      if (params.parser) {
        t.items[key] = {
          parser: params.parser,
          required: params.required || false,
          maxOccurs: params.maxOccurs || MAX,
          minOccurs: params.minOccurs === void 0 ? 0 : params.minOccurs,
          noRoot: params.noRoot || false
        };
      } else {
        t.items[key] = {
          namespaceURI: params.namespaceURI || null,
          required: params.required || false,
          prefix: params.prefix || null,
          defaultValue: params.defaultValue,
          converter: params.converter,
          noRoot: params.noRoot || false
        };
      }
      params.localName = params.localName || params.parser && params.parser.localName || key;
      t.items[key].namespaceURI = params.namespaceURI || params.parser && params.parser.namespaceURI || null;
      t.items[key].prefix = params.prefix || params.parser && params.parser.prefix || null;
      t.items[key].localName = params.localName;
      t.items[key].type = ELEMENT;
      defineProperty(target, key, params);
    };
  }
  function XmlAttribute() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      required: false,
      namespaceURI: null
    };
    return function (target, propertyKey) {
      var t = target.constructor;
      var key = propertyKey;
      if (!params.localName) {
        params.localName = propertyKey;
      }
      if (!t.items) {
        t.items = {};
      }
      if (t.target !== t) {
        t.items = assign$1({}, t.items);
      }
      t.target = target;
      t.items[propertyKey] = params;
      t.items[propertyKey].type = ATTRIBUTE;
      defineProperty(target, key, params);
    };
  }
  function defineProperty(target, key, params) {
    var key2 = "_".concat(key);
    var opt = {
      set: function set(v) {
        if (this[key2] !== v) {
          this.element = null;
          this[key2] = v;
        }
      },
      get: function get() {
        if (this[key2] === void 0) {
          var defaultValue = params.defaultValue;
          if (params.parser) {
            defaultValue = new params.parser();
            defaultValue.localName = params.localName;
          }
          this[key2] = defaultValue;
        }
        return this[key2];
      }
    };
    Object.defineProperty(target, key2, {
      writable: true,
      enumerable: false
    });
    Object.defineProperty(target, key, opt);
  }
  var Collection = function () {
    function Collection(items) {
      _classCallCheck(this, Collection);
      this.items = new Array();
      if (items) {
        this.items = items;
      }
    }
    return _createClass(Collection, [{
      key: "Count",
      get: function get() {
        return this.items.length;
      }
    }, {
      key: "Item",
      value: function Item(index) {
        return this.items[index] || null;
      }
    }, {
      key: "Add",
      value: function Add(item) {
        this.items.push(item);
      }
    }, {
      key: "Pop",
      value: function Pop() {
        return this.items.pop();
      }
    }, {
      key: "RemoveAt",
      value: function RemoveAt(index) {
        this.items = this.items.filter(function (item, index2) {
          return index2 !== index;
        });
      }
    }, {
      key: "Clear",
      value: function Clear() {
        this.items = new Array();
      }
    }, {
      key: "GetIterator",
      value: function GetIterator() {
        return this.items;
      }
    }, {
      key: "ForEach",
      value: function ForEach(cb) {
        this.GetIterator().forEach(cb);
      }
    }, {
      key: "Map",
      value: function Map(cb) {
        return new Collection(this.GetIterator().map(cb));
      }
    }, {
      key: "Filter",
      value: function Filter(cb) {
        return new Collection(this.GetIterator().filter(cb));
      }
    }, {
      key: "Sort",
      value: function Sort(cb) {
        return new Collection(this.GetIterator().sort(cb));
      }
    }, {
      key: "Every",
      value: function Every(cb) {
        return this.GetIterator().every(cb);
      }
    }, {
      key: "Some",
      value: function Some(cb) {
        return this.GetIterator().some(cb);
      }
    }, {
      key: "IsEmpty",
      value: function IsEmpty() {
        return this.Count === 0;
      }
    }]);
  }();
  function printf(text) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    var msg = text;
    var regFind = /[^%](%\d+)/g;
    var match = null;
    var matches = [];
    while (match = regFind.exec(msg)) {
      matches.push({
        arg: match[1],
        index: match.index
      });
    }
    for (var i = matches.length - 1; i >= 0; i--) {
      var item = matches[i];
      var arg = item.arg.substring(1);
      var index = item.index + 1;
      msg = msg.substring(0, index) + arguments[+arg] + msg.substring(index + 1 + arg.length);
    }
    msg = msg.replace("%%", "%");
    return msg;
  }
  function padNum(num, size) {
    var s = num + "";
    while (s.length < size) {
      s = "0" + s;
    }
    return s;
  }
  var XmlError = _createClass(function XmlError(code) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    _classCallCheck(this, XmlError);
    this.prefix = "XMLJS";
    this.code = code;
    this.name = this.constructor.name;
    arguments[0] = xes[code];
    var message = printf.apply(this, arguments);
    this.message = "".concat(this.prefix).concat(padNum(code, 4), ": ").concat(message);
    this.stack = new Error(this.message).stack;
  });
  var XE;
  (function (XE) {
    XE[XE["NONE"] = 0] = "NONE";
    XE[XE["NULL_REFERENCE"] = 1] = "NULL_REFERENCE";
    XE[XE["NULL_PARAM"] = 2] = "NULL_PARAM";
    XE[XE["DECORATOR_NULL_PARAM"] = 3] = "DECORATOR_NULL_PARAM";
    XE[XE["COLLECTION_LIMIT"] = 4] = "COLLECTION_LIMIT";
    XE[XE["METHOD_NOT_IMPLEMENTED"] = 5] = "METHOD_NOT_IMPLEMENTED";
    XE[XE["METHOD_NOT_SUPPORTED"] = 6] = "METHOD_NOT_SUPPORTED";
    XE[XE["PARAM_REQUIRED"] = 7] = "PARAM_REQUIRED";
    XE[XE["CONVERTER_UNSUPPORTED"] = 8] = "CONVERTER_UNSUPPORTED";
    XE[XE["ELEMENT_MALFORMED"] = 9] = "ELEMENT_MALFORMED";
    XE[XE["ELEMENT_MISSING"] = 10] = "ELEMENT_MISSING";
    XE[XE["ATTRIBUTE_MISSING"] = 11] = "ATTRIBUTE_MISSING";
    XE[XE["CONTENT_MISSING"] = 12] = "CONTENT_MISSING";
    XE[XE["CRYPTOGRAPHIC"] = 13] = "CRYPTOGRAPHIC";
    XE[XE["CRYPTOGRAPHIC_NO_MODULE"] = 14] = "CRYPTOGRAPHIC_NO_MODULE";
    XE[XE["CRYPTOGRAPHIC_UNKNOWN_TRANSFORM"] = 15] = "CRYPTOGRAPHIC_UNKNOWN_TRANSFORM";
    XE[XE["ALGORITHM_NOT_SUPPORTED"] = 16] = "ALGORITHM_NOT_SUPPORTED";
    XE[XE["ALGORITHM_WRONG_NAME"] = 17] = "ALGORITHM_WRONG_NAME";
    XE[XE["XML_EXCEPTION"] = 18] = "XML_EXCEPTION";
  })(XE || (XE = {}));
  var xes = {};
  xes[XE.NONE] = "No description";
  xes[XE.NULL_REFERENCE] = "Null reference";
  xes[XE.NULL_PARAM] = "'%1' has empty '%2' object";
  xes[XE.DECORATOR_NULL_PARAM] = "Decorator '%1' has empty '%2' parameter";
  xes[XE.COLLECTION_LIMIT] = "Collection of '%1' in element '%2' has wrong amount of items";
  xes[XE.METHOD_NOT_IMPLEMENTED] = "Method is not implemented";
  xes[XE.METHOD_NOT_SUPPORTED] = "Method is not supported";
  xes[XE.PARAM_REQUIRED] = "Required parameter is missing '%1'";
  xes[XE.CONVERTER_UNSUPPORTED] = "Converter is not supported";
  xes[XE.ELEMENT_MALFORMED] = "Malformed element '%1'";
  xes[XE.ELEMENT_MISSING] = "Element '%1' is missing in '%2'";
  xes[XE.ATTRIBUTE_MISSING] = "Attribute '%1' is missing in '%2'";
  xes[XE.CONTENT_MISSING] = "Content is missing in '%1'";
  xes[XE.CRYPTOGRAPHIC] = "Cryptographic error: %1";
  xes[XE.CRYPTOGRAPHIC_NO_MODULE] = "WebCrypto module is not found";
  xes[XE.CRYPTOGRAPHIC_UNKNOWN_TRANSFORM] = "Unknown transform %1";
  xes[XE.ALGORITHM_NOT_SUPPORTED] = "Algorithm is not supported '%1'";
  xes[XE.ALGORITHM_WRONG_NAME] = "Algorithm wrong name in use '%1'";
  xes[XE.XML_EXCEPTION] = "XML exception: %1";
  var Convert$1 = function () {
    function Convert() {
      _classCallCheck(this, Convert);
    }
    return _createClass(Convert, null, [{
      key: "ToString",
      value: function ToString(buffer) {
        var enc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "utf8";
        var buf = new Uint8Array(buffer);
        switch (enc.toLowerCase()) {
          case "utf8":
            return this.ToUtf8String(buf);
          case "binary":
            return this.ToBinary(buf);
          case "hex":
            return this.ToHex(buf);
          case "base64":
            return this.ToBase64(buf);
          case "base64url":
            return this.ToBase64Url(buf);
          default:
            throw new XmlError(XE.CONVERTER_UNSUPPORTED);
        }
      }
    }, {
      key: "FromString",
      value: function FromString(str) {
        var enc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "utf8";
        switch (enc.toLowerCase()) {
          case "utf8":
            return this.FromUtf8String(str);
          case "binary":
            return this.FromBinary(str);
          case "hex":
            return this.FromHex(str);
          case "base64":
            return this.FromBase64(str);
          case "base64url":
            return this.FromBase64Url(str);
          default:
            throw new XmlError(XE.CONVERTER_UNSUPPORTED);
        }
      }
    }, {
      key: "ToBase64",
      value: function ToBase64(buf) {
        if (typeof btoa !== "undefined") {
          var binary = this.ToString(buf, "binary");
          return btoa(binary);
        } else if (typeof Buffer !== "undefined") {
          return Buffer.from(buf).toString("base64");
        } else {
          throw new XmlError(XE.CONVERTER_UNSUPPORTED);
        }
      }
    }, {
      key: "FromBase64",
      value: function FromBase64(base64Text) {
        base64Text = base64Text.replace(/\n/g, "").replace(/\r/g, "").replace(/\t/g, "").replace(/\s/g, "");
        if (typeof atob !== "undefined") {
          return this.FromBinary(atob(base64Text));
        } else if (typeof Buffer !== "undefined") {
          return new Uint8Array(Buffer.from(base64Text, "base64"));
        } else {
          throw new XmlError(XE.CONVERTER_UNSUPPORTED);
        }
      }
    }, {
      key: "FromBase64Url",
      value: function FromBase64Url(base64url) {
        return this.FromBase64(this.Base64Padding(base64url.replace(/\-/g, "+").replace(/\_/g, "/")));
      }
    }, {
      key: "ToBase64Url",
      value: function ToBase64Url(data) {
        return this.ToBase64(data).replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
      }
    }, {
      key: "FromUtf8String",
      value: function FromUtf8String(text) {
        var s = unescape(encodeURIComponent(text));
        var uintArray = new Uint8Array(s.length);
        for (var i = 0; i < s.length; i++) {
          uintArray[i] = s.charCodeAt(i);
        }
        return uintArray;
      }
    }, {
      key: "ToUtf8String",
      value: function ToUtf8String(buffer) {
        var encodedString = String.fromCharCode.apply(null, buffer);
        var decodedString = decodeURIComponent(escape(encodedString));
        return decodedString;
      }
    }, {
      key: "FromBinary",
      value: function FromBinary(text) {
        var stringLength = text.length;
        var resultView = new Uint8Array(stringLength);
        for (var i = 0; i < stringLength; i++) {
          resultView[i] = text.charCodeAt(i);
        }
        return resultView;
      }
    }, {
      key: "ToBinary",
      value: function ToBinary(buffer) {
        var resultString = "";
        for (var i = 0; i < buffer.length; i++) {
          resultString = resultString + String.fromCharCode(buffer[i]);
        }
        return resultString;
      }
    }, {
      key: "ToHex",
      value: function ToHex(buffer) {
        var splitter = "";
        var res = [];
        for (var i = 0; i < buffer.length; i++) {
          var char = buffer[i].toString(16);
          res.push(char.length === 1 ? "0" + char : char);
        }
        return res.join(splitter);
      }
    }, {
      key: "FromHex",
      value: function FromHex(hexString) {
        var res = new Uint8Array(hexString.length / 2);
        for (var i = 0; i < hexString.length; i = i + 2) {
          var c = hexString.slice(i, i + 2);
          res[i / 2] = parseInt(c, 16);
        }
        return res;
      }
    }, {
      key: "ToDateTime",
      value: function ToDateTime(dateTime) {
        return new Date(dateTime);
      }
    }, {
      key: "FromDateTime",
      value: function FromDateTime(dateTime) {
        var str = dateTime.toISOString();
        return str;
      }
    }, {
      key: "Base64Padding",
      value: function Base64Padding(base64) {
        var padCount = 4 - base64.length % 4;
        if (padCount < 4) {
          for (var i = 0; i < padCount; i++) {
            base64 += "=";
          }
        }
        return base64;
      }
    }]);
  }();
  var APPLICATION_XML = "application/xml";
  var XmlNodeType;
  (function (XmlNodeType) {
    XmlNodeType[XmlNodeType["None"] = 0] = "None";
    XmlNodeType[XmlNodeType["Element"] = 1] = "Element";
    XmlNodeType[XmlNodeType["Attribute"] = 2] = "Attribute";
    XmlNodeType[XmlNodeType["Text"] = 3] = "Text";
    XmlNodeType[XmlNodeType["CDATA"] = 4] = "CDATA";
    XmlNodeType[XmlNodeType["EntityReference"] = 5] = "EntityReference";
    XmlNodeType[XmlNodeType["Entity"] = 6] = "Entity";
    XmlNodeType[XmlNodeType["ProcessingInstruction"] = 7] = "ProcessingInstruction";
    XmlNodeType[XmlNodeType["Comment"] = 8] = "Comment";
    XmlNodeType[XmlNodeType["Document"] = 9] = "Document";
    XmlNodeType[XmlNodeType["DocumentType"] = 10] = "DocumentType";
    XmlNodeType[XmlNodeType["DocumentFragment"] = 11] = "DocumentFragment";
    XmlNodeType[XmlNodeType["Notation"] = 12] = "Notation";
    XmlNodeType[XmlNodeType["Whitespace"] = 13] = "Whitespace";
    XmlNodeType[XmlNodeType["SignificantWhitespace"] = 14] = "SignificantWhitespace";
    XmlNodeType[XmlNodeType["EndElement"] = 15] = "EndElement";
    XmlNodeType[XmlNodeType["EndEntity"] = 16] = "EndEntity";
    XmlNodeType[XmlNodeType["XmlDeclaration"] = 17] = "XmlDeclaration";
  })(XmlNodeType || (XmlNodeType = {}));
  var xpath = function xpath(node, xPath) {
    throw new Error("Not implemented");
  };
  var sWindow;
  if (typeof self === "undefined") {
    sWindow = global;
    var xmldom = require("@xmldom/xmldom");
    xpath = require("xpath.js");
    sWindow.XMLSerializer = xmldom.XMLSerializer;
    sWindow.DOMParser = xmldom.DOMParser;
    sWindow.DOMImplementation = xmldom.DOMImplementation;
    sWindow.document = new DOMImplementation().createDocument("http://www.w3.org/1999/xhtml", "html", null);
  } else {
    sWindow = self;
  }
  function SelectNodesEx(node, xPath) {
    var doc = node.ownerDocument == null ? node : node.ownerDocument;
    var nsResolver = document.createNSResolver(node.ownerDocument == null ? node.documentElement : node.ownerDocument.documentElement);
    var personIterator = doc.evaluate(xPath, node, nsResolver, XPathResult.ANY_TYPE, null);
    var ns = [];
    var n;
    while (n = personIterator.iterateNext()) {
      ns.push(n);
    }
    return ns;
  }
  var Select = typeof self !== "undefined" ? SelectNodesEx : xpath;
  function Parse(xmlString) {
    xmlString = xmlString.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    return new DOMParser().parseFromString(xmlString, APPLICATION_XML);
  }
  function Stringify(target) {
    return new XMLSerializer().serializeToString(target);
  }
  function SelectSingleNode(node, path) {
    var ns = Select(node, path);
    if (ns && ns.length > 0) {
      return ns[0];
    }
    return null;
  }
  function _SelectNamespaces(node) {
    var selectedNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (isElement(node)) {
      if (node.namespaceURI && node.namespaceURI !== "http://www.w3.org/XML/1998/namespace" && !selectedNodes[node.prefix || ""]) {
        selectedNodes[node.prefix ? node.prefix : ""] = node.namespaceURI;
      }
      for (var i = 0; i < node.childNodes.length; i++) {
        var childNode = node.childNodes.item(i);
        if (childNode && childNode.nodeType === XmlNodeType.Element) {
          _SelectNamespaces(childNode, selectedNodes);
        }
      }
    }
  }
  function SelectNamespaces(node) {
    var attrs = {};
    _SelectNamespaces(node, attrs);
    return attrs;
  }
  function assign(target) {
    for (var _len4 = arguments.length, sources = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      sources[_key4 - 1] = arguments[_key4];
    }
    var res = arguments[0];
    for (var i = 1; i < arguments.length; i++) {
      var obj = arguments[i];
      for (var prop in obj) {
        if (!obj.hasOwnProperty(prop)) {
          continue;
        }
        res[prop] = obj[prop];
      }
    }
    return res;
  }
  function isNodeType(obj, type) {
    return obj && obj.nodeType === type;
  }
  function isElement(obj) {
    return isNodeType(obj, XmlNodeType.Element);
  }
  function isDocument(obj) {
    return isNodeType(obj, XmlNodeType.Document);
  }
  var XmlBase64Converter = {
    get: function get(value) {
      if (value) {
        return Convert$1.ToBase64(value);
      }
      return void 0;
    },
    set: function set(value) {
      return Convert$1.FromBase64(value);
    }
  };
  var XmlNumberConverter = {
    get: function get(value) {
      if (value) {
        return value.toString();
      }
      return "0";
    },
    set: function set(value) {
      return Number(value);
    }
  };
  var DEFAULT_ROOT_NAME = "xml_root";
  var XmlObject = function () {
    function XmlObject() {
      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, XmlObject);
      this.prefix = this.GetStatic().prefix || null;
      this.localName = this.GetStatic().localName;
      this.namespaceURI = this.GetStatic().namespaceURI;
      if (properties) {
        for (var _i = 0, _Object$entries = Object.entries(properties); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
            key = _Object$entries$_i[0],
            value = _Object$entries$_i[1];
          if (value !== undefined) {
            this[key] = value;
          }
        }
      }
    }
    return _createClass(XmlObject, [{
      key: "Element",
      get: function get() {
        return this.element;
      }
    }, {
      key: "Prefix",
      get: function get() {
        return this.prefix;
      },
      set: function set(value) {
        this.prefix = value;
      }
    }, {
      key: "LocalName",
      get: function get() {
        return this.localName;
      }
    }, {
      key: "NamespaceURI",
      get: function get() {
        return this.namespaceURI || null;
      }
    }, {
      key: "HasChanged",
      value: function HasChanged() {
        var self = this.GetStatic();
        if (self.items) {
          for (var key in self.items) {
            if (!self.items.hasOwnProperty(key)) {
              continue;
            }
            var item = self.items[key];
            var value = this[key];
            if (item.parser && value && value.HasChanged()) {
              return true;
            }
          }
        }
        return this.element === null;
      }
    }, {
      key: "GetXml",
      value: function GetXml(hard) {
        if (!(hard || this.HasChanged())) {
          return this.element || null;
        }
        var thisAny = this;
        var doc = this.CreateDocument();
        var el = this.CreateElement();
        var self = this.GetStatic();
        var localName = this.localName;
        if (self.items) {
          for (var key in self.items) {
            if (!self.items.hasOwnProperty(key)) {
              continue;
            }
            var parser = thisAny[key];
            var selfItem = self.items[key];
            switch (selfItem.type) {
              case CONTENT$1:
                {
                  var schema = selfItem;
                  var value = schema.converter ? schema.converter.get(parser) : parser;
                  if (schema.required && (value === null || value === void 0)) {
                    throw new XmlError(XE.CONTENT_MISSING, localName);
                  }
                  if (schema.defaultValue !== parser || schema.required) {
                    el.textContent = value;
                  }
                  break;
                }
              case ATTRIBUTE:
                {
                  var _schema2 = selfItem;
                  var _value = _schema2.converter ? _schema2.converter.get(parser) : parser;
                  if (_schema2.required && (_value === null || _value === void 0)) {
                    throw new XmlError(XE.ATTRIBUTE_MISSING, _schema2.localName, localName);
                  }
                  if (_schema2.defaultValue !== parser || _schema2.required) {
                    if (!_schema2.namespaceURI) {
                      el.setAttribute(_schema2.localName, _value);
                    } else {
                      el.setAttributeNS(_schema2.namespaceURI, _schema2.localName, _value);
                    }
                  }
                  break;
                }
              case ELEMENT:
                {
                  var _schema3 = selfItem;
                  var node = null;
                  if (_schema3.parser) {
                    if (_schema3.required && !parser || _schema3.minOccurs && !parser.Count) {
                      throw new XmlError(XE.ELEMENT_MISSING, parser.localName, localName);
                    }
                    if (parser) {
                      node = parser.GetXml(parser.element === void 0 && (_schema3.required || parser.Count));
                    }
                  } else {
                    var _value2 = _schema3.converter ? _schema3.converter.get(parser) : parser;
                    if (_schema3.required && _value2 === void 0) {
                      throw new XmlError(XE.ELEMENT_MISSING, _schema3.localName, localName);
                    }
                    if (parser !== _schema3.defaultValue || _schema3.required) {
                      if (!_schema3.namespaceURI) {
                        node = doc.createElement("".concat(_schema3.prefix ? _schema3.prefix + ":" : "").concat(_schema3.localName));
                      } else {
                        node = doc.createElementNS(_schema3.namespaceURI, "".concat(_schema3.prefix ? _schema3.prefix + ":" : "").concat(_schema3.localName));
                      }
                      if (Array.isArray(_value2)) {
                        var _iterator = _createForOfIteratorHelper(_value2),
                          _step;
                        try {
                          for (_iterator.s(); !(_step = _iterator.n()).done;) {
                            var child = _step.value;
                            var val = child instanceof XmlObject ? child.GetXml(true) : child;
                            if (val !== null) {
                              node.appendChild(val);
                            }
                          }
                        } catch (err) {
                          _iterator.e(err);
                        } finally {
                          _iterator.f();
                        }
                      } else if (_value2 instanceof XmlObject) {
                        node.appendChild(_value2.GetXml(true));
                      } else {
                        node.textContent = _value2;
                      }
                    }
                  }
                  if (node) {
                    if (_schema3.noRoot) {
                      var els = [];
                      for (var i = 0; i < node.childNodes.length; i++) {
                        var colNode = node.childNodes.item(i);
                        if (isElement(colNode)) {
                          els.push(colNode);
                        }
                      }
                      if (els.length < _schema3.minOccurs || els.length > _schema3.maxOccurs) {
                        throw new XmlError(XE.COLLECTION_LIMIT, parser.localName, self.localName);
                      }
                      els.forEach(function (e) {
                        return el.appendChild(e.cloneNode(true));
                      });
                    } else if (node.childNodes.length < _schema3.minOccurs || node.childNodes.length > _schema3.maxOccurs) {
                      throw new XmlError(XE.COLLECTION_LIMIT, parser.localName, self.localName);
                    } else {
                      el.appendChild(node);
                    }
                  }
                  break;
                }
            }
          }
        }
        this.OnGetXml(el);
        this.element = el;
        return el;
      }
    }, {
      key: "LoadXml",
      value: function LoadXml(param) {
        var element;
        var thisAny = this;
        if (typeof param === "string") {
          var doc = Parse(param);
          element = doc.documentElement;
        } else {
          element = param;
        }
        if (!element) {
          throw new XmlError(XE.PARAM_REQUIRED, "element");
        }
        var self = this.GetStatic();
        var localName = this.localName;
        if (!(element.localName === localName && element.namespaceURI == this.NamespaceURI)) {
          throw new XmlError(XE.ELEMENT_MALFORMED, localName);
        }
        if (self.items) {
          for (var key in self.items) {
            if (!self.items.hasOwnProperty(key)) {
              continue;
            }
            var selfItem = self.items[key];
            switch (selfItem.type) {
              case CONTENT$1:
                {
                  var schema = selfItem;
                  if (schema.required && !element.textContent) {
                    throw new XmlError(XE.CONTENT_MISSING, localName);
                  }
                  if (!element.textContent) {
                    thisAny[key] = schema.defaultValue;
                  } else {
                    var value = schema.converter ? schema.converter.set(element.textContent) : element.textContent;
                    thisAny[key] = value;
                  }
                  break;
                }
              case ATTRIBUTE:
                {
                  var _schema4 = selfItem;
                  var hasAttribute = void 0;
                  var getAttribute = void 0;
                  if (!_schema4.localName) {
                    throw new XmlError(XE.PARAM_REQUIRED, "localName");
                  }
                  if (_schema4.namespaceURI) {
                    hasAttribute = element.hasAttributeNS.bind(element, _schema4.namespaceURI, _schema4.localName);
                    getAttribute = element.getAttributeNS.bind(element, _schema4.namespaceURI, _schema4.localName);
                  } else {
                    hasAttribute = element.hasAttribute.bind(element, _schema4.localName);
                    getAttribute = element.getAttribute.bind(element, _schema4.localName);
                  }
                  if (_schema4.required && !hasAttribute()) {
                    throw new XmlError(XE.ATTRIBUTE_MISSING, _schema4.localName, localName);
                  }
                  if (!hasAttribute()) {
                    thisAny[key] = _schema4.defaultValue;
                  } else {
                    var _value3 = _schema4.converter ? _schema4.converter.set(getAttribute()) : getAttribute();
                    thisAny[key] = _value3;
                  }
                  break;
                }
              case ELEMENT:
                {
                  var _schema5 = selfItem;
                  if (_schema5.noRoot) {
                    if (!_schema5.parser) {
                      throw new XmlError(XE.XML_EXCEPTION, "Schema for '".concat(_schema5.localName, "' with flag noRoot must have 'parser'"));
                    }
                    var col = new _schema5.parser();
                    if (!(col instanceof XmlCollection)) {
                      throw new XmlError(XE.XML_EXCEPTION, "Schema for '".concat(_schema5.localName, "' with flag noRoot must have 'parser' like instance of XmlCollection"));
                    }
                    col.OnLoadXml(element);
                    delete col.element;
                    if (col.Count < _schema5.minOccurs || col.Count > _schema5.maxOccurs) {
                      throw new XmlError(XE.COLLECTION_LIMIT, _schema5.parser.localName, localName);
                    }
                    thisAny[key] = col;
                    continue;
                  }
                  var foundElement = null;
                  for (var i = 0; i < element.childNodes.length; i++) {
                    var node = element.childNodes.item(i);
                    if (!isElement(node)) {
                      continue;
                    }
                    var el = node;
                    if (el.localName === _schema5.localName && el.namespaceURI == _schema5.namespaceURI) {
                      foundElement = el;
                      break;
                    }
                  }
                  if (_schema5.required && !foundElement) {
                    throw new XmlError(XE.ELEMENT_MISSING, _schema5.parser ? _schema5.parser.localName : _schema5.localName, localName);
                  }
                  if (!_schema5.parser) {
                    if (!foundElement) {
                      thisAny[key] = _schema5.defaultValue;
                    } else {
                      var _value4 = _schema5.converter ? _schema5.converter.set(foundElement.textContent) : foundElement.textContent;
                      thisAny[key] = _value4;
                    }
                  } else {
                    if (foundElement) {
                      var _value5 = new _schema5.parser();
                      _value5.localName = _schema5.localName;
                      _value5.namespaceURI = _schema5.namespaceURI;
                      thisAny[key] = _value5;
                      _value5.LoadXml(foundElement);
                    }
                  }
                  break;
                }
            }
          }
        }
        this.OnLoadXml(element);
        this.prefix = element.prefix || "";
        this.element = element;
      }
    }, {
      key: "toString",
      value: function toString() {
        var xml = this.GetXml();
        return xml ? new XMLSerializer().serializeToString(xml) : "";
      }
    }, {
      key: "GetElement",
      value: function GetElement(name) {
        var required = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        if (!this.element) {
          throw new XmlError(XE.NULL_PARAM, this.localName);
        }
        return XmlObject.GetElement(this.element, name, required);
      }
    }, {
      key: "GetChildren",
      value: function GetChildren(localName, nameSpace) {
        if (!this.element) {
          throw new XmlError(XE.NULL_PARAM, this.localName);
        }
        return XmlObject.GetChildren(this.element, localName, nameSpace || this.NamespaceURI || undefined);
      }
    }, {
      key: "GetChild",
      value: function GetChild(localName) {
        var required = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        if (!this.element) {
          throw new XmlError(XE.NULL_PARAM, this.localName);
        }
        return XmlObject.GetChild(this.element, localName, this.NamespaceURI || undefined, required);
      }
    }, {
      key: "GetFirstChild",
      value: function GetFirstChild(localName, namespace) {
        if (!this.element) {
          throw new XmlError(XE.NULL_PARAM, this.localName);
        }
        return XmlObject.GetFirstChild(this.element, localName, namespace);
      }
    }, {
      key: "GetAttribute",
      value: function GetAttribute(name, defaultValue) {
        var required = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        if (!this.element) {
          throw new XmlError(XE.NULL_PARAM, this.localName);
        }
        return XmlObject.GetAttribute(this.element, name, defaultValue, required);
      }
    }, {
      key: "IsEmpty",
      value: function IsEmpty() {
        return this.Element === void 0;
      }
    }, {
      key: "OnLoadXml",
      value: function OnLoadXml(element) {}
    }, {
      key: "GetStatic",
      value: function GetStatic() {
        return this.constructor;
      }
    }, {
      key: "GetPrefix",
      value: function GetPrefix() {
        return this.Prefix ? this.prefix + ":" : "";
      }
    }, {
      key: "OnGetXml",
      value: function OnGetXml(element) {}
    }, {
      key: "CreateElement",
      value: function CreateElement(document, localName) {
        var namespaceUri = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var prefix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        if (!document) {
          document = this.CreateDocument();
        }
        localName = localName || this.localName;
        namespaceUri = namespaceUri || this.NamespaceURI;
        prefix = prefix || this.prefix;
        var tagName = (prefix ? "".concat(prefix, ":") : "") + localName;
        var xn = namespaceUri ? document.createElementNS(namespaceUri, tagName) : document.createElement(tagName);
        document.importNode(xn, true);
        return xn;
      }
    }, {
      key: "CreateDocument",
      value: function CreateDocument() {
        return XmlObject.CreateDocument(this.localName, this.NamespaceURI, this.Prefix);
      }
    }], [{
      key: "LoadXml",
      value: function LoadXml(param) {
        var xml = new this();
        xml.LoadXml(param);
        return xml;
      }
    }, {
      key: "GetElement",
      value: function GetElement(element, name) {
        var required = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        var xmlNodeList = element.getElementsByTagName(name);
        if (required && xmlNodeList.length === 0) {
          throw new XmlError(XE.ELEMENT_MISSING, name, element.localName);
        }
        return xmlNodeList[0] || null;
      }
    }, {
      key: "GetAttribute",
      value: function GetAttribute(element, attrName, defaultValue) {
        var required = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        if (element.hasAttribute(attrName)) {
          return element.getAttribute(attrName);
        } else {
          if (required) {
            throw new XmlError(XE.ATTRIBUTE_MISSING, attrName, element.localName);
          }
          return defaultValue;
        }
      }
    }, {
      key: "GetElementById",
      value: function GetElementById(node, idValue) {
        if (node == null || idValue == null) {
          return null;
        }
        var xel = null;
        if (isDocument(node)) {
          xel = node.getElementById(idValue);
        }
        if (xel == null) {
          xel = SelectSingleNode(node, "//*[@*[local-name()='Id']='".concat(idValue, "']"));
          if (xel == null) {
            xel = SelectSingleNode(node, "//*[@*[local-name()='ID']='".concat(idValue, "']"));
            if (xel == null) {
              xel = SelectSingleNode(node, "//*[@*[local-name()='id']='".concat(idValue, "']"));
            }
          }
        }
        return xel;
      }
    }, {
      key: "CreateDocument",
      value: function CreateDocument() {
        var root = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_ROOT_NAME;
        var namespaceUri = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var namePrefix = "";
        var nsPrefix = "";
        var namespaceUri2 = "";
        if (prefix) {
          namePrefix = prefix + ":";
          nsPrefix = ":" + prefix;
        }
        if (namespaceUri) {
          namespaceUri2 = " xmlns".concat(nsPrefix, "=\"").concat(namespaceUri, "\"");
        }
        var name = "".concat(namePrefix).concat(root);
        var doc = new DOMParser().parseFromString("<".concat(name).concat(namespaceUri2, "></").concat(name, ">"), APPLICATION_XML);
        return doc;
      }
    }, {
      key: "GetChildren",
      value: function GetChildren(node, localName, nameSpace) {
        node = isDocument(node) ? node.documentElement : node;
        var res = [];
        for (var i = 0; i < node.childNodes.length; i++) {
          var child = node.childNodes[i];
          if (isElement(child) && child.localName === localName && (child.namespaceURI === nameSpace || !nameSpace)) {
            res.push(child);
          }
        }
        return res;
      }
    }, {
      key: "GetFirstChild",
      value: function GetFirstChild(node, localName, nameSpace) {
        node = isDocument(node) ? node.documentElement : node;
        for (var i = 0; i < node.childNodes.length; i++) {
          var child = node.childNodes[i];
          if (isElement(child) && child.localName === localName && (child.namespaceURI === nameSpace || !nameSpace)) {
            return child;
          }
        }
        return null;
      }
    }, {
      key: "GetChild",
      value: function GetChild(node, localName, nameSpace) {
        var required = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        for (var i = 0; i < node.childNodes.length; i++) {
          var child = node.childNodes[i];
          if (isElement(child) && child.localName === localName && (child.namespaceURI === nameSpace || !nameSpace)) {
            return child;
          }
        }
        if (required) {
          throw new XmlError(XE.ELEMENT_MISSING, localName, node.localName);
        }
        return null;
      }
    }]);
  }();
  var XmlCollection = function (_XmlObject) {
    function XmlCollection() {
      var _this;
      _classCallCheck(this, XmlCollection);
      _this = _callSuper(this, XmlCollection, arguments);
      _this.MaxOccurs = Number.MAX_VALUE;
      _this.MinOccurs = 0;
      _this.items = [];
      return _this;
    }
    _inherits(XmlCollection, _XmlObject);
    return _createClass(XmlCollection, [{
      key: "HasChanged",
      value: function HasChanged() {
        var res = _superPropGet(XmlCollection, "HasChanged", this, 3)([]);
        var changed = this.Some(function (item) {
          return item.HasChanged();
        });
        return res || changed;
      }
    }, {
      key: "Count",
      get: function get() {
        return this.items.length;
      }
    }, {
      key: "Item",
      value: function Item(index) {
        return this.items[index] || null;
      }
    }, {
      key: "Add",
      value: function Add(item) {
        this.items.push(item);
        this.element = null;
      }
    }, {
      key: "Pop",
      value: function Pop() {
        this.element = null;
        return this.items.pop();
      }
    }, {
      key: "RemoveAt",
      value: function RemoveAt(index) {
        this.items = this.items.filter(function (item, index2) {
          return index2 !== index;
        });
        this.element = null;
      }
    }, {
      key: "Clear",
      value: function Clear() {
        this.items = new Array();
        this.element = null;
      }
    }, {
      key: "GetIterator",
      value: function GetIterator() {
        return this.items;
      }
    }, {
      key: "ForEach",
      value: function ForEach(cb) {
        this.GetIterator().forEach(cb);
      }
    }, {
      key: "Map",
      value: function Map(cb) {
        return new Collection(this.GetIterator().map(cb));
      }
    }, {
      key: "Filter",
      value: function Filter(cb) {
        return new Collection(this.GetIterator().filter(cb));
      }
    }, {
      key: "Sort",
      value: function Sort(cb) {
        return new Collection(this.GetIterator().sort(cb));
      }
    }, {
      key: "Every",
      value: function Every(cb) {
        return this.GetIterator().every(cb);
      }
    }, {
      key: "Some",
      value: function Some(cb) {
        return this.GetIterator().some(cb);
      }
    }, {
      key: "IsEmpty",
      value: function IsEmpty() {
        return this.Count === 0;
      }
    }, {
      key: "OnGetXml",
      value: function OnGetXml(element) {
        var _iterator2 = _createForOfIteratorHelper(this.GetIterator()),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var item = _step2.value;
            var el = item.GetXml();
            if (el) {
              element.appendChild(el);
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    }, {
      key: "OnLoadXml",
      value: function OnLoadXml(element) {
        var self = this.GetStatic();
        if (!self.parser) {
          throw new XmlError(XE.XML_EXCEPTION, "".concat(self.localName, " doesn't have required 'parser' in @XmlElement"));
        }
        for (var i = 0; i < element.childNodes.length; i++) {
          var node = element.childNodes.item(i);
          if (!(isElement(node) && node.localName === self.parser.localName && node.namespaceURI == self.namespaceURI)) {
            continue;
          }
          var el = node;
          var item = new self.parser();
          item.LoadXml(el);
          this.Add(item);
        }
      }
    }]);
  }(XmlObject);
  var NamespaceManager = function (_Collection) {
    function NamespaceManager() {
      _classCallCheck(this, NamespaceManager);
      return _callSuper(this, NamespaceManager, arguments);
    }
    _inherits(NamespaceManager, _Collection);
    return _createClass(NamespaceManager, [{
      key: "Add",
      value: function Add(item) {
        item.prefix = item.prefix || "";
        item.namespace = item.namespace || "";
        _superPropGet(NamespaceManager, "Add", this, 3)([item]);
      }
    }, {
      key: "GetPrefix",
      value: function GetPrefix(prefix) {
        var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.Count - 1;
        var lim = this.Count - 1;
        prefix = prefix || "";
        if (start > lim) {
          start = lim;
        }
        for (var i = start; i >= 0; i--) {
          var item = this.items[i];
          if (item.prefix === prefix) {
            return item;
          }
        }
        return null;
      }
    }, {
      key: "GetNamespace",
      value: function GetNamespace(namespaceUrl) {
        var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.Count - 1;
        var lim = this.Count - 1;
        namespaceUrl = namespaceUrl || "";
        if (start > lim) {
          start = lim;
        }
        for (var i = start; i >= 0; i--) {
          var item = this.items[i];
          if (item.namespace === namespaceUrl) {
            return item;
          }
        }
        return null;
      }
    }]);
  }(Collection);
  var ARRAY_BUFFER_NAME = "[object ArrayBuffer]";
  var BufferSourceConverter = function () {
    function BufferSourceConverter() {
      _classCallCheck(this, BufferSourceConverter);
    }
    return _createClass(BufferSourceConverter, null, [{
      key: "isArrayBuffer",
      value: function isArrayBuffer(data) {
        return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;
      }
    }, {
      key: "toArrayBuffer",
      value: function toArrayBuffer(data) {
        if (this.isArrayBuffer(data)) {
          return data;
        }
        if (data.byteLength === data.buffer.byteLength) {
          return data.buffer;
        }
        if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
          return data.buffer;
        }
        return this.toUint8Array(data.buffer).slice(data.byteOffset, data.byteOffset + data.byteLength).buffer;
      }
    }, {
      key: "toUint8Array",
      value: function toUint8Array(data) {
        return this.toView(data, Uint8Array);
      }
    }, {
      key: "toView",
      value: function toView(data, type) {
        if (data.constructor === type) {
          return data;
        }
        if (this.isArrayBuffer(data)) {
          return new type(data);
        }
        if (this.isArrayBufferView(data)) {
          return new type(data.buffer, data.byteOffset, data.byteLength);
        }
        throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
      }
    }, {
      key: "isBufferSource",
      value: function isBufferSource(data) {
        return this.isArrayBufferView(data) || this.isArrayBuffer(data);
      }
    }, {
      key: "isArrayBufferView",
      value: function isArrayBufferView(data) {
        return ArrayBuffer.isView(data) || data && this.isArrayBuffer(data.buffer);
      }
    }, {
      key: "isEqual",
      value: function isEqual(a, b) {
        var aView = BufferSourceConverter.toUint8Array(a);
        var bView = BufferSourceConverter.toUint8Array(b);
        if (aView.length !== bView.byteLength) {
          return false;
        }
        for (var i = 0; i < aView.length; i++) {
          if (aView[i] !== bView[i]) {
            return false;
          }
        }
        return true;
      }
    }, {
      key: "concat",
      value: function concat() {
        var buffers;
        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }
        if (Array.isArray(args[0]) && !(args[1] instanceof Function)) {
          buffers = args[0];
        } else if (Array.isArray(args[0]) && args[1] instanceof Function) {
          buffers = args[0];
        } else {
          if (args[args.length - 1] instanceof Function) {
            buffers = args.slice(0, args.length - 1);
          } else {
            buffers = args;
          }
        }
        var size = 0;
        var _iterator3 = _createForOfIteratorHelper(buffers),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var buffer = _step3.value;
            size += buffer.byteLength;
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        var res = new Uint8Array(size);
        var offset = 0;
        var _iterator4 = _createForOfIteratorHelper(buffers),
          _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var _buffer = _step4.value;
            var view = this.toUint8Array(_buffer);
            res.set(view, offset);
            offset += view.length;
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
        if (args[args.length - 1] instanceof Function) {
          return this.toView(res, args[args.length - 1]);
        }
        return res.buffer;
      }
    }]);
  }();
  var STRING_TYPE = "string";
  var HEX_REGEX = /^[0-9a-f]+$/i;
  var BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
  var BASE64URL_REGEX = /^[a-zA-Z0-9-_]+$/;
  var Utf8Converter = function () {
    function Utf8Converter() {
      _classCallCheck(this, Utf8Converter);
    }
    return _createClass(Utf8Converter, null, [{
      key: "fromString",
      value: function fromString(text) {
        var s = unescape(encodeURIComponent(text));
        var uintArray = new Uint8Array(s.length);
        for (var i = 0; i < s.length; i++) {
          uintArray[i] = s.charCodeAt(i);
        }
        return uintArray.buffer;
      }
    }, {
      key: "toString",
      value: function toString(buffer) {
        var buf = BufferSourceConverter.toUint8Array(buffer);
        var encodedString = "";
        for (var i = 0; i < buf.length; i++) {
          encodedString += String.fromCharCode(buf[i]);
        }
        var decodedString = decodeURIComponent(escape(encodedString));
        return decodedString;
      }
    }]);
  }();
  var Utf16Converter = function () {
    function Utf16Converter() {
      _classCallCheck(this, Utf16Converter);
    }
    return _createClass(Utf16Converter, null, [{
      key: "toString",
      value: function toString(buffer) {
        var littleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var arrayBuffer = BufferSourceConverter.toArrayBuffer(buffer);
        var dataView = new DataView(arrayBuffer);
        var res = "";
        for (var i = 0; i < arrayBuffer.byteLength; i += 2) {
          var code = dataView.getUint16(i, littleEndian);
          res += String.fromCharCode(code);
        }
        return res;
      }
    }, {
      key: "fromString",
      value: function fromString(text) {
        var littleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var res = new ArrayBuffer(text.length * 2);
        var dataView = new DataView(res);
        for (var i = 0; i < text.length; i++) {
          dataView.setUint16(i * 2, text.charCodeAt(i), littleEndian);
        }
        return res;
      }
    }]);
  }();
  var Convert = function () {
    function Convert() {
      _classCallCheck(this, Convert);
    }
    return _createClass(Convert, null, [{
      key: "isHex",
      value: function isHex(data) {
        return _typeof(data) === STRING_TYPE && HEX_REGEX.test(data);
      }
    }, {
      key: "isBase64",
      value: function isBase64(data) {
        return _typeof(data) === STRING_TYPE && BASE64_REGEX.test(data);
      }
    }, {
      key: "isBase64Url",
      value: function isBase64Url(data) {
        return _typeof(data) === STRING_TYPE && BASE64URL_REGEX.test(data);
      }
    }, {
      key: "ToString",
      value: function ToString(buffer) {
        var enc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "utf8";
        var buf = BufferSourceConverter.toUint8Array(buffer);
        switch (enc.toLowerCase()) {
          case "utf8":
            return this.ToUtf8String(buf);
          case "binary":
            return this.ToBinary(buf);
          case "hex":
            return this.ToHex(buf);
          case "base64":
            return this.ToBase64(buf);
          case "base64url":
            return this.ToBase64Url(buf);
          case "utf16le":
            return Utf16Converter.toString(buf, true);
          case "utf16":
          case "utf16be":
            return Utf16Converter.toString(buf);
          default:
            throw new Error("Unknown type of encoding '".concat(enc, "'"));
        }
      }
    }, {
      key: "FromString",
      value: function FromString(str) {
        var enc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "utf8";
        if (!str) {
          return new ArrayBuffer(0);
        }
        switch (enc.toLowerCase()) {
          case "utf8":
            return this.FromUtf8String(str);
          case "binary":
            return this.FromBinary(str);
          case "hex":
            return this.FromHex(str);
          case "base64":
            return this.FromBase64(str);
          case "base64url":
            return this.FromBase64Url(str);
          case "utf16le":
            return Utf16Converter.fromString(str, true);
          case "utf16":
          case "utf16be":
            return Utf16Converter.fromString(str);
          default:
            throw new Error("Unknown type of encoding '".concat(enc, "'"));
        }
      }
    }, {
      key: "ToBase64",
      value: function ToBase64(buffer) {
        var buf = BufferSourceConverter.toUint8Array(buffer);
        if (typeof btoa !== "undefined") {
          var binary = this.ToString(buf, "binary");
          return btoa(binary);
        } else {
          return Buffer.from(buf).toString("base64");
        }
      }
    }, {
      key: "FromBase64",
      value: function FromBase64(base64) {
        var formatted = this.formatString(base64);
        if (!formatted) {
          return new ArrayBuffer(0);
        }
        if (!Convert.isBase64(formatted)) {
          throw new TypeError("Argument 'base64Text' is not Base64 encoded");
        }
        if (typeof atob !== "undefined") {
          return this.FromBinary(atob(formatted));
        } else {
          return new Uint8Array(Buffer.from(formatted, "base64")).buffer;
        }
      }
    }, {
      key: "FromBase64Url",
      value: function FromBase64Url(base64url) {
        var formatted = this.formatString(base64url);
        if (!formatted) {
          return new ArrayBuffer(0);
        }
        if (!Convert.isBase64Url(formatted)) {
          throw new TypeError("Argument 'base64url' is not Base64Url encoded");
        }
        return this.FromBase64(this.Base64Padding(formatted.replace(/\-/g, "+").replace(/\_/g, "/")));
      }
    }, {
      key: "ToBase64Url",
      value: function ToBase64Url(data) {
        return this.ToBase64(data).replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
      }
    }, {
      key: "FromUtf8String",
      value: function FromUtf8String(text) {
        var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Convert.DEFAULT_UTF8_ENCODING;
        switch (encoding) {
          case "ascii":
            return this.FromBinary(text);
          case "utf8":
            return Utf8Converter.fromString(text);
          case "utf16":
          case "utf16be":
            return Utf16Converter.fromString(text);
          case "utf16le":
          case "usc2":
            return Utf16Converter.fromString(text, true);
          default:
            throw new Error("Unknown type of encoding '".concat(encoding, "'"));
        }
      }
    }, {
      key: "ToUtf8String",
      value: function ToUtf8String(buffer) {
        var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Convert.DEFAULT_UTF8_ENCODING;
        switch (encoding) {
          case "ascii":
            return this.ToBinary(buffer);
          case "utf8":
            return Utf8Converter.toString(buffer);
          case "utf16":
          case "utf16be":
            return Utf16Converter.toString(buffer);
          case "utf16le":
          case "usc2":
            return Utf16Converter.toString(buffer, true);
          default:
            throw new Error("Unknown type of encoding '".concat(encoding, "'"));
        }
      }
    }, {
      key: "FromBinary",
      value: function FromBinary(text) {
        var stringLength = text.length;
        var resultView = new Uint8Array(stringLength);
        for (var i = 0; i < stringLength; i++) {
          resultView[i] = text.charCodeAt(i);
        }
        return resultView.buffer;
      }
    }, {
      key: "ToBinary",
      value: function ToBinary(buffer) {
        var buf = BufferSourceConverter.toUint8Array(buffer);
        var res = "";
        for (var i = 0; i < buf.length; i++) {
          res += String.fromCharCode(buf[i]);
        }
        return res;
      }
    }, {
      key: "ToHex",
      value: function ToHex(buffer) {
        var buf = BufferSourceConverter.toUint8Array(buffer);
        var result = "";
        var len = buf.length;
        for (var i = 0; i < len; i++) {
          var byte = buf[i];
          if (byte < 16) {
            result += "0";
          }
          result += byte.toString(16);
        }
        return result;
      }
    }, {
      key: "FromHex",
      value: function FromHex(hexString) {
        var formatted = this.formatString(hexString);
        if (!formatted) {
          return new ArrayBuffer(0);
        }
        if (!Convert.isHex(formatted)) {
          throw new TypeError("Argument 'hexString' is not HEX encoded");
        }
        if (formatted.length % 2) {
          formatted = "0".concat(formatted);
        }
        var res = new Uint8Array(formatted.length / 2);
        for (var i = 0; i < formatted.length; i = i + 2) {
          var c = formatted.slice(i, i + 2);
          res[i / 2] = parseInt(c, 16);
        }
        return res.buffer;
      }
    }, {
      key: "ToUtf16String",
      value: function ToUtf16String(buffer) {
        var littleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        return Utf16Converter.toString(buffer, littleEndian);
      }
    }, {
      key: "FromUtf16String",
      value: function FromUtf16String(text) {
        var littleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        return Utf16Converter.fromString(text, littleEndian);
      }
    }, {
      key: "Base64Padding",
      value: function Base64Padding(base64) {
        var padCount = 4 - base64.length % 4;
        if (padCount < 4) {
          for (var i = 0; i < padCount; i++) {
            base64 += "=";
          }
        }
        return base64;
      }
    }, {
      key: "formatString",
      value: function formatString(data) {
        return (data === null || data === void 0 ? void 0 : data.replace(/[\n\r\t ]/g, "")) || "";
      }
    }]);
  }();
  Convert.DEFAULT_UTF8_ENCODING = "utf8";
  function getParametersValue(parameters, name, defaultValue) {
    var _a;
    if (parameters instanceof Object === false) {
      return defaultValue;
    }
    return (_a = parameters[name]) !== null && _a !== void 0 ? _a : defaultValue;
  }
  function bufferToHexCodes(inputBuffer) {
    var inputOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var inputLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : inputBuffer.byteLength - inputOffset;
    var insertSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var result = "";
    var _iterator5 = _createForOfIteratorHelper(new Uint8Array(inputBuffer, inputOffset, inputLength)),
      _step5;
    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var item = _step5.value;
        var str = item.toString(16).toUpperCase();
        if (str.length === 1) {
          result += "0";
        }
        result += str;
        if (insertSpace) {
          result += " ";
        }
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }
    return result.trim();
  }
  function utilFromBase(inputBuffer, inputBase) {
    var result = 0;
    if (inputBuffer.length === 1) {
      return inputBuffer[0];
    }
    for (var i = inputBuffer.length - 1; i >= 0; i--) {
      result += inputBuffer[inputBuffer.length - 1 - i] * Math.pow(2, inputBase * i);
    }
    return result;
  }
  function utilToBase(value, base) {
    var reserved = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
    var internalReserved = reserved;
    var internalValue = value;
    var result = 0;
    var biggest = Math.pow(2, base);
    for (var i = 1; i < 8; i++) {
      if (value < biggest) {
        var retBuf = void 0;
        if (internalReserved < 0) {
          retBuf = new ArrayBuffer(i);
          result = i;
        } else {
          if (internalReserved < i) {
            return new ArrayBuffer(0);
          }
          retBuf = new ArrayBuffer(internalReserved);
          result = internalReserved;
        }
        var retView = new Uint8Array(retBuf);
        for (var j = i - 1; j >= 0; j--) {
          var basis = Math.pow(2, j * base);
          retView[result - j - 1] = Math.floor(internalValue / basis);
          internalValue -= retView[result - j - 1] * basis;
        }
        return retBuf;
      }
      biggest *= Math.pow(2, base);
    }
    return new ArrayBuffer(0);
  }
  function utilConcatBuf() {
    var outputLength = 0;
    var prevLength = 0;
    for (var _len6 = arguments.length, buffers = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      buffers[_key6] = arguments[_key6];
    }
    for (var _i2 = 0, _buffers = buffers; _i2 < _buffers.length; _i2++) {
      var buffer = _buffers[_i2];
      outputLength += buffer.byteLength;
    }
    var retBuf = new ArrayBuffer(outputLength);
    var retView = new Uint8Array(retBuf);
    for (var _i3 = 0, _buffers2 = buffers; _i3 < _buffers2.length; _i3++) {
      var _buffer2 = _buffers2[_i3];
      retView.set(new Uint8Array(_buffer2), prevLength);
      prevLength += _buffer2.byteLength;
    }
    return retBuf;
  }
  function utilConcatView() {
    var outputLength = 0;
    var prevLength = 0;
    for (var _len7 = arguments.length, views = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      views[_key7] = arguments[_key7];
    }
    for (var _i4 = 0, _views = views; _i4 < _views.length; _i4++) {
      var view = _views[_i4];
      outputLength += view.length;
    }
    var retBuf = new ArrayBuffer(outputLength);
    var retView = new Uint8Array(retBuf);
    for (var _i5 = 0, _views2 = views; _i5 < _views2.length; _i5++) {
      var _view2 = _views2[_i5];
      retView.set(_view2, prevLength);
      prevLength += _view2.length;
    }
    return retView;
  }
  function utilDecodeTC() {
    var buf = new Uint8Array(this.valueHex);
    if (this.valueHex.byteLength >= 2) {
      var condition1 = buf[0] === 0xFF && buf[1] & 0x80;
      var condition2 = buf[0] === 0x00 && (buf[1] & 0x80) === 0x00;
      if (condition1 || condition2) {
        this.warnings.push("Needlessly long format");
      }
    }
    var bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
    var bigIntView = new Uint8Array(bigIntBuffer);
    for (var i = 0; i < this.valueHex.byteLength; i++) {
      bigIntView[i] = 0;
    }
    bigIntView[0] = buf[0] & 0x80;
    var bigInt = utilFromBase(bigIntView, 8);
    var smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
    var smallIntView = new Uint8Array(smallIntBuffer);
    for (var j = 0; j < this.valueHex.byteLength; j++) {
      smallIntView[j] = buf[j];
    }
    smallIntView[0] &= 0x7F;
    var smallInt = utilFromBase(smallIntView, 8);
    return smallInt - bigInt;
  }
  function utilEncodeTC(value) {
    var modValue = value < 0 ? value * -1 : value;
    var bigInt = 128;
    for (var i = 1; i < 8; i++) {
      if (modValue <= bigInt) {
        if (value < 0) {
          var smallInt = bigInt - modValue;
          var _retBuf = utilToBase(smallInt, 8, i);
          var _retView = new Uint8Array(_retBuf);
          _retView[0] |= 0x80;
          return _retBuf;
        }
        var retBuf = utilToBase(modValue, 8, i);
        var retView = new Uint8Array(retBuf);
        if (retView[0] & 0x80) {
          var tempBuf = retBuf.slice(0);
          var tempView = new Uint8Array(tempBuf);
          retBuf = new ArrayBuffer(retBuf.byteLength + 1);
          retView = new Uint8Array(retBuf);
          for (var k = 0; k < tempBuf.byteLength; k++) {
            retView[k + 1] = tempView[k];
          }
          retView[0] = 0x00;
        }
        return retBuf;
      }
      bigInt *= Math.pow(2, 8);
    }
    return new ArrayBuffer(0);
  }
  function isEqualBuffer(inputBuffer1, inputBuffer2) {
    if (inputBuffer1.byteLength !== inputBuffer2.byteLength) {
      return false;
    }
    var view1 = new Uint8Array(inputBuffer1);
    var view2 = new Uint8Array(inputBuffer2);
    for (var i = 0; i < view1.length; i++) {
      if (view1[i] !== view2[i]) {
        return false;
      }
    }
    return true;
  }
  function padNumber(inputNumber, fullLength) {
    var str = inputNumber.toString(10);
    if (fullLength < str.length) {
      return "";
    }
    var dif = fullLength - str.length;
    var padding = new Array(dif);
    for (var i = 0; i < dif; i++) {
      padding[i] = "0";
    }
    var paddingString = padding.join("");
    return paddingString.concat(str);
  }
  var base64Template = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  var base64UrlTemplate = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";
  function toBase64(input) {
    var useUrlTemplate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var skipPadding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var skipLeadingZeros = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var i = 0;
    var flag1 = 0;
    var flag2 = 0;
    var output = "";
    var template = useUrlTemplate ? base64UrlTemplate : base64Template;
    if (skipLeadingZeros) {
      var nonZeroPosition = 0;
      for (var _i6 = 0; _i6 < input.length; _i6++) {
        if (input.charCodeAt(_i6) !== 0) {
          nonZeroPosition = _i6;
          break;
        }
      }
      input = input.slice(nonZeroPosition);
    }
    while (i < input.length) {
      var chr1 = input.charCodeAt(i++);
      if (i >= input.length) {
        flag1 = 1;
      }
      var chr2 = input.charCodeAt(i++);
      if (i >= input.length) {
        flag2 = 1;
      }
      var chr3 = input.charCodeAt(i++);
      var enc1 = chr1 >> 2;
      var enc2 = (chr1 & 0x03) << 4 | chr2 >> 4;
      var enc3 = (chr2 & 0x0F) << 2 | chr3 >> 6;
      var enc4 = chr3 & 0x3F;
      if (flag1 === 1) {
        enc3 = enc4 = 64;
      } else {
        if (flag2 === 1) {
          enc4 = 64;
        }
      }
      if (skipPadding) {
        if (enc3 === 64) {
          output += "".concat(template.charAt(enc1)).concat(template.charAt(enc2));
        } else {
          if (enc4 === 64) {
            output += "".concat(template.charAt(enc1)).concat(template.charAt(enc2)).concat(template.charAt(enc3));
          } else {
            output += "".concat(template.charAt(enc1)).concat(template.charAt(enc2)).concat(template.charAt(enc3)).concat(template.charAt(enc4));
          }
        }
      } else {
        output += "".concat(template.charAt(enc1)).concat(template.charAt(enc2)).concat(template.charAt(enc3)).concat(template.charAt(enc4));
      }
    }
    return output;
  }
  function fromBase64(input) {
    var useUrlTemplate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var cutTailZeros = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var template = useUrlTemplate ? base64UrlTemplate : base64Template;
    function indexOf(toSearch) {
      for (var _i7 = 0; _i7 < 64; _i7++) {
        if (template.charAt(_i7) === toSearch) return _i7;
      }
      return 64;
    }
    function test(incoming) {
      return incoming === 64 ? 0x00 : incoming;
    }
    var i = 0;
    var output = "";
    while (i < input.length) {
      var enc1 = indexOf(input.charAt(i++));
      var enc2 = i >= input.length ? 0x00 : indexOf(input.charAt(i++));
      var enc3 = i >= input.length ? 0x00 : indexOf(input.charAt(i++));
      var enc4 = i >= input.length ? 0x00 : indexOf(input.charAt(i++));
      var chr1 = test(enc1) << 2 | test(enc2) >> 4;
      var chr2 = (test(enc2) & 0x0F) << 4 | test(enc3) >> 2;
      var chr3 = (test(enc3) & 0x03) << 6 | test(enc4);
      output += String.fromCharCode(chr1);
      if (enc3 !== 64) {
        output += String.fromCharCode(chr2);
      }
      if (enc4 !== 64) {
        output += String.fromCharCode(chr3);
      }
    }
    if (cutTailZeros) {
      var outputLength = output.length;
      var nonZeroStart = -1;
      for (var _i8 = outputLength - 1; _i8 >= 0; _i8--) {
        if (output.charCodeAt(_i8) !== 0) {
          nonZeroStart = _i8;
          break;
        }
      }
      if (nonZeroStart !== -1) {
        output = output.slice(0, nonZeroStart + 1);
      } else {
        output = "";
      }
    }
    return output;
  }
  function arrayBufferToString(buffer) {
    var resultString = "";
    var view = new Uint8Array(buffer);
    var _iterator6 = _createForOfIteratorHelper(view),
      _step6;
    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
        var element = _step6.value;
        resultString += String.fromCharCode(element);
      }
    } catch (err) {
      _iterator6.e(err);
    } finally {
      _iterator6.f();
    }
    return resultString;
  }
  function stringToArrayBuffer(str) {
    var stringLength = str.length;
    var resultBuffer = new ArrayBuffer(stringLength);
    var resultView = new Uint8Array(resultBuffer);
    for (var i = 0; i < stringLength; i++) {
      resultView[i] = str.charCodeAt(i);
    }
    return resultBuffer;
  }
  var log2 = Math.log(2);
  function nearestPowerOf2(length) {
    var base = Math.log(length) / log2;
    var floor = Math.floor(base);
    var round = Math.round(base);
    return floor === round ? floor : round;
  }
  function clearProps(object, propsArray) {
    var _iterator7 = _createForOfIteratorHelper(propsArray),
      _step7;
    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        var prop = _step7.value;
        delete object[prop];
      }
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }
  }
  function assertBigInt() {
    if (typeof BigInt === "undefined") {
      throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.");
    }
  }
  function concat(buffers) {
    var outputLength = 0;
    var prevLength = 0;
    for (var i = 0; i < buffers.length; i++) {
      var buffer = buffers[i];
      outputLength += buffer.byteLength;
    }
    var retView = new Uint8Array(outputLength);
    for (var _i9 = 0; _i9 < buffers.length; _i9++) {
      var _buffer3 = buffers[_i9];
      retView.set(new Uint8Array(_buffer3), prevLength);
      prevLength += _buffer3.byteLength;
    }
    return retView.buffer;
  }
  function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {
    if (!(inputBuffer instanceof Uint8Array)) {
      baseBlock.error = "Wrong parameter: inputBuffer must be 'Uint8Array'";
      return false;
    }
    if (!inputBuffer.byteLength) {
      baseBlock.error = "Wrong parameter: inputBuffer has zero length";
      return false;
    }
    if (inputOffset < 0) {
      baseBlock.error = "Wrong parameter: inputOffset less than zero";
      return false;
    }
    if (inputLength < 0) {
      baseBlock.error = "Wrong parameter: inputLength less than zero";
      return false;
    }
    if (inputBuffer.byteLength - inputOffset - inputLength < 0) {
      baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
      return false;
    }
    return true;
  }
  var ViewWriter = function () {
    function ViewWriter() {
      _classCallCheck(this, ViewWriter);
      this.items = [];
    }
    return _createClass(ViewWriter, [{
      key: "write",
      value: function write(buf) {
        this.items.push(buf);
      }
    }, {
      key: "final",
      value: function final() {
        return concat(this.items);
      }
    }]);
  }();
  var powers2 = [new Uint8Array([1])];
  var digitsString = "0123456789";
  var NAME = "name";
  var VALUE_HEX_VIEW = "valueHexView";
  var IS_HEX_ONLY = "isHexOnly";
  var ID_BLOCK = "idBlock";
  var TAG_CLASS = "tagClass";
  var TAG_NUMBER = "tagNumber";
  var IS_CONSTRUCTED = "isConstructed";
  var FROM_BER = "fromBER";
  var TO_BER = "toBER";
  var LOCAL = "local";
  var EMPTY_STRING$1 = "";
  var EMPTY_BUFFER$1 = new ArrayBuffer(0);
  var EMPTY_VIEW = new Uint8Array(0);
  var END_OF_CONTENT_NAME = "EndOfContent";
  var OCTET_STRING_NAME = "OCTET STRING";
  var BIT_STRING_NAME = "BIT STRING";
  function HexBlock(BaseClass) {
    var _a;
    return _a = function (_BaseClass) {
      function Some() {
        var _this2;
        _classCallCheck(this, Some);
        var _a;
        for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
          args[_key8] = arguments[_key8];
        }
        _this2 = _callSuper(this, Some, [].concat(args));
        var params = args[0] || {};
        _this2.isHexOnly = (_a = params.isHexOnly) !== null && _a !== void 0 ? _a : false;
        _this2.valueHexView = params.valueHex ? BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW;
        return _this2;
      }
      _inherits(Some, _BaseClass);
      return _createClass(Some, [{
        key: "valueHex",
        get: function get() {
          return this.valueHexView.slice().buffer;
        },
        set: function set(value) {
          this.valueHexView = new Uint8Array(value);
        }
      }, {
        key: "fromBER",
        value: function fromBER(inputBuffer, inputOffset, inputLength) {
          var view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
          if (!checkBufferParams(this, view, inputOffset, inputLength)) {
            return -1;
          }
          var endLength = inputOffset + inputLength;
          this.valueHexView = view.subarray(inputOffset, endLength);
          if (!this.valueHexView.length) {
            this.warnings.push("Zero buffer length");
            return inputOffset;
          }
          this.blockLength = inputLength;
          return endLength;
        }
      }, {
        key: "toBER",
        value: function toBER() {
          var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          if (!this.isHexOnly) {
            this.error = "Flag 'isHexOnly' is not set, abort";
            return EMPTY_BUFFER$1;
          }
          if (sizeOnly) {
            return new ArrayBuffer(this.valueHexView.byteLength);
          }
          return this.valueHexView.byteLength === this.valueHexView.buffer.byteLength ? this.valueHexView.buffer : this.valueHexView.slice().buffer;
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return _objectSpread2(_objectSpread2({}, _superPropGet(Some, "toJSON", this, 3)([])), {}, {
            isHexOnly: this.isHexOnly,
            valueHex: Convert.ToHex(this.valueHexView)
          });
        }
      }]);
    }(BaseClass), _a.NAME = "hexBlock", _a;
  }
  var LocalBaseBlock = function () {
    function LocalBaseBlock() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$blockLength = _ref.blockLength,
        blockLength = _ref$blockLength === void 0 ? 0 : _ref$blockLength,
        _ref$error = _ref.error,
        error = _ref$error === void 0 ? EMPTY_STRING$1 : _ref$error,
        _ref$warnings = _ref.warnings,
        warnings = _ref$warnings === void 0 ? [] : _ref$warnings,
        _ref$valueBeforeDecod = _ref.valueBeforeDecode,
        valueBeforeDecode = _ref$valueBeforeDecod === void 0 ? EMPTY_VIEW : _ref$valueBeforeDecod;
      _classCallCheck(this, LocalBaseBlock);
      this.blockLength = blockLength;
      this.error = error;
      this.warnings = warnings;
      this.valueBeforeDecodeView = BufferSourceConverter.toUint8Array(valueBeforeDecode);
    }
    return _createClass(LocalBaseBlock, [{
      key: "valueBeforeDecode",
      get: function get() {
        return this.valueBeforeDecodeView.slice().buffer;
      },
      set: function set(value) {
        this.valueBeforeDecodeView = new Uint8Array(value);
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          blockName: this.constructor.NAME,
          blockLength: this.blockLength,
          error: this.error,
          warnings: this.warnings,
          valueBeforeDecode: Convert.ToHex(this.valueBeforeDecodeView)
        };
      }
    }], [{
      key: "blockName",
      value: function blockName() {
        return this.NAME;
      }
    }]);
  }();
  LocalBaseBlock.NAME = "baseBlock";
  var ValueBlock = function (_LocalBaseBlock) {
    function ValueBlock() {
      _classCallCheck(this, ValueBlock);
      return _callSuper(this, ValueBlock, arguments);
    }
    _inherits(ValueBlock, _LocalBaseBlock);
    return _createClass(ValueBlock, [{
      key: "fromBER",
      value: function fromBER(inputBuffer, inputOffset, inputLength) {
        throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
      }
    }, {
      key: "toBER",
      value: function toBER(sizeOnly, writer) {
        throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
      }
    }]);
  }(LocalBaseBlock);
  ValueBlock.NAME = "valueBlock";
  var LocalIdentificationBlock = function (_HexBlock) {
    function LocalIdentificationBlock() {
      var _this3;
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$idBlock = _ref2.idBlock,
        idBlock = _ref2$idBlock === void 0 ? {} : _ref2$idBlock;
      _classCallCheck(this, LocalIdentificationBlock);
      var _a, _b, _c, _d;
      _this3 = _callSuper(this, LocalIdentificationBlock);
      if (idBlock) {
        _this3.isHexOnly = (_a = idBlock.isHexOnly) !== null && _a !== void 0 ? _a : false;
        _this3.valueHexView = idBlock.valueHex ? BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW;
        _this3.tagClass = (_b = idBlock.tagClass) !== null && _b !== void 0 ? _b : -1;
        _this3.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== void 0 ? _c : -1;
        _this3.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== void 0 ? _d : false;
      } else {
        _this3.tagClass = -1;
        _this3.tagNumber = -1;
        _this3.isConstructed = false;
      }
      return _this3;
    }
    _inherits(LocalIdentificationBlock, _HexBlock);
    return _createClass(LocalIdentificationBlock, [{
      key: "toBER",
      value: function toBER() {
        var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var firstOctet = 0;
        switch (this.tagClass) {
          case 1:
            firstOctet |= 0x00;
            break;
          case 2:
            firstOctet |= 0x40;
            break;
          case 3:
            firstOctet |= 0x80;
            break;
          case 4:
            firstOctet |= 0xC0;
            break;
          default:
            this.error = "Unknown tag class";
            return EMPTY_BUFFER$1;
        }
        if (this.isConstructed) firstOctet |= 0x20;
        if (this.tagNumber < 31 && !this.isHexOnly) {
          var _retView2 = new Uint8Array(1);
          if (!sizeOnly) {
            var number = this.tagNumber;
            number &= 0x1F;
            firstOctet |= number;
            _retView2[0] = firstOctet;
          }
          return _retView2.buffer;
        }
        if (!this.isHexOnly) {
          var encodedBuf = utilToBase(this.tagNumber, 7);
          var encodedView = new Uint8Array(encodedBuf);
          var size = encodedBuf.byteLength;
          var _retView3 = new Uint8Array(size + 1);
          _retView3[0] = firstOctet | 0x1F;
          if (!sizeOnly) {
            for (var i = 0; i < size - 1; i++) _retView3[i + 1] = encodedView[i] | 0x80;
            _retView3[size] = encodedView[size - 1];
          }
          return _retView3.buffer;
        }
        var retView = new Uint8Array(this.valueHexView.byteLength + 1);
        retView[0] = firstOctet | 0x1F;
        if (!sizeOnly) {
          var curView = this.valueHexView;
          for (var _i10 = 0; _i10 < curView.length - 1; _i10++) retView[_i10 + 1] = curView[_i10] | 0x80;
          retView[this.valueHexView.byteLength] = curView[curView.length - 1];
        }
        return retView.buffer;
      }
    }, {
      key: "fromBER",
      value: function fromBER(inputBuffer, inputOffset, inputLength) {
        var inputView = BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
          return -1;
        }
        var intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        if (intBuffer.length === 0) {
          this.error = "Zero buffer length";
          return -1;
        }
        var tagClassMask = intBuffer[0] & 0xC0;
        switch (tagClassMask) {
          case 0x00:
            this.tagClass = 1;
            break;
          case 0x40:
            this.tagClass = 2;
            break;
          case 0x80:
            this.tagClass = 3;
            break;
          case 0xC0:
            this.tagClass = 4;
            break;
          default:
            this.error = "Unknown tag class";
            return -1;
        }
        this.isConstructed = (intBuffer[0] & 0x20) === 0x20;
        this.isHexOnly = false;
        var tagNumberMask = intBuffer[0] & 0x1F;
        if (tagNumberMask !== 0x1F) {
          this.tagNumber = tagNumberMask;
          this.blockLength = 1;
        } else {
          var count = 1;
          var intTagNumberBuffer = this.valueHexView = new Uint8Array(255);
          var tagNumberBufferMaxLength = 255;
          while (intBuffer[count] & 0x80) {
            intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;
            count++;
            if (count >= intBuffer.length) {
              this.error = "End of input reached before message was fully decoded";
              return -1;
            }
            if (count === tagNumberBufferMaxLength) {
              tagNumberBufferMaxLength += 255;
              var _tempBufferView = new Uint8Array(tagNumberBufferMaxLength);
              for (var i = 0; i < intTagNumberBuffer.length; i++) _tempBufferView[i] = intTagNumberBuffer[i];
              intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);
            }
          }
          this.blockLength = count + 1;
          intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;
          var tempBufferView = new Uint8Array(count);
          for (var _i11 = 0; _i11 < count; _i11++) tempBufferView[_i11] = intTagNumberBuffer[_i11];
          intTagNumberBuffer = this.valueHexView = new Uint8Array(count);
          intTagNumberBuffer.set(tempBufferView);
          if (this.blockLength <= 9) this.tagNumber = utilFromBase(intTagNumberBuffer, 7);else {
            this.isHexOnly = true;
            this.warnings.push("Tag too long, represented as hex-coded");
          }
        }
        if (this.tagClass === 1 && this.isConstructed) {
          switch (this.tagNumber) {
            case 1:
            case 2:
            case 5:
            case 6:
            case 9:
            case 13:
            case 14:
            case 23:
            case 24:
            case 31:
            case 32:
            case 33:
            case 34:
              this.error = "Constructed encoding used for primitive type";
              return -1;
          }
        }
        return inputOffset + this.blockLength;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return _objectSpread2(_objectSpread2({}, _superPropGet(LocalIdentificationBlock, "toJSON", this, 3)([])), {}, {
          tagClass: this.tagClass,
          tagNumber: this.tagNumber,
          isConstructed: this.isConstructed
        });
      }
    }]);
  }(HexBlock(LocalBaseBlock));
  LocalIdentificationBlock.NAME = "identificationBlock";
  var LocalLengthBlock = function (_LocalBaseBlock2) {
    function LocalLengthBlock() {
      var _this4;
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref3$lenBlock = _ref3.lenBlock,
        lenBlock = _ref3$lenBlock === void 0 ? {} : _ref3$lenBlock;
      _classCallCheck(this, LocalLengthBlock);
      var _a, _b, _c;
      _this4 = _callSuper(this, LocalLengthBlock);
      _this4.isIndefiniteForm = (_a = lenBlock.isIndefiniteForm) !== null && _a !== void 0 ? _a : false;
      _this4.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== void 0 ? _b : false;
      _this4.length = (_c = lenBlock.length) !== null && _c !== void 0 ? _c : 0;
      return _this4;
    }
    _inherits(LocalLengthBlock, _LocalBaseBlock2);
    return _createClass(LocalLengthBlock, [{
      key: "fromBER",
      value: function fromBER(inputBuffer, inputOffset, inputLength) {
        var view = BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, view, inputOffset, inputLength)) {
          return -1;
        }
        var intBuffer = view.subarray(inputOffset, inputOffset + inputLength);
        if (intBuffer.length === 0) {
          this.error = "Zero buffer length";
          return -1;
        }
        if (intBuffer[0] === 0xFF) {
          this.error = "Length block 0xFF is reserved by standard";
          return -1;
        }
        this.isIndefiniteForm = intBuffer[0] === 0x80;
        if (this.isIndefiniteForm) {
          this.blockLength = 1;
          return inputOffset + this.blockLength;
        }
        this.longFormUsed = !!(intBuffer[0] & 0x80);
        if (this.longFormUsed === false) {
          this.length = intBuffer[0];
          this.blockLength = 1;
          return inputOffset + this.blockLength;
        }
        var count = intBuffer[0] & 0x7F;
        if (count > 8) {
          this.error = "Too big integer";
          return -1;
        }
        if (count + 1 > intBuffer.length) {
          this.error = "End of input reached before message was fully decoded";
          return -1;
        }
        var lenOffset = inputOffset + 1;
        var lengthBufferView = view.subarray(lenOffset, lenOffset + count);
        if (lengthBufferView[count - 1] === 0x00) this.warnings.push("Needlessly long encoded length");
        this.length = utilFromBase(lengthBufferView, 8);
        if (this.longFormUsed && this.length <= 127) this.warnings.push("Unnecessary usage of long length form");
        this.blockLength = count + 1;
        return inputOffset + this.blockLength;
      }
    }, {
      key: "toBER",
      value: function toBER() {
        var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var retBuf;
        var retView;
        if (this.length > 127) this.longFormUsed = true;
        if (this.isIndefiniteForm) {
          retBuf = new ArrayBuffer(1);
          if (sizeOnly === false) {
            retView = new Uint8Array(retBuf);
            retView[0] = 0x80;
          }
          return retBuf;
        }
        if (this.longFormUsed) {
          var encodedBuf = utilToBase(this.length, 8);
          if (encodedBuf.byteLength > 127) {
            this.error = "Too big length";
            return EMPTY_BUFFER$1;
          }
          retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);
          if (sizeOnly) return retBuf;
          var encodedView = new Uint8Array(encodedBuf);
          retView = new Uint8Array(retBuf);
          retView[0] = encodedBuf.byteLength | 0x80;
          for (var i = 0; i < encodedBuf.byteLength; i++) retView[i + 1] = encodedView[i];
          return retBuf;
        }
        retBuf = new ArrayBuffer(1);
        if (sizeOnly === false) {
          retView = new Uint8Array(retBuf);
          retView[0] = this.length;
        }
        return retBuf;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return _objectSpread2(_objectSpread2({}, _superPropGet(LocalLengthBlock, "toJSON", this, 3)([])), {}, {
          isIndefiniteForm: this.isIndefiniteForm,
          longFormUsed: this.longFormUsed,
          length: this.length
        });
      }
    }]);
  }(LocalBaseBlock);
  LocalLengthBlock.NAME = "lengthBlock";
  var typeStore = {};
  var BaseBlock = function (_LocalBaseBlock3) {
    function BaseBlock() {
      var _this5;
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var valueBlockType = arguments.length > 1 ? arguments[1] : undefined;
      var _ref4$name = _ref4.name,
        name = _ref4$name === void 0 ? EMPTY_STRING$1 : _ref4$name,
        _ref4$optional = _ref4.optional,
        optional = _ref4$optional === void 0 ? false : _ref4$optional,
        primitiveSchema = _ref4.primitiveSchema,
        parameters = _objectWithoutProperties(_ref4, _excluded);
      _classCallCheck(this, BaseBlock);
      _this5 = _callSuper(this, BaseBlock, [parameters]);
      _this5.name = name;
      _this5.optional = optional;
      if (primitiveSchema) {
        _this5.primitiveSchema = primitiveSchema;
      }
      _this5.idBlock = new LocalIdentificationBlock(parameters);
      _this5.lenBlock = new LocalLengthBlock(parameters);
      _this5.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock(parameters);
      return _this5;
    }
    _inherits(BaseBlock, _LocalBaseBlock3);
    return _createClass(BaseBlock, [{
      key: "fromBER",
      value: function fromBER(inputBuffer, inputOffset, inputLength) {
        var resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
          this.error = this.valueBlock.error;
          return resultOffset;
        }
        if (!this.idBlock.error.length) this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length) this.blockLength += this.lenBlock.blockLength;
        if (!this.valueBlock.error.length) this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
      }
    }, {
      key: "toBER",
      value: function toBER(sizeOnly, writer) {
        var _writer = writer || new ViewWriter();
        if (!writer) {
          prepareIndefiniteForm(this);
        }
        var idBlockBuf = this.idBlock.toBER(sizeOnly);
        _writer.write(idBlockBuf);
        if (this.lenBlock.isIndefiniteForm) {
          _writer.write(new Uint8Array([0x80]).buffer);
          this.valueBlock.toBER(sizeOnly, _writer);
          _writer.write(new ArrayBuffer(2));
        } else {
          var valueBlockBuf = this.valueBlock.toBER(sizeOnly);
          this.lenBlock.length = valueBlockBuf.byteLength;
          var lenBlockBuf = this.lenBlock.toBER(sizeOnly);
          _writer.write(lenBlockBuf);
          _writer.write(valueBlockBuf);
        }
        if (!writer) {
          return _writer.final();
        }
        return EMPTY_BUFFER$1;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var object = _objectSpread2(_objectSpread2({}, _superPropGet(BaseBlock, "toJSON", this, 3)([])), {}, {
          idBlock: this.idBlock.toJSON(),
          lenBlock: this.lenBlock.toJSON(),
          valueBlock: this.valueBlock.toJSON(),
          name: this.name,
          optional: this.optional
        });
        if (this.primitiveSchema) object.primitiveSchema = this.primitiveSchema.toJSON();
        return object;
      }
    }, {
      key: "toString",
      value: function toString() {
        var encoding = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "ascii";
        if (encoding === "ascii") {
          return this.onAsciiEncoding();
        }
        return Convert.ToHex(this.toBER());
      }
    }, {
      key: "onAsciiEncoding",
      value: function onAsciiEncoding() {
        return "".concat(this.constructor.NAME, " : ").concat(Convert.ToHex(this.valueBlock.valueBeforeDecodeView));
      }
    }, {
      key: "isEqual",
      value: function isEqual(other) {
        if (this === other) {
          return true;
        }
        if (!(other instanceof this.constructor)) {
          return false;
        }
        var thisRaw = this.toBER();
        var otherRaw = other.toBER();
        return isEqualBuffer(thisRaw, otherRaw);
      }
    }]);
  }(LocalBaseBlock);
  BaseBlock.NAME = "BaseBlock";
  function prepareIndefiniteForm(baseBlock) {
    if (baseBlock instanceof typeStore.Constructed) {
      var _iterator8 = _createForOfIteratorHelper(baseBlock.valueBlock.value),
        _step8;
      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var value = _step8.value;
          if (prepareIndefiniteForm(value)) {
            baseBlock.lenBlock.isIndefiniteForm = true;
          }
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }
    }
    return !!baseBlock.lenBlock.isIndefiniteForm;
  }
  var BaseStringBlock = function (_BaseBlock) {
    function BaseStringBlock() {
      var _this6;
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var stringValueBlockType = arguments.length > 1 ? arguments[1] : undefined;
      var _ref5$value = _ref5.value,
        value = _ref5$value === void 0 ? EMPTY_STRING$1 : _ref5$value,
        parameters = _objectWithoutProperties(_ref5, _excluded2);
      _classCallCheck(this, BaseStringBlock);
      _this6 = _callSuper(this, BaseStringBlock, [parameters, stringValueBlockType]);
      if (value) {
        _this6.fromString(value);
      }
      return _this6;
    }
    _inherits(BaseStringBlock, _BaseBlock);
    return _createClass(BaseStringBlock, [{
      key: "getValue",
      value: function getValue() {
        return this.valueBlock.value;
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        this.valueBlock.value = value;
      }
    }, {
      key: "fromBER",
      value: function fromBER(inputBuffer, inputOffset, inputLength) {
        var resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
          this.error = this.valueBlock.error;
          return resultOffset;
        }
        this.fromBuffer(this.valueBlock.valueHexView);
        if (!this.idBlock.error.length) this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length) this.blockLength += this.lenBlock.blockLength;
        if (!this.valueBlock.error.length) this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
      }
    }, {
      key: "onAsciiEncoding",
      value: function onAsciiEncoding() {
        return "".concat(this.constructor.NAME, " : '").concat(this.valueBlock.value, "'");
      }
    }]);
  }(BaseBlock);
  BaseStringBlock.NAME = "BaseStringBlock";
  var LocalPrimitiveValueBlock = function (_HexBlock2) {
    function LocalPrimitiveValueBlock() {
      var _this7;
      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _ref6$isHexOnly = _ref6.isHexOnly,
        isHexOnly = _ref6$isHexOnly === void 0 ? true : _ref6$isHexOnly,
        parameters = _objectWithoutProperties(_ref6, _excluded3);
      _classCallCheck(this, LocalPrimitiveValueBlock);
      _this7 = _callSuper(this, LocalPrimitiveValueBlock, [parameters]);
      _this7.isHexOnly = isHexOnly;
      return _this7;
    }
    _inherits(LocalPrimitiveValueBlock, _HexBlock2);
    return _createClass(LocalPrimitiveValueBlock);
  }(HexBlock(ValueBlock));
  LocalPrimitiveValueBlock.NAME = "PrimitiveValueBlock";
  var _a$w;
  var Primitive = function (_BaseBlock2) {
    function Primitive() {
      var _this8;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Primitive);
      _this8 = _callSuper(this, Primitive, [parameters, LocalPrimitiveValueBlock]);
      _this8.idBlock.isConstructed = false;
      return _this8;
    }
    _inherits(Primitive, _BaseBlock2);
    return _createClass(Primitive);
  }(BaseBlock);
  _a$w = Primitive;
  (function () {
    typeStore.Primitive = _a$w;
  })();
  Primitive.NAME = "PRIMITIVE";
  function localChangeType(inputObject, newType) {
    if (inputObject instanceof newType) {
      return inputObject;
    }
    var newObject = new newType();
    newObject.idBlock = inputObject.idBlock;
    newObject.lenBlock = inputObject.lenBlock;
    newObject.warnings = inputObject.warnings;
    newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;
    return newObject;
  }
  function localFromBER(inputBuffer) {
    var inputOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var inputLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : inputBuffer.length;
    var incomingOffset = inputOffset;
    var returnObject = new BaseBlock({}, ValueBlock);
    var baseBlock = new LocalBaseBlock();
    if (!checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)) {
      returnObject.error = baseBlock.error;
      return {
        offset: -1,
        result: returnObject
      };
    }
    var intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);
    if (!intBuffer.length) {
      returnObject.error = "Zero buffer length";
      return {
        offset: -1,
        result: returnObject
      };
    }
    var resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
    if (returnObject.idBlock.warnings.length) {
      returnObject.warnings.concat(returnObject.idBlock.warnings);
    }
    if (resultOffset === -1) {
      returnObject.error = returnObject.idBlock.error;
      return {
        offset: -1,
        result: returnObject
      };
    }
    inputOffset = resultOffset;
    inputLength -= returnObject.idBlock.blockLength;
    resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
    if (returnObject.lenBlock.warnings.length) {
      returnObject.warnings.concat(returnObject.lenBlock.warnings);
    }
    if (resultOffset === -1) {
      returnObject.error = returnObject.lenBlock.error;
      return {
        offset: -1,
        result: returnObject
      };
    }
    inputOffset = resultOffset;
    inputLength -= returnObject.lenBlock.blockLength;
    if (!returnObject.idBlock.isConstructed && returnObject.lenBlock.isIndefiniteForm) {
      returnObject.error = "Indefinite length form used for primitive encoding form";
      return {
        offset: -1,
        result: returnObject
      };
    }
    var newASN1Type = BaseBlock;
    switch (returnObject.idBlock.tagClass) {
      case 1:
        if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {
          returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
          return {
            offset: -1,
            result: returnObject
          };
        }
        switch (returnObject.idBlock.tagNumber) {
          case 0:
            if (returnObject.idBlock.isConstructed && returnObject.lenBlock.length > 0) {
              returnObject.error = "Type [UNIVERSAL 0] is reserved";
              return {
                offset: -1,
                result: returnObject
              };
            }
            newASN1Type = typeStore.EndOfContent;
            break;
          case 1:
            newASN1Type = typeStore.Boolean;
            break;
          case 2:
            newASN1Type = typeStore.Integer;
            break;
          case 3:
            newASN1Type = typeStore.BitString;
            break;
          case 4:
            newASN1Type = typeStore.OctetString;
            break;
          case 5:
            newASN1Type = typeStore.Null;
            break;
          case 6:
            newASN1Type = typeStore.ObjectIdentifier;
            break;
          case 10:
            newASN1Type = typeStore.Enumerated;
            break;
          case 12:
            newASN1Type = typeStore.Utf8String;
            break;
          case 13:
            newASN1Type = typeStore.RelativeObjectIdentifier;
            break;
          case 14:
            newASN1Type = typeStore.TIME;
            break;
          case 15:
            returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
            return {
              offset: -1,
              result: returnObject
            };
          case 16:
            newASN1Type = typeStore.Sequence;
            break;
          case 17:
            newASN1Type = typeStore.Set;
            break;
          case 18:
            newASN1Type = typeStore.NumericString;
            break;
          case 19:
            newASN1Type = typeStore.PrintableString;
            break;
          case 20:
            newASN1Type = typeStore.TeletexString;
            break;
          case 21:
            newASN1Type = typeStore.VideotexString;
            break;
          case 22:
            newASN1Type = typeStore.IA5String;
            break;
          case 23:
            newASN1Type = typeStore.UTCTime;
            break;
          case 24:
            newASN1Type = typeStore.GeneralizedTime;
            break;
          case 25:
            newASN1Type = typeStore.GraphicString;
            break;
          case 26:
            newASN1Type = typeStore.VisibleString;
            break;
          case 27:
            newASN1Type = typeStore.GeneralString;
            break;
          case 28:
            newASN1Type = typeStore.UniversalString;
            break;
          case 29:
            newASN1Type = typeStore.CharacterString;
            break;
          case 30:
            newASN1Type = typeStore.BmpString;
            break;
          case 31:
            newASN1Type = typeStore.DATE;
            break;
          case 32:
            newASN1Type = typeStore.TimeOfDay;
            break;
          case 33:
            newASN1Type = typeStore.DateTime;
            break;
          case 34:
            newASN1Type = typeStore.Duration;
            break;
          default:
            {
              var newObject = returnObject.idBlock.isConstructed ? new typeStore.Constructed() : new typeStore.Primitive();
              newObject.idBlock = returnObject.idBlock;
              newObject.lenBlock = returnObject.lenBlock;
              newObject.warnings = returnObject.warnings;
              returnObject = newObject;
            }
        }
        break;
      case 2:
      case 3:
      case 4:
      default:
        {
          newASN1Type = returnObject.idBlock.isConstructed ? typeStore.Constructed : typeStore.Primitive;
        }
    }
    returnObject = localChangeType(returnObject, newASN1Type);
    resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);
    returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);
    return {
      offset: resultOffset,
      result: returnObject
    };
  }
  function _fromBER(inputBuffer) {
    if (!inputBuffer.byteLength) {
      var result = new BaseBlock({}, ValueBlock);
      result.error = "Input buffer has zero length";
      return {
        offset: -1,
        result: result
      };
    }
    return localFromBER(BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);
  }
  function checkLen(indefiniteLength, length) {
    if (indefiniteLength) {
      return 1;
    }
    return length;
  }
  var LocalConstructedValueBlock = function (_ValueBlock) {
    function LocalConstructedValueBlock() {
      var _this9;
      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _ref7$value = _ref7.value,
        value = _ref7$value === void 0 ? [] : _ref7$value,
        _ref7$isIndefiniteFor = _ref7.isIndefiniteForm,
        isIndefiniteForm = _ref7$isIndefiniteFor === void 0 ? false : _ref7$isIndefiniteFor,
        parameters = _objectWithoutProperties(_ref7, _excluded4);
      _classCallCheck(this, LocalConstructedValueBlock);
      _this9 = _callSuper(this, LocalConstructedValueBlock, [parameters]);
      _this9.value = value;
      _this9.isIndefiniteForm = isIndefiniteForm;
      return _this9;
    }
    _inherits(LocalConstructedValueBlock, _ValueBlock);
    return _createClass(LocalConstructedValueBlock, [{
      key: "fromBER",
      value: function fromBER(inputBuffer, inputOffset, inputLength) {
        var view = BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, view, inputOffset, inputLength)) {
          return -1;
        }
        this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);
        if (this.valueBeforeDecodeView.length === 0) {
          this.warnings.push("Zero buffer length");
          return inputOffset;
        }
        var currentOffset = inputOffset;
        while (checkLen(this.isIndefiniteForm, inputLength) > 0) {
          var returnObject = localFromBER(view, currentOffset, inputLength);
          if (returnObject.offset === -1) {
            this.error = returnObject.result.error;
            this.warnings.concat(returnObject.result.warnings);
            return -1;
          }
          currentOffset = returnObject.offset;
          this.blockLength += returnObject.result.blockLength;
          inputLength -= returnObject.result.blockLength;
          this.value.push(returnObject.result);
          if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME) {
            break;
          }
        }
        if (this.isIndefiniteForm) {
          if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME) {
            this.value.pop();
          } else {
            this.warnings.push("No EndOfContent block encoded");
          }
        }
        return currentOffset;
      }
    }, {
      key: "toBER",
      value: function toBER(sizeOnly, writer) {
        var _writer = writer || new ViewWriter();
        for (var i = 0; i < this.value.length; i++) {
          this.value[i].toBER(sizeOnly, _writer);
        }
        if (!writer) {
          return _writer.final();
        }
        return EMPTY_BUFFER$1;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var object = _objectSpread2(_objectSpread2({}, _superPropGet(LocalConstructedValueBlock, "toJSON", this, 3)([])), {}, {
          isIndefiniteForm: this.isIndefiniteForm,
          value: []
        });
        var _iterator9 = _createForOfIteratorHelper(this.value),
          _step9;
        try {
          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
            var value = _step9.value;
            object.value.push(value.toJSON());
          }
        } catch (err) {
          _iterator9.e(err);
        } finally {
          _iterator9.f();
        }
        return object;
      }
    }]);
  }(ValueBlock);
  LocalConstructedValueBlock.NAME = "ConstructedValueBlock";
  var _a$v;
  var Constructed = function (_BaseBlock3) {
    function Constructed() {
      var _this10;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Constructed);
      _this10 = _callSuper(this, Constructed, [parameters, LocalConstructedValueBlock]);
      _this10.idBlock.isConstructed = true;
      return _this10;
    }
    _inherits(Constructed, _BaseBlock3);
    return _createClass(Constructed, [{
      key: "fromBER",
      value: function fromBER(inputBuffer, inputOffset, inputLength) {
        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
        var resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
          this.error = this.valueBlock.error;
          return resultOffset;
        }
        if (!this.idBlock.error.length) this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length) this.blockLength += this.lenBlock.blockLength;
        if (!this.valueBlock.error.length) this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
      }
    }, {
      key: "onAsciiEncoding",
      value: function onAsciiEncoding() {
        var values = [];
        var _iterator10 = _createForOfIteratorHelper(this.valueBlock.value),
          _step10;
        try {
          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
            var value = _step10.value;
            values.push(value.toString("ascii").split("\n").map(function (o) {
              return "  ".concat(o);
            }).join("\n"));
          }
        } catch (err) {
          _iterator10.e(err);
        } finally {
          _iterator10.f();
        }
        var blockName = this.idBlock.tagClass === 3 ? "[".concat(this.idBlock.tagNumber, "]") : this.constructor.NAME;
        return values.length ? "".concat(blockName, " :\n").concat(values.join("\n")) : "".concat(blockName, " :");
      }
    }]);
  }(BaseBlock);
  _a$v = Constructed;
  (function () {
    typeStore.Constructed = _a$v;
  })();
  Constructed.NAME = "CONSTRUCTED";
  var LocalEndOfContentValueBlock = function (_ValueBlock2) {
    function LocalEndOfContentValueBlock() {
      _classCallCheck(this, LocalEndOfContentValueBlock);
      return _callSuper(this, LocalEndOfContentValueBlock, arguments);
    }
    _inherits(LocalEndOfContentValueBlock, _ValueBlock2);
    return _createClass(LocalEndOfContentValueBlock, [{
      key: "fromBER",
      value: function fromBER(inputBuffer, inputOffset, inputLength) {
        return inputOffset;
      }
    }, {
      key: "toBER",
      value: function toBER(sizeOnly) {
        return EMPTY_BUFFER$1;
      }
    }]);
  }(ValueBlock);
  LocalEndOfContentValueBlock.override = "EndOfContentValueBlock";
  var _a$u;
  var EndOfContent = function (_BaseBlock4) {
    function EndOfContent() {
      var _this11;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, EndOfContent);
      _this11 = _callSuper(this, EndOfContent, [parameters, LocalEndOfContentValueBlock]);
      _this11.idBlock.tagClass = 1;
      _this11.idBlock.tagNumber = 0;
      return _this11;
    }
    _inherits(EndOfContent, _BaseBlock4);
    return _createClass(EndOfContent);
  }(BaseBlock);
  _a$u = EndOfContent;
  (function () {
    typeStore.EndOfContent = _a$u;
  })();
  EndOfContent.NAME = END_OF_CONTENT_NAME;
  var _a$t;
  var Null = function (_BaseBlock5) {
    function Null() {
      var _this12;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Null);
      _this12 = _callSuper(this, Null, [parameters, ValueBlock]);
      _this12.idBlock.tagClass = 1;
      _this12.idBlock.tagNumber = 5;
      return _this12;
    }
    _inherits(Null, _BaseBlock5);
    return _createClass(Null, [{
      key: "fromBER",
      value: function fromBER(inputBuffer, inputOffset, inputLength) {
        if (this.lenBlock.length > 0) this.warnings.push("Non-zero length of value block for Null type");
        if (!this.idBlock.error.length) this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length) this.blockLength += this.lenBlock.blockLength;
        this.blockLength += inputLength;
        if (inputOffset + inputLength > inputBuffer.byteLength) {
          this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
          return -1;
        }
        return inputOffset + inputLength;
      }
    }, {
      key: "toBER",
      value: function toBER(sizeOnly, writer) {
        var retBuf = new ArrayBuffer(2);
        if (!sizeOnly) {
          var retView = new Uint8Array(retBuf);
          retView[0] = 0x05;
          retView[1] = 0x00;
        }
        if (writer) {
          writer.write(retBuf);
        }
        return retBuf;
      }
    }, {
      key: "onAsciiEncoding",
      value: function onAsciiEncoding() {
        return "".concat(this.constructor.NAME);
      }
    }]);
  }(BaseBlock);
  _a$t = Null;
  (function () {
    typeStore.Null = _a$t;
  })();
  Null.NAME = "NULL";
  var LocalBooleanValueBlock = function (_HexBlock3) {
    function LocalBooleanValueBlock() {
      var _this13;
      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var value = _ref8.value,
        parameters = _objectWithoutProperties(_ref8, _excluded5);
      _classCallCheck(this, LocalBooleanValueBlock);
      _this13 = _callSuper(this, LocalBooleanValueBlock, [parameters]);
      if (parameters.valueHex) {
        _this13.valueHexView = BufferSourceConverter.toUint8Array(parameters.valueHex);
      } else {
        _this13.valueHexView = new Uint8Array(1);
      }
      if (value) {
        _this13.value = value;
      }
      return _this13;
    }
    _inherits(LocalBooleanValueBlock, _HexBlock3);
    return _createClass(LocalBooleanValueBlock, [{
      key: "value",
      get: function get() {
        var _iterator11 = _createForOfIteratorHelper(this.valueHexView),
          _step11;
        try {
          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
            var octet = _step11.value;
            if (octet > 0) {
              return true;
            }
          }
        } catch (err) {
          _iterator11.e(err);
        } finally {
          _iterator11.f();
        }
        return false;
      },
      set: function set(value) {
        this.valueHexView[0] = value ? 0xFF : 0x00;
      }
    }, {
      key: "fromBER",
      value: function fromBER(inputBuffer, inputOffset, inputLength) {
        var inputView = BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
          return -1;
        }
        this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);
        if (inputLength > 1) this.warnings.push("Boolean value encoded in more then 1 octet");
        this.isHexOnly = true;
        utilDecodeTC.call(this);
        this.blockLength = inputLength;
        return inputOffset + inputLength;
      }
    }, {
      key: "toBER",
      value: function toBER() {
        return this.valueHexView.slice();
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return _objectSpread2(_objectSpread2({}, _superPropGet(LocalBooleanValueBlock, "toJSON", this, 3)([])), {}, {
          value: this.value
        });
      }
    }]);
  }(HexBlock(ValueBlock));
  LocalBooleanValueBlock.NAME = "BooleanValueBlock";
  var _a$s;
  var Boolean$1 = function (_BaseBlock6) {
    function Boolean() {
      var _this14;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Boolean);
      _this14 = _callSuper(this, Boolean, [parameters, LocalBooleanValueBlock]);
      _this14.idBlock.tagClass = 1;
      _this14.idBlock.tagNumber = 1;
      return _this14;
    }
    _inherits(Boolean, _BaseBlock6);
    return _createClass(Boolean, [{
      key: "getValue",
      value: function getValue() {
        return this.valueBlock.value;
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        this.valueBlock.value = value;
      }
    }, {
      key: "onAsciiEncoding",
      value: function onAsciiEncoding() {
        return "".concat(this.constructor.NAME, " : ").concat(this.getValue);
      }
    }]);
  }(BaseBlock);
  _a$s = Boolean$1;
  (function () {
    typeStore.Boolean = _a$s;
  })();
  Boolean$1.NAME = "BOOLEAN";
  var LocalOctetStringValueBlock = function (_HexBlock4) {
    function LocalOctetStringValueBlock() {
      var _this15;
      var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _ref9$isConstructed = _ref9.isConstructed,
        isConstructed = _ref9$isConstructed === void 0 ? false : _ref9$isConstructed,
        parameters = _objectWithoutProperties(_ref9, _excluded6);
      _classCallCheck(this, LocalOctetStringValueBlock);
      _this15 = _callSuper(this, LocalOctetStringValueBlock, [parameters]);
      _this15.isConstructed = isConstructed;
      return _this15;
    }
    _inherits(LocalOctetStringValueBlock, _HexBlock4);
    return _createClass(LocalOctetStringValueBlock, [{
      key: "fromBER",
      value: function fromBER(inputBuffer, inputOffset, inputLength) {
        var resultOffset = 0;
        if (this.isConstructed) {
          this.isHexOnly = false;
          resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
          if (resultOffset === -1) return resultOffset;
          for (var i = 0; i < this.value.length; i++) {
            var currentBlockName = this.value[i].constructor.NAME;
            if (currentBlockName === END_OF_CONTENT_NAME) {
              if (this.isIndefiniteForm) break;else {
                this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
                return -1;
              }
            }
            if (currentBlockName !== OCTET_STRING_NAME) {
              this.error = "OCTET STRING may consists of OCTET STRINGs only";
              return -1;
            }
          }
        } else {
          this.isHexOnly = true;
          resultOffset = _superPropGet(LocalOctetStringValueBlock, "fromBER", this, 3)([inputBuffer, inputOffset, inputLength]);
          this.blockLength = inputLength;
        }
        return resultOffset;
      }
    }, {
      key: "toBER",
      value: function toBER(sizeOnly, writer) {
        if (this.isConstructed) return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
        return sizeOnly ? new ArrayBuffer(this.valueHexView.byteLength) : this.valueHexView.slice().buffer;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return _objectSpread2(_objectSpread2({}, _superPropGet(LocalOctetStringValueBlock, "toJSON", this, 3)([])), {}, {
          isConstructed: this.isConstructed
        });
      }
    }]);
  }(HexBlock(LocalConstructedValueBlock));
  LocalOctetStringValueBlock.NAME = "OctetStringValueBlock";
  var _a$r;
  var OctetString = function (_BaseBlock7) {
    function OctetString() {
      var _this16;
      var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _ref10$idBlock = _ref10.idBlock,
        idBlock = _ref10$idBlock === void 0 ? {} : _ref10$idBlock,
        _ref10$lenBlock = _ref10.lenBlock,
        lenBlock = _ref10$lenBlock === void 0 ? {} : _ref10$lenBlock,
        parameters = _objectWithoutProperties(_ref10, _excluded7);
      _classCallCheck(this, OctetString);
      var _b, _c;
      (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);
      _this16 = _callSuper(this, OctetString, [_objectSpread2({
        idBlock: _objectSpread2({
          isConstructed: parameters.isConstructed
        }, idBlock),
        lenBlock: _objectSpread2(_objectSpread2({}, lenBlock), {}, {
          isIndefiniteForm: !!parameters.isIndefiniteForm
        })
      }, parameters), LocalOctetStringValueBlock]);
      _this16.idBlock.tagClass = 1;
      _this16.idBlock.tagNumber = 4;
      return _this16;
    }
    _inherits(OctetString, _BaseBlock7);
    return _createClass(OctetString, [{
      key: "fromBER",
      value: function fromBER(inputBuffer, inputOffset, inputLength) {
        this.valueBlock.isConstructed = this.idBlock.isConstructed;
        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
        if (inputLength === 0) {
          if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;
          if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;
          return inputOffset;
        }
        if (!this.valueBlock.isConstructed) {
          var view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
          var buf = view.subarray(inputOffset, inputOffset + inputLength);
          try {
            if (buf.byteLength) {
              var asn = localFromBER(buf, 0, buf.byteLength);
              if (asn.offset !== -1 && asn.offset === inputLength) {
                this.valueBlock.value = [asn.result];
              }
            }
          } catch (e) {}
        }
        return _superPropGet(OctetString, "fromBER", this, 3)([inputBuffer, inputOffset, inputLength]);
      }
    }, {
      key: "onAsciiEncoding",
      value: function onAsciiEncoding() {
        if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
          return Constructed.prototype.onAsciiEncoding.call(this);
        }
        return "".concat(this.constructor.NAME, " : ").concat(Convert.ToHex(this.valueBlock.valueHexView));
      }
    }, {
      key: "getValue",
      value: function getValue() {
        if (!this.idBlock.isConstructed) {
          return this.valueBlock.valueHexView.slice().buffer;
        }
        var array = [];
        var _iterator12 = _createForOfIteratorHelper(this.valueBlock.value),
          _step12;
        try {
          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
            var content = _step12.value;
            if (content instanceof OctetString) {
              array.push(content.valueBlock.valueHexView);
            }
          }
        } catch (err) {
          _iterator12.e(err);
        } finally {
          _iterator12.f();
        }
        return BufferSourceConverter.concat(array);
      }
    }]);
  }(BaseBlock);
  _a$r = OctetString;
  (function () {
    typeStore.OctetString = _a$r;
  })();
  OctetString.NAME = OCTET_STRING_NAME;
  var LocalBitStringValueBlock = function (_HexBlock5) {
    function LocalBitStringValueBlock() {
      var _this17;
      var _ref11 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _ref11$unusedBits = _ref11.unusedBits,
        unusedBits = _ref11$unusedBits === void 0 ? 0 : _ref11$unusedBits,
        _ref11$isConstructed = _ref11.isConstructed,
        isConstructed = _ref11$isConstructed === void 0 ? false : _ref11$isConstructed,
        parameters = _objectWithoutProperties(_ref11, _excluded8);
      _classCallCheck(this, LocalBitStringValueBlock);
      _this17 = _callSuper(this, LocalBitStringValueBlock, [parameters]);
      _this17.unusedBits = unusedBits;
      _this17.isConstructed = isConstructed;
      _this17.blockLength = _this17.valueHexView.byteLength;
      return _this17;
    }
    _inherits(LocalBitStringValueBlock, _HexBlock5);
    return _createClass(LocalBitStringValueBlock, [{
      key: "fromBER",
      value: function fromBER(inputBuffer, inputOffset, inputLength) {
        if (!inputLength) {
          return inputOffset;
        }
        var resultOffset = -1;
        if (this.isConstructed) {
          resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
          if (resultOffset === -1) return resultOffset;
          var _iterator13 = _createForOfIteratorHelper(this.value),
            _step13;
          try {
            for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
              var value = _step13.value;
              var currentBlockName = value.constructor.NAME;
              if (currentBlockName === END_OF_CONTENT_NAME) {
                if (this.isIndefiniteForm) break;else {
                  this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
                  return -1;
                }
              }
              if (currentBlockName !== BIT_STRING_NAME) {
                this.error = "BIT STRING may consists of BIT STRINGs only";
                return -1;
              }
              var valueBlock = value.valueBlock;
              if (this.unusedBits > 0 && valueBlock.unusedBits > 0) {
                this.error = "Using of \"unused bits\" inside constructive BIT STRING allowed for least one only";
                return -1;
              }
              this.unusedBits = valueBlock.unusedBits;
            }
          } catch (err) {
            _iterator13.e(err);
          } finally {
            _iterator13.f();
          }
          return resultOffset;
        }
        var inputView = BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
          return -1;
        }
        var intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        this.unusedBits = intBuffer[0];
        if (this.unusedBits > 7) {
          this.error = "Unused bits for BitString must be in range 0-7";
          return -1;
        }
        if (!this.unusedBits) {
          var buf = intBuffer.subarray(1);
          try {
            if (buf.byteLength) {
              var asn = localFromBER(buf, 0, buf.byteLength);
              if (asn.offset !== -1 && asn.offset === inputLength - 1) {
                this.value = [asn.result];
              }
            }
          } catch (e) {}
        }
        this.valueHexView = intBuffer.subarray(1);
        this.blockLength = intBuffer.length;
        return inputOffset + inputLength;
      }
    }, {
      key: "toBER",
      value: function toBER(sizeOnly, writer) {
        if (this.isConstructed) {
          return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
        }
        if (sizeOnly) {
          return new ArrayBuffer(this.valueHexView.byteLength + 1);
        }
        if (!this.valueHexView.byteLength) {
          return EMPTY_BUFFER$1;
        }
        var retView = new Uint8Array(this.valueHexView.length + 1);
        retView[0] = this.unusedBits;
        retView.set(this.valueHexView, 1);
        return retView.buffer;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return _objectSpread2(_objectSpread2({}, _superPropGet(LocalBitStringValueBlock, "toJSON", this, 3)([])), {}, {
          unusedBits: this.unusedBits,
          isConstructed: this.isConstructed
        });
      }
    }]);
  }(HexBlock(LocalConstructedValueBlock));
  LocalBitStringValueBlock.NAME = "BitStringValueBlock";
  var _a$q;
  var BitString = function (_BaseBlock8) {
    function BitString() {
      var _this18;
      var _ref12 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _ref12$idBlock = _ref12.idBlock,
        idBlock = _ref12$idBlock === void 0 ? {} : _ref12$idBlock,
        _ref12$lenBlock = _ref12.lenBlock,
        lenBlock = _ref12$lenBlock === void 0 ? {} : _ref12$lenBlock,
        parameters = _objectWithoutProperties(_ref12, _excluded9);
      _classCallCheck(this, BitString);
      var _b, _c;
      (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);
      _this18 = _callSuper(this, BitString, [_objectSpread2({
        idBlock: _objectSpread2({
          isConstructed: parameters.isConstructed
        }, idBlock),
        lenBlock: _objectSpread2(_objectSpread2({}, lenBlock), {}, {
          isIndefiniteForm: !!parameters.isIndefiniteForm
        })
      }, parameters), LocalBitStringValueBlock]);
      _this18.idBlock.tagClass = 1;
      _this18.idBlock.tagNumber = 3;
      return _this18;
    }
    _inherits(BitString, _BaseBlock8);
    return _createClass(BitString, [{
      key: "fromBER",
      value: function fromBER(inputBuffer, inputOffset, inputLength) {
        this.valueBlock.isConstructed = this.idBlock.isConstructed;
        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
        return _superPropGet(BitString, "fromBER", this, 3)([inputBuffer, inputOffset, inputLength]);
      }
    }, {
      key: "onAsciiEncoding",
      value: function onAsciiEncoding() {
        if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
          return Constructed.prototype.onAsciiEncoding.call(this);
        } else {
          var bits = [];
          var valueHex = this.valueBlock.valueHexView;
          var _iterator14 = _createForOfIteratorHelper(valueHex),
            _step14;
          try {
            for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
              var byte = _step14.value;
              bits.push(byte.toString(2).padStart(8, "0"));
            }
          } catch (err) {
            _iterator14.e(err);
          } finally {
            _iterator14.f();
          }
          var bitsStr = bits.join("");
          return "".concat(this.constructor.NAME, " : ").concat(bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits));
        }
      }
    }]);
  }(BaseBlock);
  _a$q = BitString;
  (function () {
    typeStore.BitString = _a$q;
  })();
  BitString.NAME = BIT_STRING_NAME;
  var _a$p;
  function viewAdd(first, second) {
    var c = new Uint8Array([0]);
    var firstView = new Uint8Array(first);
    var secondView = new Uint8Array(second);
    var firstViewCopy = firstView.slice(0);
    var firstViewCopyLength = firstViewCopy.length - 1;
    var secondViewCopy = secondView.slice(0);
    var secondViewCopyLength = secondViewCopy.length - 1;
    var value = 0;
    var max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;
    var counter = 0;
    for (var i = max; i >= 0; i--, counter++) {
      switch (true) {
        case counter < secondViewCopy.length:
          value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];
          break;
        default:
          value = firstViewCopy[firstViewCopyLength - counter] + c[0];
      }
      c[0] = value / 10;
      switch (true) {
        case counter >= firstViewCopy.length:
          firstViewCopy = utilConcatView(new Uint8Array([value % 10]), firstViewCopy);
          break;
        default:
          firstViewCopy[firstViewCopyLength - counter] = value % 10;
      }
    }
    if (c[0] > 0) firstViewCopy = utilConcatView(c, firstViewCopy);
    return firstViewCopy;
  }
  function power2(n) {
    if (n >= powers2.length) {
      for (var p = powers2.length; p <= n; p++) {
        var c = new Uint8Array([0]);
        var digits = powers2[p - 1].slice(0);
        for (var i = digits.length - 1; i >= 0; i--) {
          var newValue = new Uint8Array([(digits[i] << 1) + c[0]]);
          c[0] = newValue[0] / 10;
          digits[i] = newValue[0] % 10;
        }
        if (c[0] > 0) digits = utilConcatView(c, digits);
        powers2.push(digits);
      }
    }
    return powers2[n];
  }
  function viewSub(first, second) {
    var b = 0;
    var firstView = new Uint8Array(first);
    var secondView = new Uint8Array(second);
    var firstViewCopy = firstView.slice(0);
    var firstViewCopyLength = firstViewCopy.length - 1;
    var secondViewCopy = secondView.slice(0);
    var secondViewCopyLength = secondViewCopy.length - 1;
    var value;
    var counter = 0;
    for (var i = secondViewCopyLength; i >= 0; i--, counter++) {
      value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;
      switch (true) {
        case value < 0:
          b = 1;
          firstViewCopy[firstViewCopyLength - counter] = value + 10;
          break;
        default:
          b = 0;
          firstViewCopy[firstViewCopyLength - counter] = value;
      }
    }
    if (b > 0) {
      for (var _i12 = firstViewCopyLength - secondViewCopyLength + 1; _i12 >= 0; _i12--, counter++) {
        value = firstViewCopy[firstViewCopyLength - counter] - b;
        if (value < 0) {
          b = 1;
          firstViewCopy[firstViewCopyLength - counter] = value + 10;
        } else {
          b = 0;
          firstViewCopy[firstViewCopyLength - counter] = value;
          break;
        }
      }
    }
    return firstViewCopy.slice();
  }
  var LocalIntegerValueBlock = function (_HexBlock6) {
    function LocalIntegerValueBlock() {
      var _this19;
      var _ref13 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var value = _ref13.value,
        parameters = _objectWithoutProperties(_ref13, _excluded10);
      _classCallCheck(this, LocalIntegerValueBlock);
      _this19 = _callSuper(this, LocalIntegerValueBlock, [parameters]);
      _this19._valueDec = 0;
      if (parameters.valueHex) {
        _this19.setValueHex();
      }
      if (value !== undefined) {
        _this19.valueDec = value;
      }
      return _this19;
    }
    _inherits(LocalIntegerValueBlock, _HexBlock6);
    return _createClass(LocalIntegerValueBlock, [{
      key: "setValueHex",
      value: function setValueHex() {
        if (this.valueHexView.length >= 4) {
          this.warnings.push("Too big Integer for decoding, hex only");
          this.isHexOnly = true;
          this._valueDec = 0;
        } else {
          this.isHexOnly = false;
          if (this.valueHexView.length > 0) {
            this._valueDec = utilDecodeTC.call(this);
          }
        }
      }
    }, {
      key: "valueDec",
      get: function get() {
        return this._valueDec;
      },
      set: function set(v) {
        this._valueDec = v;
        this.isHexOnly = false;
        this.valueHexView = new Uint8Array(utilEncodeTC(v));
      }
    }, {
      key: "fromDER",
      value: function fromDER(inputBuffer, inputOffset, inputLength) {
        var expectedLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var offset = this.fromBER(inputBuffer, inputOffset, inputLength);
        if (offset === -1) return offset;
        var view = this.valueHexView;
        if (view[0] === 0x00 && (view[1] & 0x80) !== 0) {
          this.valueHexView = view.subarray(1);
        } else {
          if (expectedLength !== 0) {
            if (view.length < expectedLength) {
              if (expectedLength - view.length > 1) expectedLength = view.length + 1;
              this.valueHexView = view.subarray(expectedLength - view.length);
            }
          }
        }
        return offset;
      }
    }, {
      key: "toDER",
      value: function toDER() {
        var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var view = this.valueHexView;
        switch (true) {
          case (view[0] & 0x80) !== 0:
            {
              var updatedView = new Uint8Array(this.valueHexView.length + 1);
              updatedView[0] = 0x00;
              updatedView.set(view, 1);
              this.valueHexView = updatedView;
            }
            break;
          case view[0] === 0x00 && (view[1] & 0x80) === 0:
            {
              this.valueHexView = this.valueHexView.subarray(1);
            }
            break;
        }
        return this.toBER(sizeOnly);
      }
    }, {
      key: "fromBER",
      value: function fromBER(inputBuffer, inputOffset, inputLength) {
        var resultOffset = _superPropGet(LocalIntegerValueBlock, "fromBER", this, 3)([inputBuffer, inputOffset, inputLength]);
        if (resultOffset === -1) {
          return resultOffset;
        }
        this.setValueHex();
        return resultOffset;
      }
    }, {
      key: "toBER",
      value: function toBER(sizeOnly) {
        return sizeOnly ? new ArrayBuffer(this.valueHexView.length) : this.valueHexView.slice().buffer;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return _objectSpread2(_objectSpread2({}, _superPropGet(LocalIntegerValueBlock, "toJSON", this, 3)([])), {}, {
          valueDec: this.valueDec
        });
      }
    }, {
      key: "toString",
      value: function toString() {
        var firstBit = this.valueHexView.length * 8 - 1;
        var digits = new Uint8Array(this.valueHexView.length * 8 / 3);
        var bitNumber = 0;
        var currentByte;
        var asn1View = this.valueHexView;
        var result = "";
        var flag = false;
        for (var byteNumber = asn1View.byteLength - 1; byteNumber >= 0; byteNumber--) {
          currentByte = asn1View[byteNumber];
          for (var i = 0; i < 8; i++) {
            if ((currentByte & 1) === 1) {
              switch (bitNumber) {
                case firstBit:
                  digits = viewSub(power2(bitNumber), digits);
                  result = "-";
                  break;
                default:
                  digits = viewAdd(digits, power2(bitNumber));
              }
            }
            bitNumber++;
            currentByte >>= 1;
          }
        }
        for (var _i13 = 0; _i13 < digits.length; _i13++) {
          if (digits[_i13]) flag = true;
          if (flag) result += digitsString.charAt(digits[_i13]);
        }
        if (flag === false) result += digitsString.charAt(0);
        return result;
      }
    }]);
  }(HexBlock(ValueBlock));
  _a$p = LocalIntegerValueBlock;
  LocalIntegerValueBlock.NAME = "IntegerValueBlock";
  (function () {
    Object.defineProperty(_a$p.prototype, "valueHex", {
      set: function set(v) {
        this.valueHexView = new Uint8Array(v);
        this.setValueHex();
      },
      get: function get() {
        return this.valueHexView.slice().buffer;
      }
    });
  })();
  var _a$o;
  var Integer = function (_BaseBlock9) {
    function Integer() {
      var _this20;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Integer);
      _this20 = _callSuper(this, Integer, [parameters, LocalIntegerValueBlock]);
      _this20.idBlock.tagClass = 1;
      _this20.idBlock.tagNumber = 2;
      return _this20;
    }
    _inherits(Integer, _BaseBlock9);
    return _createClass(Integer, [{
      key: "toBigInt",
      value: function toBigInt() {
        assertBigInt();
        return BigInt(this.valueBlock.toString());
      }
    }, {
      key: "convertToDER",
      value: function convertToDER() {
        var integer = new Integer({
          valueHex: this.valueBlock.valueHexView
        });
        integer.valueBlock.toDER();
        return integer;
      }
    }, {
      key: "convertFromDER",
      value: function convertFromDER() {
        return new Integer({
          valueHex: this.valueBlock.valueHexView[0] === 0 ? this.valueBlock.valueHexView.subarray(1) : this.valueBlock.valueHexView
        });
      }
    }, {
      key: "onAsciiEncoding",
      value: function onAsciiEncoding() {
        return "".concat(this.constructor.NAME, " : ").concat(this.valueBlock.toString());
      }
    }], [{
      key: "fromBigInt",
      value: function fromBigInt(value) {
        assertBigInt();
        var bigIntValue = BigInt(value);
        var writer = new ViewWriter();
        var hex = bigIntValue.toString(16).replace(/^-/, "");
        var view = new Uint8Array(Convert.FromHex(hex));
        if (bigIntValue < 0) {
          var first = new Uint8Array(view.length + (view[0] & 0x80 ? 1 : 0));
          first[0] |= 0x80;
          var firstInt = BigInt("0x".concat(Convert.ToHex(first)));
          var secondInt = firstInt + bigIntValue;
          var second = BufferSourceConverter.toUint8Array(Convert.FromHex(secondInt.toString(16)));
          second[0] |= 0x80;
          writer.write(second);
        } else {
          if (view[0] & 0x80) {
            writer.write(new Uint8Array([0]));
          }
          writer.write(view);
        }
        var res = new Integer({
          valueHex: writer.final()
        });
        return res;
      }
    }]);
  }(BaseBlock);
  _a$o = Integer;
  (function () {
    typeStore.Integer = _a$o;
  })();
  Integer.NAME = "INTEGER";
  var _a$n;
  var Enumerated = function (_Integer) {
    function Enumerated() {
      var _this21;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Enumerated);
      _this21 = _callSuper(this, Enumerated, [parameters]);
      _this21.idBlock.tagClass = 1;
      _this21.idBlock.tagNumber = 10;
      return _this21;
    }
    _inherits(Enumerated, _Integer);
    return _createClass(Enumerated);
  }(Integer);
  _a$n = Enumerated;
  (function () {
    typeStore.Enumerated = _a$n;
  })();
  Enumerated.NAME = "ENUMERATED";
  var LocalSidValueBlock = function (_HexBlock7) {
    function LocalSidValueBlock() {
      var _this22;
      var _ref14 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _ref14$valueDec = _ref14.valueDec,
        valueDec = _ref14$valueDec === void 0 ? -1 : _ref14$valueDec,
        _ref14$isFirstSid = _ref14.isFirstSid,
        isFirstSid = _ref14$isFirstSid === void 0 ? false : _ref14$isFirstSid,
        parameters = _objectWithoutProperties(_ref14, _excluded11);
      _classCallCheck(this, LocalSidValueBlock);
      _this22 = _callSuper(this, LocalSidValueBlock, [parameters]);
      _this22.valueDec = valueDec;
      _this22.isFirstSid = isFirstSid;
      return _this22;
    }
    _inherits(LocalSidValueBlock, _HexBlock7);
    return _createClass(LocalSidValueBlock, [{
      key: "fromBER",
      value: function fromBER(inputBuffer, inputOffset, inputLength) {
        if (!inputLength) {
          return inputOffset;
        }
        var inputView = BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
          return -1;
        }
        var intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        this.valueHexView = new Uint8Array(inputLength);
        for (var i = 0; i < inputLength; i++) {
          this.valueHexView[i] = intBuffer[i] & 0x7F;
          this.blockLength++;
          if ((intBuffer[i] & 0x80) === 0x00) break;
        }
        var tempView = new Uint8Array(this.blockLength);
        for (var _i14 = 0; _i14 < this.blockLength; _i14++) {
          tempView[_i14] = this.valueHexView[_i14];
        }
        this.valueHexView = tempView;
        if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {
          this.error = "End of input reached before message was fully decoded";
          return -1;
        }
        if (this.valueHexView[0] === 0x00) this.warnings.push("Needlessly long format of SID encoding");
        if (this.blockLength <= 8) this.valueDec = utilFromBase(this.valueHexView, 7);else {
          this.isHexOnly = true;
          this.warnings.push("Too big SID for decoding, hex only");
        }
        return inputOffset + this.blockLength;
      }
    }, {
      key: "valueBigInt",
      set: function set(value) {
        assertBigInt();
        var bits = BigInt(value).toString(2);
        while (bits.length % 7) {
          bits = "0" + bits;
        }
        var bytes = new Uint8Array(bits.length / 7);
        for (var i = 0; i < bytes.length; i++) {
          bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 0x80 : 0);
        }
        this.fromBER(bytes.buffer, 0, bytes.length);
      }
    }, {
      key: "toBER",
      value: function toBER(sizeOnly) {
        if (this.isHexOnly) {
          if (sizeOnly) return new ArrayBuffer(this.valueHexView.byteLength);
          var curView = this.valueHexView;
          var _retView4 = new Uint8Array(this.blockLength);
          for (var i = 0; i < this.blockLength - 1; i++) _retView4[i] = curView[i] | 0x80;
          _retView4[this.blockLength - 1] = curView[this.blockLength - 1];
          return _retView4.buffer;
        }
        var encodedBuf = utilToBase(this.valueDec, 7);
        if (encodedBuf.byteLength === 0) {
          this.error = "Error during encoding SID value";
          return EMPTY_BUFFER$1;
        }
        var retView = new Uint8Array(encodedBuf.byteLength);
        if (!sizeOnly) {
          var encodedView = new Uint8Array(encodedBuf);
          var len = encodedBuf.byteLength - 1;
          for (var _i15 = 0; _i15 < len; _i15++) retView[_i15] = encodedView[_i15] | 0x80;
          retView[len] = encodedView[len];
        }
        return retView;
      }
    }, {
      key: "toString",
      value: function toString() {
        var result = "";
        if (this.isHexOnly) result = Convert.ToHex(this.valueHexView);else {
          if (this.isFirstSid) {
            var sidValue = this.valueDec;
            if (this.valueDec <= 39) result = "0.";else {
              if (this.valueDec <= 79) {
                result = "1.";
                sidValue -= 40;
              } else {
                result = "2.";
                sidValue -= 80;
              }
            }
            result += sidValue.toString();
          } else result = this.valueDec.toString();
        }
        return result;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return _objectSpread2(_objectSpread2({}, _superPropGet(LocalSidValueBlock, "toJSON", this, 3)([])), {}, {
          valueDec: this.valueDec,
          isFirstSid: this.isFirstSid
        });
      }
    }]);
  }(HexBlock(ValueBlock));
  LocalSidValueBlock.NAME = "sidBlock";
  var LocalObjectIdentifierValueBlock = function (_ValueBlock3) {
    function LocalObjectIdentifierValueBlock() {
      var _this23;
      var _ref15 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _ref15$value = _ref15.value,
        value = _ref15$value === void 0 ? EMPTY_STRING$1 : _ref15$value,
        parameters = _objectWithoutProperties(_ref15, _excluded12);
      _classCallCheck(this, LocalObjectIdentifierValueBlock);
      _this23 = _callSuper(this, LocalObjectIdentifierValueBlock, [parameters]);
      _this23.value = [];
      if (value) {
        _this23.fromString(value);
      }
      return _this23;
    }
    _inherits(LocalObjectIdentifierValueBlock, _ValueBlock3);
    return _createClass(LocalObjectIdentifierValueBlock, [{
      key: "fromBER",
      value: function fromBER(inputBuffer, inputOffset, inputLength) {
        var resultOffset = inputOffset;
        while (inputLength > 0) {
          var sidBlock = new LocalSidValueBlock();
          resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
          if (resultOffset === -1) {
            this.blockLength = 0;
            this.error = sidBlock.error;
            return resultOffset;
          }
          if (this.value.length === 0) sidBlock.isFirstSid = true;
          this.blockLength += sidBlock.blockLength;
          inputLength -= sidBlock.blockLength;
          this.value.push(sidBlock);
        }
        return resultOffset;
      }
    }, {
      key: "toBER",
      value: function toBER(sizeOnly) {
        var retBuffers = [];
        for (var i = 0; i < this.value.length; i++) {
          var valueBuf = this.value[i].toBER(sizeOnly);
          if (valueBuf.byteLength === 0) {
            this.error = this.value[i].error;
            return EMPTY_BUFFER$1;
          }
          retBuffers.push(valueBuf);
        }
        return concat(retBuffers);
      }
    }, {
      key: "fromString",
      value: function fromString(string) {
        this.value = [];
        var pos1 = 0;
        var pos2 = 0;
        var sid = "";
        var flag = false;
        do {
          pos2 = string.indexOf(".", pos1);
          if (pos2 === -1) sid = string.substring(pos1);else sid = string.substring(pos1, pos2);
          pos1 = pos2 + 1;
          if (flag) {
            var sidBlock = this.value[0];
            var plus = 0;
            switch (sidBlock.valueDec) {
              case 0:
                break;
              case 1:
                plus = 40;
                break;
              case 2:
                plus = 80;
                break;
              default:
                this.value = [];
                return;
            }
            var parsedSID = parseInt(sid, 10);
            if (isNaN(parsedSID)) return;
            sidBlock.valueDec = parsedSID + plus;
            flag = false;
          } else {
            var _sidBlock = new LocalSidValueBlock();
            if (sid > Number.MAX_SAFE_INTEGER) {
              assertBigInt();
              var sidValue = BigInt(sid);
              _sidBlock.valueBigInt = sidValue;
            } else {
              _sidBlock.valueDec = parseInt(sid, 10);
              if (isNaN(_sidBlock.valueDec)) return;
            }
            if (!this.value.length) {
              _sidBlock.isFirstSid = true;
              flag = true;
            }
            this.value.push(_sidBlock);
          }
        } while (pos2 !== -1);
      }
    }, {
      key: "toString",
      value: function toString() {
        var result = "";
        var isHexOnly = false;
        for (var i = 0; i < this.value.length; i++) {
          isHexOnly = this.value[i].isHexOnly;
          var sidStr = this.value[i].toString();
          if (i !== 0) result = "".concat(result, ".");
          if (isHexOnly) {
            sidStr = "{".concat(sidStr, "}");
            if (this.value[i].isFirstSid) result = "2.{".concat(sidStr, " - 80}");else result += sidStr;
          } else result += sidStr;
        }
        return result;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var object = _objectSpread2(_objectSpread2({}, _superPropGet(LocalObjectIdentifierValueBlock, "toJSON", this, 3)([])), {}, {
          value: this.toString(),
          sidArray: []
        });
        for (var i = 0; i < this.value.length; i++) {
          object.sidArray.push(this.value[i].toJSON());
        }
        return object;
      }
    }]);
  }(ValueBlock);
  LocalObjectIdentifierValueBlock.NAME = "ObjectIdentifierValueBlock";
  var _a$m;
  var ObjectIdentifier = function (_BaseBlock10) {
    function ObjectIdentifier() {
      var _this24;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, ObjectIdentifier);
      _this24 = _callSuper(this, ObjectIdentifier, [parameters, LocalObjectIdentifierValueBlock]);
      _this24.idBlock.tagClass = 1;
      _this24.idBlock.tagNumber = 6;
      return _this24;
    }
    _inherits(ObjectIdentifier, _BaseBlock10);
    return _createClass(ObjectIdentifier, [{
      key: "getValue",
      value: function getValue() {
        return this.valueBlock.toString();
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        this.valueBlock.fromString(value);
      }
    }, {
      key: "onAsciiEncoding",
      value: function onAsciiEncoding() {
        return "".concat(this.constructor.NAME, " : ").concat(this.valueBlock.toString() || "empty");
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return _objectSpread2(_objectSpread2({}, _superPropGet(ObjectIdentifier, "toJSON", this, 3)([])), {}, {
          value: this.getValue()
        });
      }
    }]);
  }(BaseBlock);
  _a$m = ObjectIdentifier;
  (function () {
    typeStore.ObjectIdentifier = _a$m;
  })();
  ObjectIdentifier.NAME = "OBJECT IDENTIFIER";
  var LocalRelativeSidValueBlock = function (_HexBlock8) {
    function LocalRelativeSidValueBlock() {
      var _this25;
      var _ref16 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _ref16$valueDec = _ref16.valueDec,
        valueDec = _ref16$valueDec === void 0 ? 0 : _ref16$valueDec,
        parameters = _objectWithoutProperties(_ref16, _excluded13);
      _classCallCheck(this, LocalRelativeSidValueBlock);
      _this25 = _callSuper(this, LocalRelativeSidValueBlock, [parameters]);
      _this25.valueDec = valueDec;
      return _this25;
    }
    _inherits(LocalRelativeSidValueBlock, _HexBlock8);
    return _createClass(LocalRelativeSidValueBlock, [{
      key: "fromBER",
      value: function fromBER(inputBuffer, inputOffset, inputLength) {
        if (inputLength === 0) return inputOffset;
        var inputView = BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) return -1;
        var intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        this.valueHexView = new Uint8Array(inputLength);
        for (var i = 0; i < inputLength; i++) {
          this.valueHexView[i] = intBuffer[i] & 0x7F;
          this.blockLength++;
          if ((intBuffer[i] & 0x80) === 0x00) break;
        }
        var tempView = new Uint8Array(this.blockLength);
        for (var _i16 = 0; _i16 < this.blockLength; _i16++) tempView[_i16] = this.valueHexView[_i16];
        this.valueHexView = tempView;
        if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {
          this.error = "End of input reached before message was fully decoded";
          return -1;
        }
        if (this.valueHexView[0] === 0x00) this.warnings.push("Needlessly long format of SID encoding");
        if (this.blockLength <= 8) this.valueDec = utilFromBase(this.valueHexView, 7);else {
          this.isHexOnly = true;
          this.warnings.push("Too big SID for decoding, hex only");
        }
        return inputOffset + this.blockLength;
      }
    }, {
      key: "toBER",
      value: function toBER(sizeOnly) {
        if (this.isHexOnly) {
          if (sizeOnly) return new ArrayBuffer(this.valueHexView.byteLength);
          var curView = this.valueHexView;
          var _retView5 = new Uint8Array(this.blockLength);
          for (var i = 0; i < this.blockLength - 1; i++) _retView5[i] = curView[i] | 0x80;
          _retView5[this.blockLength - 1] = curView[this.blockLength - 1];
          return _retView5.buffer;
        }
        var encodedBuf = utilToBase(this.valueDec, 7);
        if (encodedBuf.byteLength === 0) {
          this.error = "Error during encoding SID value";
          return EMPTY_BUFFER$1;
        }
        var retView = new Uint8Array(encodedBuf.byteLength);
        if (!sizeOnly) {
          var encodedView = new Uint8Array(encodedBuf);
          var len = encodedBuf.byteLength - 1;
          for (var _i17 = 0; _i17 < len; _i17++) retView[_i17] = encodedView[_i17] | 0x80;
          retView[len] = encodedView[len];
        }
        return retView.buffer;
      }
    }, {
      key: "toString",
      value: function toString() {
        var result = "";
        if (this.isHexOnly) result = Convert.ToHex(this.valueHexView);else {
          result = this.valueDec.toString();
        }
        return result;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return _objectSpread2(_objectSpread2({}, _superPropGet(LocalRelativeSidValueBlock, "toJSON", this, 3)([])), {}, {
          valueDec: this.valueDec
        });
      }
    }]);
  }(HexBlock(LocalBaseBlock));
  LocalRelativeSidValueBlock.NAME = "relativeSidBlock";
  var LocalRelativeObjectIdentifierValueBlock = function (_ValueBlock4) {
    function LocalRelativeObjectIdentifierValueBlock() {
      var _this26;
      var _ref17 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _ref17$value = _ref17.value,
        value = _ref17$value === void 0 ? EMPTY_STRING$1 : _ref17$value,
        parameters = _objectWithoutProperties(_ref17, _excluded14);
      _classCallCheck(this, LocalRelativeObjectIdentifierValueBlock);
      _this26 = _callSuper(this, LocalRelativeObjectIdentifierValueBlock, [parameters]);
      _this26.value = [];
      if (value) {
        _this26.fromString(value);
      }
      return _this26;
    }
    _inherits(LocalRelativeObjectIdentifierValueBlock, _ValueBlock4);
    return _createClass(LocalRelativeObjectIdentifierValueBlock, [{
      key: "fromBER",
      value: function fromBER(inputBuffer, inputOffset, inputLength) {
        var resultOffset = inputOffset;
        while (inputLength > 0) {
          var sidBlock = new LocalRelativeSidValueBlock();
          resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
          if (resultOffset === -1) {
            this.blockLength = 0;
            this.error = sidBlock.error;
            return resultOffset;
          }
          this.blockLength += sidBlock.blockLength;
          inputLength -= sidBlock.blockLength;
          this.value.push(sidBlock);
        }
        return resultOffset;
      }
    }, {
      key: "toBER",
      value: function toBER(sizeOnly, writer) {
        var retBuffers = [];
        for (var i = 0; i < this.value.length; i++) {
          var valueBuf = this.value[i].toBER(sizeOnly);
          if (valueBuf.byteLength === 0) {
            this.error = this.value[i].error;
            return EMPTY_BUFFER$1;
          }
          retBuffers.push(valueBuf);
        }
        return concat(retBuffers);
      }
    }, {
      key: "fromString",
      value: function fromString(string) {
        this.value = [];
        var pos1 = 0;
        var pos2 = 0;
        var sid = "";
        do {
          pos2 = string.indexOf(".", pos1);
          if (pos2 === -1) sid = string.substring(pos1);else sid = string.substring(pos1, pos2);
          pos1 = pos2 + 1;
          var sidBlock = new LocalRelativeSidValueBlock();
          sidBlock.valueDec = parseInt(sid, 10);
          if (isNaN(sidBlock.valueDec)) return true;
          this.value.push(sidBlock);
        } while (pos2 !== -1);
        return true;
      }
    }, {
      key: "toString",
      value: function toString() {
        var result = "";
        var isHexOnly = false;
        for (var i = 0; i < this.value.length; i++) {
          isHexOnly = this.value[i].isHexOnly;
          var sidStr = this.value[i].toString();
          if (i !== 0) result = "".concat(result, ".");
          if (isHexOnly) {
            sidStr = "{".concat(sidStr, "}");
            result += sidStr;
          } else result += sidStr;
        }
        return result;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var object = _objectSpread2(_objectSpread2({}, _superPropGet(LocalRelativeObjectIdentifierValueBlock, "toJSON", this, 3)([])), {}, {
          value: this.toString(),
          sidArray: []
        });
        for (var i = 0; i < this.value.length; i++) object.sidArray.push(this.value[i].toJSON());
        return object;
      }
    }]);
  }(ValueBlock);
  LocalRelativeObjectIdentifierValueBlock.NAME = "RelativeObjectIdentifierValueBlock";
  var _a$l;
  var RelativeObjectIdentifier = function (_BaseBlock11) {
    function RelativeObjectIdentifier() {
      var _this27;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, RelativeObjectIdentifier);
      _this27 = _callSuper(this, RelativeObjectIdentifier, [parameters, LocalRelativeObjectIdentifierValueBlock]);
      _this27.idBlock.tagClass = 1;
      _this27.idBlock.tagNumber = 13;
      return _this27;
    }
    _inherits(RelativeObjectIdentifier, _BaseBlock11);
    return _createClass(RelativeObjectIdentifier, [{
      key: "getValue",
      value: function getValue() {
        return this.valueBlock.toString();
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        this.valueBlock.fromString(value);
      }
    }, {
      key: "onAsciiEncoding",
      value: function onAsciiEncoding() {
        return "".concat(this.constructor.NAME, " : ").concat(this.valueBlock.toString() || "empty");
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return _objectSpread2(_objectSpread2({}, _superPropGet(RelativeObjectIdentifier, "toJSON", this, 3)([])), {}, {
          value: this.getValue()
        });
      }
    }]);
  }(BaseBlock);
  _a$l = RelativeObjectIdentifier;
  (function () {
    typeStore.RelativeObjectIdentifier = _a$l;
  })();
  RelativeObjectIdentifier.NAME = "RelativeObjectIdentifier";
  var _a$k;
  var Sequence = function (_Constructed) {
    function Sequence() {
      var _this28;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Sequence);
      _this28 = _callSuper(this, Sequence, [parameters]);
      _this28.idBlock.tagClass = 1;
      _this28.idBlock.tagNumber = 16;
      return _this28;
    }
    _inherits(Sequence, _Constructed);
    return _createClass(Sequence);
  }(Constructed);
  _a$k = Sequence;
  (function () {
    typeStore.Sequence = _a$k;
  })();
  Sequence.NAME = "SEQUENCE";
  var _a$j;
  var Set = function (_Constructed2) {
    function Set() {
      var _this29;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Set);
      _this29 = _callSuper(this, Set, [parameters]);
      _this29.idBlock.tagClass = 1;
      _this29.idBlock.tagNumber = 17;
      return _this29;
    }
    _inherits(Set, _Constructed2);
    return _createClass(Set);
  }(Constructed);
  _a$j = Set;
  (function () {
    typeStore.Set = _a$j;
  })();
  Set.NAME = "SET";
  var LocalStringValueBlock = function (_HexBlock9) {
    function LocalStringValueBlock() {
      var _this30;
      var _ref18 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var parameters = Object.assign({}, (_objectDestructuringEmpty(_ref18), _ref18));
      _classCallCheck(this, LocalStringValueBlock);
      _this30 = _callSuper(this, LocalStringValueBlock, [parameters]);
      _this30.isHexOnly = true;
      _this30.value = EMPTY_STRING$1;
      return _this30;
    }
    _inherits(LocalStringValueBlock, _HexBlock9);
    return _createClass(LocalStringValueBlock, [{
      key: "toJSON",
      value: function toJSON() {
        return _objectSpread2(_objectSpread2({}, _superPropGet(LocalStringValueBlock, "toJSON", this, 3)([])), {}, {
          value: this.value
        });
      }
    }]);
  }(HexBlock(ValueBlock));
  LocalStringValueBlock.NAME = "StringValueBlock";
  var LocalSimpleStringValueBlock = function (_LocalStringValueBloc) {
    function LocalSimpleStringValueBlock() {
      _classCallCheck(this, LocalSimpleStringValueBlock);
      return _callSuper(this, LocalSimpleStringValueBlock, arguments);
    }
    _inherits(LocalSimpleStringValueBlock, _LocalStringValueBloc);
    return _createClass(LocalSimpleStringValueBlock);
  }(LocalStringValueBlock);
  LocalSimpleStringValueBlock.NAME = "SimpleStringValueBlock";
  var LocalSimpleStringBlock = function (_BaseStringBlock) {
    function LocalSimpleStringBlock() {
      var _ref19 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var parameters = Object.assign({}, (_objectDestructuringEmpty(_ref19), _ref19));
      _classCallCheck(this, LocalSimpleStringBlock);
      return _callSuper(this, LocalSimpleStringBlock, [parameters, LocalSimpleStringValueBlock]);
    }
    _inherits(LocalSimpleStringBlock, _BaseStringBlock);
    return _createClass(LocalSimpleStringBlock, [{
      key: "fromBuffer",
      value: function fromBuffer(inputBuffer) {
        this.valueBlock.value = String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer));
      }
    }, {
      key: "fromString",
      value: function fromString(inputString) {
        var strLen = inputString.length;
        var view = this.valueBlock.valueHexView = new Uint8Array(strLen);
        for (var i = 0; i < strLen; i++) view[i] = inputString.charCodeAt(i);
        this.valueBlock.value = inputString;
      }
    }]);
  }(BaseStringBlock);
  LocalSimpleStringBlock.NAME = "SIMPLE STRING";
  var LocalUtf8StringValueBlock = function (_LocalSimpleStringBlo) {
    function LocalUtf8StringValueBlock() {
      _classCallCheck(this, LocalUtf8StringValueBlock);
      return _callSuper(this, LocalUtf8StringValueBlock, arguments);
    }
    _inherits(LocalUtf8StringValueBlock, _LocalSimpleStringBlo);
    return _createClass(LocalUtf8StringValueBlock, [{
      key: "fromBuffer",
      value: function fromBuffer(inputBuffer) {
        this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
        try {
          this.valueBlock.value = Convert.ToUtf8String(inputBuffer);
        } catch (ex) {
          this.warnings.push("Error during \"decodeURIComponent\": ".concat(ex, ", using raw string"));
          this.valueBlock.value = Convert.ToBinary(inputBuffer);
        }
      }
    }, {
      key: "fromString",
      value: function fromString(inputString) {
        this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf8String(inputString));
        this.valueBlock.value = inputString;
      }
    }]);
  }(LocalSimpleStringBlock);
  LocalUtf8StringValueBlock.NAME = "Utf8StringValueBlock";
  var _a$i;
  var Utf8String = function (_LocalUtf8StringValue) {
    function Utf8String() {
      var _this31;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Utf8String);
      _this31 = _callSuper(this, Utf8String, [parameters]);
      _this31.idBlock.tagClass = 1;
      _this31.idBlock.tagNumber = 12;
      return _this31;
    }
    _inherits(Utf8String, _LocalUtf8StringValue);
    return _createClass(Utf8String);
  }(LocalUtf8StringValueBlock);
  _a$i = Utf8String;
  (function () {
    typeStore.Utf8String = _a$i;
  })();
  Utf8String.NAME = "UTF8String";
  var LocalBmpStringValueBlock = function (_LocalSimpleStringBlo2) {
    function LocalBmpStringValueBlock() {
      _classCallCheck(this, LocalBmpStringValueBlock);
      return _callSuper(this, LocalBmpStringValueBlock, arguments);
    }
    _inherits(LocalBmpStringValueBlock, _LocalSimpleStringBlo2);
    return _createClass(LocalBmpStringValueBlock, [{
      key: "fromBuffer",
      value: function fromBuffer(inputBuffer) {
        this.valueBlock.value = Convert.ToUtf16String(inputBuffer);
        this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
      }
    }, {
      key: "fromString",
      value: function fromString(inputString) {
        this.valueBlock.value = inputString;
        this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf16String(inputString));
      }
    }]);
  }(LocalSimpleStringBlock);
  LocalBmpStringValueBlock.NAME = "BmpStringValueBlock";
  var _a$h;
  var BmpString = function (_LocalBmpStringValueB) {
    function BmpString() {
      var _this32;
      var _ref20 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var parameters = Object.assign({}, (_objectDestructuringEmpty(_ref20), _ref20));
      _classCallCheck(this, BmpString);
      _this32 = _callSuper(this, BmpString, [parameters]);
      _this32.idBlock.tagClass = 1;
      _this32.idBlock.tagNumber = 30;
      return _this32;
    }
    _inherits(BmpString, _LocalBmpStringValueB);
    return _createClass(BmpString);
  }(LocalBmpStringValueBlock);
  _a$h = BmpString;
  (function () {
    typeStore.BmpString = _a$h;
  })();
  BmpString.NAME = "BMPString";
  var LocalUniversalStringValueBlock = function (_LocalSimpleStringBlo3) {
    function LocalUniversalStringValueBlock() {
      _classCallCheck(this, LocalUniversalStringValueBlock);
      return _callSuper(this, LocalUniversalStringValueBlock, arguments);
    }
    _inherits(LocalUniversalStringValueBlock, _LocalSimpleStringBlo3);
    return _createClass(LocalUniversalStringValueBlock, [{
      key: "fromBuffer",
      value: function fromBuffer(inputBuffer) {
        var copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);
        var valueView = new Uint8Array(copyBuffer);
        for (var i = 0; i < valueView.length; i += 4) {
          valueView[i] = valueView[i + 3];
          valueView[i + 1] = valueView[i + 2];
          valueView[i + 2] = 0x00;
          valueView[i + 3] = 0x00;
        }
        this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
      }
    }, {
      key: "fromString",
      value: function fromString(inputString) {
        var strLength = inputString.length;
        var valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);
        for (var i = 0; i < strLength; i++) {
          var codeBuf = utilToBase(inputString.charCodeAt(i), 8);
          var codeView = new Uint8Array(codeBuf);
          if (codeView.length > 4) continue;
          var dif = 4 - codeView.length;
          for (var j = codeView.length - 1; j >= 0; j--) valueHexView[i * 4 + j + dif] = codeView[j];
        }
        this.valueBlock.value = inputString;
      }
    }]);
  }(LocalSimpleStringBlock);
  LocalUniversalStringValueBlock.NAME = "UniversalStringValueBlock";
  var _a$g;
  var UniversalString = function (_LocalUniversalString) {
    function UniversalString() {
      var _this33;
      var _ref21 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var parameters = Object.assign({}, (_objectDestructuringEmpty(_ref21), _ref21));
      _classCallCheck(this, UniversalString);
      _this33 = _callSuper(this, UniversalString, [parameters]);
      _this33.idBlock.tagClass = 1;
      _this33.idBlock.tagNumber = 28;
      return _this33;
    }
    _inherits(UniversalString, _LocalUniversalString);
    return _createClass(UniversalString);
  }(LocalUniversalStringValueBlock);
  _a$g = UniversalString;
  (function () {
    typeStore.UniversalString = _a$g;
  })();
  UniversalString.NAME = "UniversalString";
  var _a$f;
  var NumericString = function (_LocalSimpleStringBlo4) {
    function NumericString() {
      var _this34;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, NumericString);
      _this34 = _callSuper(this, NumericString, [parameters]);
      _this34.idBlock.tagClass = 1;
      _this34.idBlock.tagNumber = 18;
      return _this34;
    }
    _inherits(NumericString, _LocalSimpleStringBlo4);
    return _createClass(NumericString);
  }(LocalSimpleStringBlock);
  _a$f = NumericString;
  (function () {
    typeStore.NumericString = _a$f;
  })();
  NumericString.NAME = "NumericString";
  var _a$e;
  var PrintableString = function (_LocalSimpleStringBlo5) {
    function PrintableString() {
      var _this35;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, PrintableString);
      _this35 = _callSuper(this, PrintableString, [parameters]);
      _this35.idBlock.tagClass = 1;
      _this35.idBlock.tagNumber = 19;
      return _this35;
    }
    _inherits(PrintableString, _LocalSimpleStringBlo5);
    return _createClass(PrintableString);
  }(LocalSimpleStringBlock);
  _a$e = PrintableString;
  (function () {
    typeStore.PrintableString = _a$e;
  })();
  PrintableString.NAME = "PrintableString";
  var _a$d;
  var TeletexString = function (_LocalSimpleStringBlo6) {
    function TeletexString() {
      var _this36;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, TeletexString);
      _this36 = _callSuper(this, TeletexString, [parameters]);
      _this36.idBlock.tagClass = 1;
      _this36.idBlock.tagNumber = 20;
      return _this36;
    }
    _inherits(TeletexString, _LocalSimpleStringBlo6);
    return _createClass(TeletexString);
  }(LocalSimpleStringBlock);
  _a$d = TeletexString;
  (function () {
    typeStore.TeletexString = _a$d;
  })();
  TeletexString.NAME = "TeletexString";
  var _a$c;
  var VideotexString = function (_LocalSimpleStringBlo7) {
    function VideotexString() {
      var _this37;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, VideotexString);
      _this37 = _callSuper(this, VideotexString, [parameters]);
      _this37.idBlock.tagClass = 1;
      _this37.idBlock.tagNumber = 21;
      return _this37;
    }
    _inherits(VideotexString, _LocalSimpleStringBlo7);
    return _createClass(VideotexString);
  }(LocalSimpleStringBlock);
  _a$c = VideotexString;
  (function () {
    typeStore.VideotexString = _a$c;
  })();
  VideotexString.NAME = "VideotexString";
  var _a$b;
  var IA5String = function (_LocalSimpleStringBlo8) {
    function IA5String() {
      var _this38;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, IA5String);
      _this38 = _callSuper(this, IA5String, [parameters]);
      _this38.idBlock.tagClass = 1;
      _this38.idBlock.tagNumber = 22;
      return _this38;
    }
    _inherits(IA5String, _LocalSimpleStringBlo8);
    return _createClass(IA5String);
  }(LocalSimpleStringBlock);
  _a$b = IA5String;
  (function () {
    typeStore.IA5String = _a$b;
  })();
  IA5String.NAME = "IA5String";
  var _a$a;
  var GraphicString = function (_LocalSimpleStringBlo9) {
    function GraphicString() {
      var _this39;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, GraphicString);
      _this39 = _callSuper(this, GraphicString, [parameters]);
      _this39.idBlock.tagClass = 1;
      _this39.idBlock.tagNumber = 25;
      return _this39;
    }
    _inherits(GraphicString, _LocalSimpleStringBlo9);
    return _createClass(GraphicString);
  }(LocalSimpleStringBlock);
  _a$a = GraphicString;
  (function () {
    typeStore.GraphicString = _a$a;
  })();
  GraphicString.NAME = "GraphicString";
  var _a$9;
  var VisibleString = function (_LocalSimpleStringBlo10) {
    function VisibleString() {
      var _this40;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, VisibleString);
      _this40 = _callSuper(this, VisibleString, [parameters]);
      _this40.idBlock.tagClass = 1;
      _this40.idBlock.tagNumber = 26;
      return _this40;
    }
    _inherits(VisibleString, _LocalSimpleStringBlo10);
    return _createClass(VisibleString);
  }(LocalSimpleStringBlock);
  _a$9 = VisibleString;
  (function () {
    typeStore.VisibleString = _a$9;
  })();
  VisibleString.NAME = "VisibleString";
  var _a$8;
  var GeneralString = function (_LocalSimpleStringBlo11) {
    function GeneralString() {
      var _this41;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, GeneralString);
      _this41 = _callSuper(this, GeneralString, [parameters]);
      _this41.idBlock.tagClass = 1;
      _this41.idBlock.tagNumber = 27;
      return _this41;
    }
    _inherits(GeneralString, _LocalSimpleStringBlo11);
    return _createClass(GeneralString);
  }(LocalSimpleStringBlock);
  _a$8 = GeneralString;
  (function () {
    typeStore.GeneralString = _a$8;
  })();
  GeneralString.NAME = "GeneralString";
  var _a$7;
  var CharacterString = function (_LocalSimpleStringBlo12) {
    function CharacterString() {
      var _this42;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, CharacterString);
      _this42 = _callSuper(this, CharacterString, [parameters]);
      _this42.idBlock.tagClass = 1;
      _this42.idBlock.tagNumber = 29;
      return _this42;
    }
    _inherits(CharacterString, _LocalSimpleStringBlo12);
    return _createClass(CharacterString);
  }(LocalSimpleStringBlock);
  _a$7 = CharacterString;
  (function () {
    typeStore.CharacterString = _a$7;
  })();
  CharacterString.NAME = "CharacterString";
  var _a$6;
  var UTCTime = function (_VisibleString) {
    function UTCTime() {
      var _this43;
      var _ref22 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var value = _ref22.value,
        valueDate = _ref22.valueDate,
        parameters = _objectWithoutProperties(_ref22, _excluded15);
      _classCallCheck(this, UTCTime);
      _this43 = _callSuper(this, UTCTime, [parameters]);
      _this43.year = 0;
      _this43.month = 0;
      _this43.day = 0;
      _this43.hour = 0;
      _this43.minute = 0;
      _this43.second = 0;
      if (value) {
        _this43.fromString(value);
        _this43.valueBlock.valueHexView = new Uint8Array(value.length);
        for (var i = 0; i < value.length; i++) _this43.valueBlock.valueHexView[i] = value.charCodeAt(i);
      }
      if (valueDate) {
        _this43.fromDate(valueDate);
        _this43.valueBlock.valueHexView = new Uint8Array(_this43.toBuffer());
      }
      _this43.idBlock.tagClass = 1;
      _this43.idBlock.tagNumber = 23;
      return _this43;
    }
    _inherits(UTCTime, _VisibleString);
    return _createClass(UTCTime, [{
      key: "fromBuffer",
      value: function fromBuffer(inputBuffer) {
        this.fromString(String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer)));
      }
    }, {
      key: "toBuffer",
      value: function toBuffer() {
        var str = this.toString();
        var buffer = new ArrayBuffer(str.length);
        var view = new Uint8Array(buffer);
        for (var i = 0; i < str.length; i++) view[i] = str.charCodeAt(i);
        return buffer;
      }
    }, {
      key: "fromDate",
      value: function fromDate(inputDate) {
        this.year = inputDate.getUTCFullYear();
        this.month = inputDate.getUTCMonth() + 1;
        this.day = inputDate.getUTCDate();
        this.hour = inputDate.getUTCHours();
        this.minute = inputDate.getUTCMinutes();
        this.second = inputDate.getUTCSeconds();
      }
    }, {
      key: "toDate",
      value: function toDate() {
        return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));
      }
    }, {
      key: "fromString",
      value: function fromString(inputString) {
        var parser = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
        var parserArray = parser.exec(inputString);
        if (parserArray === null) {
          this.error = "Wrong input string for conversion";
          return;
        }
        var year = parseInt(parserArray[1], 10);
        if (year >= 50) this.year = 1900 + year;else this.year = 2000 + year;
        this.month = parseInt(parserArray[2], 10);
        this.day = parseInt(parserArray[3], 10);
        this.hour = parseInt(parserArray[4], 10);
        this.minute = parseInt(parserArray[5], 10);
        this.second = parseInt(parserArray[6], 10);
      }
    }, {
      key: "toString",
      value: function toString() {
        var encoding = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "iso";
        if (encoding === "iso") {
          var outputArray = new Array(7);
          outputArray[0] = padNumber(this.year < 2000 ? this.year - 1900 : this.year - 2000, 2);
          outputArray[1] = padNumber(this.month, 2);
          outputArray[2] = padNumber(this.day, 2);
          outputArray[3] = padNumber(this.hour, 2);
          outputArray[4] = padNumber(this.minute, 2);
          outputArray[5] = padNumber(this.second, 2);
          outputArray[6] = "Z";
          return outputArray.join("");
        }
        return _superPropGet(UTCTime, "toString", this, 3)([encoding]);
      }
    }, {
      key: "onAsciiEncoding",
      value: function onAsciiEncoding() {
        return "".concat(this.constructor.NAME, " : ").concat(this.toDate().toISOString());
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return _objectSpread2(_objectSpread2({}, _superPropGet(UTCTime, "toJSON", this, 3)([])), {}, {
          year: this.year,
          month: this.month,
          day: this.day,
          hour: this.hour,
          minute: this.minute,
          second: this.second
        });
      }
    }]);
  }(VisibleString);
  _a$6 = UTCTime;
  (function () {
    typeStore.UTCTime = _a$6;
  })();
  UTCTime.NAME = "UTCTime";
  var _a$5;
  var GeneralizedTime = function (_UTCTime) {
    function GeneralizedTime() {
      var _this44;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, GeneralizedTime);
      var _b;
      _this44 = _callSuper(this, GeneralizedTime, [parameters]);
      (_b = _this44.millisecond) !== null && _b !== void 0 ? _b : _this44.millisecond = 0;
      _this44.idBlock.tagClass = 1;
      _this44.idBlock.tagNumber = 24;
      return _this44;
    }
    _inherits(GeneralizedTime, _UTCTime);
    return _createClass(GeneralizedTime, [{
      key: "fromDate",
      value: function fromDate(inputDate) {
        _superPropGet(GeneralizedTime, "fromDate", this, 3)([inputDate]);
        this.millisecond = inputDate.getUTCMilliseconds();
      }
    }, {
      key: "toDate",
      value: function toDate() {
        return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond));
      }
    }, {
      key: "fromString",
      value: function fromString(inputString) {
        var isUTC = false;
        var timeString = "";
        var dateTimeString = "";
        var fractionPart = 0;
        var parser;
        var hourDifference = 0;
        var minuteDifference = 0;
        if (inputString[inputString.length - 1] === "Z") {
          timeString = inputString.substring(0, inputString.length - 1);
          isUTC = true;
        } else {
          var number = new Number(inputString[inputString.length - 1]);
          if (isNaN(number.valueOf())) throw new Error("Wrong input string for conversion");
          timeString = inputString;
        }
        if (isUTC) {
          if (timeString.indexOf("+") !== -1) throw new Error("Wrong input string for conversion");
          if (timeString.indexOf("-") !== -1) throw new Error("Wrong input string for conversion");
        } else {
          var multiplier = 1;
          var differencePosition = timeString.indexOf("+");
          var differenceString = "";
          if (differencePosition === -1) {
            differencePosition = timeString.indexOf("-");
            multiplier = -1;
          }
          if (differencePosition !== -1) {
            differenceString = timeString.substring(differencePosition + 1);
            timeString = timeString.substring(0, differencePosition);
            if (differenceString.length !== 2 && differenceString.length !== 4) throw new Error("Wrong input string for conversion");
            var _number = parseInt(differenceString.substring(0, 2), 10);
            if (isNaN(_number.valueOf())) throw new Error("Wrong input string for conversion");
            hourDifference = multiplier * _number;
            if (differenceString.length === 4) {
              _number = parseInt(differenceString.substring(2, 4), 10);
              if (isNaN(_number.valueOf())) throw new Error("Wrong input string for conversion");
              minuteDifference = multiplier * _number;
            }
          }
        }
        var fractionPointPosition = timeString.indexOf(".");
        if (fractionPointPosition === -1) fractionPointPosition = timeString.indexOf(",");
        if (fractionPointPosition !== -1) {
          var fractionPartCheck = new Number("0".concat(timeString.substring(fractionPointPosition)));
          if (isNaN(fractionPartCheck.valueOf())) throw new Error("Wrong input string for conversion");
          fractionPart = fractionPartCheck.valueOf();
          dateTimeString = timeString.substring(0, fractionPointPosition);
        } else dateTimeString = timeString;
        switch (true) {
          case dateTimeString.length === 8:
            parser = /(\d{4})(\d{2})(\d{2})/ig;
            if (fractionPointPosition !== -1) throw new Error("Wrong input string for conversion");
            break;
          case dateTimeString.length === 10:
            parser = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;
            if (fractionPointPosition !== -1) {
              var fractionResult = 60 * fractionPart;
              this.minute = Math.floor(fractionResult);
              fractionResult = 60 * (fractionResult - this.minute);
              this.second = Math.floor(fractionResult);
              fractionResult = 1000 * (fractionResult - this.second);
              this.millisecond = Math.floor(fractionResult);
            }
            break;
          case dateTimeString.length === 12:
            parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
            if (fractionPointPosition !== -1) {
              var _fractionResult = 60 * fractionPart;
              this.second = Math.floor(_fractionResult);
              _fractionResult = 1000 * (_fractionResult - this.second);
              this.millisecond = Math.floor(_fractionResult);
            }
            break;
          case dateTimeString.length === 14:
            parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
            if (fractionPointPosition !== -1) {
              var _fractionResult2 = 1000 * fractionPart;
              this.millisecond = Math.floor(_fractionResult2);
            }
            break;
          default:
            throw new Error("Wrong input string for conversion");
        }
        var parserArray = parser.exec(dateTimeString);
        if (parserArray === null) throw new Error("Wrong input string for conversion");
        for (var j = 1; j < parserArray.length; j++) {
          switch (j) {
            case 1:
              this.year = parseInt(parserArray[j], 10);
              break;
            case 2:
              this.month = parseInt(parserArray[j], 10);
              break;
            case 3:
              this.day = parseInt(parserArray[j], 10);
              break;
            case 4:
              this.hour = parseInt(parserArray[j], 10) + hourDifference;
              break;
            case 5:
              this.minute = parseInt(parserArray[j], 10) + minuteDifference;
              break;
            case 6:
              this.second = parseInt(parserArray[j], 10);
              break;
            default:
              throw new Error("Wrong input string for conversion");
          }
        }
        if (isUTC === false) {
          var tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
          this.year = tempDate.getUTCFullYear();
          this.month = tempDate.getUTCMonth();
          this.day = tempDate.getUTCDay();
          this.hour = tempDate.getUTCHours();
          this.minute = tempDate.getUTCMinutes();
          this.second = tempDate.getUTCSeconds();
          this.millisecond = tempDate.getUTCMilliseconds();
        }
      }
    }, {
      key: "toString",
      value: function toString() {
        var encoding = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "iso";
        if (encoding === "iso") {
          var outputArray = [];
          outputArray.push(padNumber(this.year, 4));
          outputArray.push(padNumber(this.month, 2));
          outputArray.push(padNumber(this.day, 2));
          outputArray.push(padNumber(this.hour, 2));
          outputArray.push(padNumber(this.minute, 2));
          outputArray.push(padNumber(this.second, 2));
          if (this.millisecond !== 0) {
            outputArray.push(".");
            outputArray.push(padNumber(this.millisecond, 3));
          }
          outputArray.push("Z");
          return outputArray.join("");
        }
        return _superPropGet(GeneralizedTime, "toString", this, 3)([encoding]);
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return _objectSpread2(_objectSpread2({}, _superPropGet(GeneralizedTime, "toJSON", this, 3)([])), {}, {
          millisecond: this.millisecond
        });
      }
    }]);
  }(UTCTime);
  _a$5 = GeneralizedTime;
  (function () {
    typeStore.GeneralizedTime = _a$5;
  })();
  GeneralizedTime.NAME = "GeneralizedTime";
  var _a$4;
  var DATE$2 = function (_Utf8String) {
    function DATE() {
      var _this45;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, DATE);
      _this45 = _callSuper(this, DATE, [parameters]);
      _this45.idBlock.tagClass = 1;
      _this45.idBlock.tagNumber = 31;
      return _this45;
    }
    _inherits(DATE, _Utf8String);
    return _createClass(DATE);
  }(Utf8String);
  _a$4 = DATE$2;
  (function () {
    typeStore.DATE = _a$4;
  })();
  DATE$2.NAME = "DATE";
  var _a$3;
  var TimeOfDay = function (_Utf8String2) {
    function TimeOfDay() {
      var _this46;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, TimeOfDay);
      _this46 = _callSuper(this, TimeOfDay, [parameters]);
      _this46.idBlock.tagClass = 1;
      _this46.idBlock.tagNumber = 32;
      return _this46;
    }
    _inherits(TimeOfDay, _Utf8String2);
    return _createClass(TimeOfDay);
  }(Utf8String);
  _a$3 = TimeOfDay;
  (function () {
    typeStore.TimeOfDay = _a$3;
  })();
  TimeOfDay.NAME = "TimeOfDay";
  var _a$2;
  var DateTime = function (_Utf8String3) {
    function DateTime() {
      var _this47;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, DateTime);
      _this47 = _callSuper(this, DateTime, [parameters]);
      _this47.idBlock.tagClass = 1;
      _this47.idBlock.tagNumber = 33;
      return _this47;
    }
    _inherits(DateTime, _Utf8String3);
    return _createClass(DateTime);
  }(Utf8String);
  _a$2 = DateTime;
  (function () {
    typeStore.DateTime = _a$2;
  })();
  DateTime.NAME = "DateTime";
  var _a$1;
  var Duration = function (_Utf8String4) {
    function Duration() {
      var _this48;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Duration);
      _this48 = _callSuper(this, Duration, [parameters]);
      _this48.idBlock.tagClass = 1;
      _this48.idBlock.tagNumber = 34;
      return _this48;
    }
    _inherits(Duration, _Utf8String4);
    return _createClass(Duration);
  }(Utf8String);
  _a$1 = Duration;
  (function () {
    typeStore.Duration = _a$1;
  })();
  Duration.NAME = "Duration";
  var _a$x;
  var TIME = function (_Utf8String5) {
    function TIME() {
      var _this49;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, TIME);
      _this49 = _callSuper(this, TIME, [parameters]);
      _this49.idBlock.tagClass = 1;
      _this49.idBlock.tagNumber = 14;
      return _this49;
    }
    _inherits(TIME, _Utf8String5);
    return _createClass(TIME);
  }(Utf8String);
  _a$x = TIME;
  (function () {
    typeStore.TIME = _a$x;
  })();
  TIME.NAME = "TIME";
  var Any = _createClass(function Any() {
    var _ref23 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref23$name = _ref23.name,
      name = _ref23$name === void 0 ? EMPTY_STRING$1 : _ref23$name,
      _ref23$optional = _ref23.optional,
      optional = _ref23$optional === void 0 ? false : _ref23$optional;
    _classCallCheck(this, Any);
    this.name = name;
    this.optional = optional;
  });
  var Choice = function (_Any) {
    function Choice() {
      var _this50;
      var _ref24 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _ref24$value = _ref24.value,
        value = _ref24$value === void 0 ? [] : _ref24$value,
        parameters = _objectWithoutProperties(_ref24, _excluded16);
      _classCallCheck(this, Choice);
      _this50 = _callSuper(this, Choice, [parameters]);
      _this50.value = value;
      return _this50;
    }
    _inherits(Choice, _Any);
    return _createClass(Choice);
  }(Any);
  var Repeated = function (_Any2) {
    function Repeated() {
      var _this51;
      var _ref25 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _ref25$value = _ref25.value,
        value = _ref25$value === void 0 ? new Any() : _ref25$value,
        _ref25$local = _ref25.local,
        local = _ref25$local === void 0 ? false : _ref25$local,
        parameters = _objectWithoutProperties(_ref25, _excluded17);
      _classCallCheck(this, Repeated);
      _this51 = _callSuper(this, Repeated, [parameters]);
      _this51.value = value;
      _this51.local = local;
      return _this51;
    }
    _inherits(Repeated, _Any2);
    return _createClass(Repeated);
  }(Any);
  var RawData = function () {
    function RawData() {
      var _ref26 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref26$data = _ref26.data,
        data = _ref26$data === void 0 ? EMPTY_VIEW : _ref26$data;
      _classCallCheck(this, RawData);
      this.dataView = BufferSourceConverter.toUint8Array(data);
    }
    return _createClass(RawData, [{
      key: "data",
      get: function get() {
        return this.dataView.slice().buffer;
      },
      set: function set(value) {
        this.dataView = BufferSourceConverter.toUint8Array(value);
      }
    }, {
      key: "fromBER",
      value: function fromBER(inputBuffer, inputOffset, inputLength) {
        var endLength = inputOffset + inputLength;
        this.dataView = BufferSourceConverter.toUint8Array(inputBuffer).subarray(inputOffset, endLength);
        return endLength;
      }
    }, {
      key: "toBER",
      value: function toBER(sizeOnly) {
        return this.dataView.slice().buffer;
      }
    }]);
  }();
  function compareSchema(root, inputData, inputSchema) {
    if (inputSchema instanceof Choice) {
      for (var j = 0; j < inputSchema.value.length; j++) {
        var result = compareSchema(root, inputData, inputSchema.value[j]);
        if (result.verified) {
          return {
            verified: true,
            result: root
          };
        }
      }
      {
        var _result = {
          verified: false,
          result: {
            error: "Wrong values for Choice type"
          }
        };
        if (inputSchema.hasOwnProperty(NAME)) _result.name = inputSchema.name;
        return _result;
      }
    }
    if (inputSchema instanceof Any) {
      if (inputSchema.hasOwnProperty(NAME)) root[inputSchema.name] = inputData;
      return {
        verified: true,
        result: root
      };
    }
    if (root instanceof Object === false) {
      return {
        verified: false,
        result: {
          error: "Wrong root object"
        }
      };
    }
    if (inputData instanceof Object === false) {
      return {
        verified: false,
        result: {
          error: "Wrong ASN.1 data"
        }
      };
    }
    if (inputSchema instanceof Object === false) {
      return {
        verified: false,
        result: {
          error: "Wrong ASN.1 schema"
        }
      };
    }
    if (ID_BLOCK in inputSchema === false) {
      return {
        verified: false,
        result: {
          error: "Wrong ASN.1 schema"
        }
      };
    }
    if (FROM_BER in inputSchema.idBlock === false) {
      return {
        verified: false,
        result: {
          error: "Wrong ASN.1 schema"
        }
      };
    }
    if (TO_BER in inputSchema.idBlock === false) {
      return {
        verified: false,
        result: {
          error: "Wrong ASN.1 schema"
        }
      };
    }
    var encodedId = inputSchema.idBlock.toBER(false);
    if (encodedId.byteLength === 0) {
      return {
        verified: false,
        result: {
          error: "Error encoding idBlock for ASN.1 schema"
        }
      };
    }
    var decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);
    if (decodedOffset === -1) {
      return {
        verified: false,
        result: {
          error: "Error decoding idBlock for ASN.1 schema"
        }
      };
    }
    if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS) === false) {
      return {
        verified: false,
        result: {
          error: "Wrong ASN.1 schema"
        }
      };
    }
    if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {
      return {
        verified: false,
        result: root
      };
    }
    if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER) === false) {
      return {
        verified: false,
        result: {
          error: "Wrong ASN.1 schema"
        }
      };
    }
    if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {
      return {
        verified: false,
        result: root
      };
    }
    if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED) === false) {
      return {
        verified: false,
        result: {
          error: "Wrong ASN.1 schema"
        }
      };
    }
    if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {
      return {
        verified: false,
        result: root
      };
    }
    if (!(IS_HEX_ONLY in inputSchema.idBlock)) {
      return {
        verified: false,
        result: {
          error: "Wrong ASN.1 schema"
        }
      };
    }
    if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {
      return {
        verified: false,
        result: root
      };
    }
    if (inputSchema.idBlock.isHexOnly) {
      if (VALUE_HEX_VIEW in inputSchema.idBlock === false) {
        return {
          verified: false,
          result: {
            error: "Wrong ASN.1 schema"
          }
        };
      }
      var schemaView = inputSchema.idBlock.valueHexView;
      var asn1View = inputData.idBlock.valueHexView;
      if (schemaView.length !== asn1View.length) {
        return {
          verified: false,
          result: root
        };
      }
      for (var i = 0; i < schemaView.length; i++) {
        if (schemaView[i] !== asn1View[1]) {
          return {
            verified: false,
            result: root
          };
        }
      }
    }
    if (inputSchema.name) {
      inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING$1);
      if (inputSchema.name) root[inputSchema.name] = inputData;
    }
    if (inputSchema instanceof typeStore.Constructed) {
      var admission = 0;
      var _result2 = {
        verified: false,
        result: {
          error: "Unknown error"
        }
      };
      var maxLength = inputSchema.valueBlock.value.length;
      if (maxLength > 0) {
        if (inputSchema.valueBlock.value[0] instanceof Repeated) {
          maxLength = inputData.valueBlock.value.length;
        }
      }
      if (maxLength === 0) {
        return {
          verified: true,
          result: root
        };
      }
      if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {
        var _optional = true;
        for (var _i18 = 0; _i18 < inputSchema.valueBlock.value.length; _i18++) _optional = _optional && (inputSchema.valueBlock.value[_i18].optional || false);
        if (_optional) {
          return {
            verified: true,
            result: root
          };
        }
        if (inputSchema.name) {
          inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING$1);
          if (inputSchema.name) delete root[inputSchema.name];
        }
        root.error = "Inconsistent object length";
        return {
          verified: false,
          result: root
        };
      }
      for (var _i19 = 0; _i19 < maxLength; _i19++) {
        if (_i19 - admission >= inputData.valueBlock.value.length) {
          if (inputSchema.valueBlock.value[_i19].optional === false) {
            var _result3 = {
              verified: false,
              result: root
            };
            root.error = "Inconsistent length between ASN.1 data and schema";
            if (inputSchema.name) {
              inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING$1);
              if (inputSchema.name) {
                delete root[inputSchema.name];
                _result3.name = inputSchema.name;
              }
            }
            return _result3;
          }
        } else {
          if (inputSchema.valueBlock.value[0] instanceof Repeated) {
            _result2 = compareSchema(root, inputData.valueBlock.value[_i19], inputSchema.valueBlock.value[0].value);
            if (_result2.verified === false) {
              if (inputSchema.valueBlock.value[0].optional) admission++;else {
                if (inputSchema.name) {
                  inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING$1);
                  if (inputSchema.name) delete root[inputSchema.name];
                }
                return _result2;
              }
            }
            if (NAME in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {
              var arrayRoot = {};
              if (LOCAL in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local) arrayRoot = inputData;else arrayRoot = root;
              if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === "undefined") arrayRoot[inputSchema.valueBlock.value[0].name] = [];
              arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[_i19]);
            }
          } else {
            _result2 = compareSchema(root, inputData.valueBlock.value[_i19 - admission], inputSchema.valueBlock.value[_i19]);
            if (_result2.verified === false) {
              if (inputSchema.valueBlock.value[_i19].optional) admission++;else {
                if (inputSchema.name) {
                  inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING$1);
                  if (inputSchema.name) delete root[inputSchema.name];
                }
                return _result2;
              }
            }
          }
        }
      }
      if (_result2.verified === false) {
        var _result4 = {
          verified: false,
          result: root
        };
        if (inputSchema.name) {
          inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING$1);
          if (inputSchema.name) {
            delete root[inputSchema.name];
            _result4.name = inputSchema.name;
          }
        }
        return _result4;
      }
      return {
        verified: true,
        result: root
      };
    }
    if (inputSchema.primitiveSchema && VALUE_HEX_VIEW in inputData.valueBlock) {
      var asn1 = localFromBER(inputData.valueBlock.valueHexView);
      if (asn1.offset === -1) {
        var _result5 = {
          verified: false,
          result: asn1.result
        };
        if (inputSchema.name) {
          inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING$1);
          if (inputSchema.name) {
            delete root[inputSchema.name];
            _result5.name = inputSchema.name;
          }
        }
        return _result5;
      }
      return compareSchema(root, asn1.result, inputSchema.primitiveSchema);
    }
    return {
      verified: true,
      result: root
    };
  }
  var ByteStream = function () {
    function ByteStream() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, ByteStream);
      if ("view" in parameters) {
        this.fromUint8Array(parameters.view);
      } else if ("buffer" in parameters) {
        this.fromArrayBuffer(parameters.buffer);
      } else if ("string" in parameters) {
        this.fromString(parameters.string);
      } else if ("hexstring" in parameters) {
        this.fromHexString(parameters.hexstring);
      } else {
        if ("length" in parameters && parameters.length > 0) {
          this.length = parameters.length;
          if (parameters.stub) {
            for (var i = 0; i < this._view.length; i++) {
              this._view[i] = parameters.stub;
            }
          }
        } else {
          this.length = 0;
        }
      }
    }
    return _createClass(ByteStream, [{
      key: "buffer",
      get: function get() {
        return this._buffer;
      },
      set: function set(value) {
        this._buffer = value;
        this._view = new Uint8Array(this._buffer);
      }
    }, {
      key: "view",
      get: function get() {
        return this._view;
      },
      set: function set(value) {
        this._buffer = new ArrayBuffer(value.length);
        this._view = new Uint8Array(this._buffer);
        this._view.set(value);
      }
    }, {
      key: "length",
      get: function get() {
        return this.view.byteLength;
      },
      set: function set(value) {
        this._buffer = new ArrayBuffer(value);
        this._view = new Uint8Array(this._buffer);
      }
    }, {
      key: "clear",
      value: function clear() {
        this._buffer = new ArrayBuffer(0);
        this._view = new Uint8Array(this._buffer);
      }
    }, {
      key: "fromArrayBuffer",
      value: function fromArrayBuffer(array) {
        this._buffer = array;
        this._view = new Uint8Array(this._buffer);
      }
    }, {
      key: "fromUint8Array",
      value: function fromUint8Array(array) {
        this.fromArrayBuffer(new Uint8Array(array).buffer);
      }
    }, {
      key: "fromString",
      value: function fromString(string) {
        var stringLength = string.length;
        this.length = stringLength;
        for (var i = 0; i < stringLength; i++) this.view[i] = string.charCodeAt(i);
      }
    }, {
      key: "toString",
      value: function toString() {
        var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.view.length - start;
        var result = "";
        if (start >= this.view.length || start < 0) {
          start = 0;
        }
        if (length >= this.view.length || length < 0) {
          length = this.view.length - start;
        }
        for (var i = start; i < start + length; i++) result += String.fromCharCode(this.view[i]);
        return result;
      }
    }, {
      key: "fromHexString",
      value: function fromHexString(hexString) {
        var stringLength = hexString.length;
        this.buffer = new ArrayBuffer(stringLength >> 1);
        this.view = new Uint8Array(this.buffer);
        var hexMap = new Map();
        hexMap.set("0", 0x00);
        hexMap.set("1", 0x01);
        hexMap.set("2", 0x02);
        hexMap.set("3", 0x03);
        hexMap.set("4", 0x04);
        hexMap.set("5", 0x05);
        hexMap.set("6", 0x06);
        hexMap.set("7", 0x07);
        hexMap.set("8", 0x08);
        hexMap.set("9", 0x09);
        hexMap.set("A", 0x0A);
        hexMap.set("a", 0x0A);
        hexMap.set("B", 0x0B);
        hexMap.set("b", 0x0B);
        hexMap.set("C", 0x0C);
        hexMap.set("c", 0x0C);
        hexMap.set("D", 0x0D);
        hexMap.set("d", 0x0D);
        hexMap.set("E", 0x0E);
        hexMap.set("e", 0x0E);
        hexMap.set("F", 0x0F);
        hexMap.set("f", 0x0F);
        var j = 0;
        var temp = 0x00;
        for (var i = 0; i < stringLength; i++) {
          if (!(i % 2)) {
            temp = hexMap.get(hexString.charAt(i)) << 4;
          } else {
            temp |= hexMap.get(hexString.charAt(i));
            this.view[j] = temp;
            j++;
          }
        }
      }
    }, {
      key: "toHexString",
      value: function toHexString() {
        var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.view.length - start;
        var result = "";
        if (start >= this.view.length || start < 0) {
          start = 0;
        }
        if (length >= this.view.length || length < 0) {
          length = this.view.length - start;
        }
        for (var i = start; i < start + length; i++) {
          var str = this.view[i].toString(16).toUpperCase();
          result = result + (str.length == 1 ? "0" : "") + str;
        }
        return result;
      }
    }, {
      key: "copy",
      value: function copy() {
        var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.length - start;
        if (!start && !this.length) {
          return new ByteStream();
        }
        if (start < 0 || start > this.length - 1) {
          throw new Error("Wrong start position: ".concat(start));
        }
        var stream = new ByteStream({
          buffer: this._buffer.slice(start, start + length)
        });
        return stream;
      }
    }, {
      key: "slice",
      value: function slice() {
        var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.length;
        if (!start && !this.length) {
          return new ByteStream();
        }
        if (start < 0 || start > this.length - 1) {
          throw new Error("Wrong start position: ".concat(start));
        }
        var stream = new ByteStream({
          buffer: this._buffer.slice(start, end)
        });
        return stream;
      }
    }, {
      key: "realloc",
      value: function realloc(size) {
        var buffer = new ArrayBuffer(size);
        var view = new Uint8Array(buffer);
        if (size > this._view.length) view.set(this._view);else {
          view.set(new Uint8Array(this._buffer, 0, size));
        }
        this._buffer = buffer;
        this._view = new Uint8Array(this._buffer);
      }
    }, {
      key: "append",
      value: function append(stream) {
        var initialSize = this.length;
        var streamViewLength = stream.length;
        var subarrayView = stream._view.subarray();
        this.realloc(initialSize + streamViewLength);
        this._view.set(subarrayView, initialSize);
      }
    }, {
      key: "insert",
      value: function insert(stream) {
        var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.length - start;
        if (start > this.length - 1) return false;
        if (length > this.length - start) {
          length = this.length - start;
        }
        if (length > stream.length) {
          length = stream.length;
        }
        if (length == stream.length) this._view.set(stream._view, start);else {
          this._view.set(stream._view.subarray(0, length), start);
        }
        return true;
      }
    }, {
      key: "isEqual",
      value: function isEqual(stream) {
        if (this.length != stream.length) return false;
        for (var i = 0; i < stream.length; i++) {
          if (this.view[i] != stream.view[i]) return false;
        }
        return true;
      }
    }, {
      key: "isEqualView",
      value: function isEqualView(view) {
        if (view.length != this.view.length) return false;
        for (var i = 0; i < view.length; i++) {
          if (this.view[i] != view[i]) return false;
        }
        return true;
      }
    }, {
      key: "findPattern",
      value: function findPattern(pattern, start_, length_, backward_) {
        var _this$prepareFindPara = this.prepareFindParameters(start_, length_, backward_),
          start = _this$prepareFindPara.start,
          length = _this$prepareFindPara.length,
          backward = _this$prepareFindPara.backward;
        var patternLength = pattern.length;
        if (patternLength > length) {
          return -1;
        }
        var patternArray = [];
        for (var i = 0; i < patternLength; i++) patternArray.push(pattern.view[i]);
        for (var _i20 = 0; _i20 <= length - patternLength; _i20++) {
          var equal = true;
          var equalStart = backward ? start - patternLength - _i20 : start + _i20;
          for (var j = 0; j < patternLength; j++) {
            if (this.view[j + equalStart] != patternArray[j]) {
              equal = false;
              break;
            }
          }
          if (equal) {
            return backward ? start - patternLength - _i20 : start + patternLength + _i20;
          }
        }
        return -1;
      }
    }, {
      key: "findFirstIn",
      value: function findFirstIn(patterns, start_, length_, backward_) {
        var _this$prepareFindPara2 = this.prepareFindParameters(start_, length_, backward_),
          start = _this$prepareFindPara2.start,
          length = _this$prepareFindPara2.length,
          backward = _this$prepareFindPara2.backward;
        var result = {
          id: -1,
          position: backward ? 0 : start + length,
          length: 0
        };
        for (var i = 0; i < patterns.length; i++) {
          var position = this.findPattern(patterns[i], start, length, backward);
          if (position != -1) {
            var valid = false;
            var patternLength = patterns[i].length;
            if (backward) {
              if (position - patternLength >= result.position - result.length) valid = true;
            } else {
              if (position - patternLength <= result.position - result.length) valid = true;
            }
            if (valid) {
              result.position = position;
              result.id = i;
              result.length = patternLength;
            }
          }
        }
        return result;
      }
    }, {
      key: "findAllIn",
      value: function findAllIn(patterns, start_, length_) {
        var _this$prepareFindPara3 = this.prepareFindParameters(start_, length_),
          start = _this$prepareFindPara3.start,
          length = _this$prepareFindPara3.length;
        var result = [];
        var patternFound = {
          id: -1,
          position: start
        };
        do {
          var position = patternFound.position;
          patternFound = this.findFirstIn(patterns, patternFound.position, length);
          if (patternFound.id == -1) {
            break;
          }
          length -= patternFound.position - position;
          result.push({
            id: patternFound.id,
            position: patternFound.position
          });
        } while (true);
        return result;
      }
    }, {
      key: "findAllPatternIn",
      value: function findAllPatternIn(pattern, start_, length_) {
        var _this$prepareFindPara4 = this.prepareFindParameters(start_, length_),
          start = _this$prepareFindPara4.start,
          length = _this$prepareFindPara4.length;
        var result = [];
        var patternLength = pattern.length;
        if (patternLength > length) {
          return -1;
        }
        var patternArray = Array.from(pattern.view);
        for (var i = 0; i <= length - patternLength; i++) {
          var equal = true;
          var equalStart = start + i;
          for (var j = 0; j < patternLength; j++) {
            if (this.view[j + equalStart] != patternArray[j]) {
              equal = false;
              break;
            }
          }
          if (equal) {
            result.push(start + patternLength + i);
            i += patternLength - 1;
          }
        }
        return result;
      }
    }, {
      key: "findFirstNotIn",
      value: function findFirstNotIn(patterns, start_, length_, backward_) {
        var _this$prepareFindPara5 = this.prepareFindParameters(start_, length_, backward_),
          start = _this$prepareFindPara5.start,
          length = _this$prepareFindPara5.length,
          backward = _this$prepareFindPara5.backward;
        var result = {
          left: {
            id: -1,
            position: start
          },
          right: {
            id: -1,
            position: 0
          },
          value: new ByteStream()
        };
        var currentLength = length;
        while (currentLength > 0) {
          result.right = this.findFirstIn(patterns, backward ? start - length + currentLength : start + length - currentLength, currentLength, backward);
          if (result.right.id == -1) {
            length = currentLength;
            if (backward) {
              start -= length;
            } else {
              start = result.left.position;
            }
            result.value = new ByteStream({
              buffer: this._buffer.slice(start, start + length)
            });
            break;
          }
          if (result.right.position != (backward ? result.left.position - patterns[result.right.id].length : result.left.position + patterns[result.right.id].length)) {
            if (backward) {
              start = result.right.position + patterns[result.right.id].length;
              length = result.left.position - result.right.position - patterns[result.right.id].length;
            } else {
              start = result.left.position;
              length = result.right.position - result.left.position - patterns[result.right.id].length;
            }
            result.value = new ByteStream({
              buffer: this._buffer.slice(start, start + length)
            });
            break;
          }
          result.left = result.right;
          currentLength -= patterns[result.right.id].length;
        }
        if (backward) {
          var temp = result.right;
          result.right = result.left;
          result.left = temp;
        }
        return result;
      }
    }, {
      key: "findAllNotIn",
      value: function findAllNotIn(patterns, start_, length_) {
        var _this$prepareFindPara6 = this.prepareFindParameters(start_, length_),
          start = _this$prepareFindPara6.start,
          length = _this$prepareFindPara6.length;
        var result = [];
        var patternFound = {
          left: {
            id: -1,
            position: start
          },
          right: {
            id: -1,
            position: start
          },
          value: new ByteStream()
        };
        do {
          var position = patternFound.right.position;
          patternFound = this.findFirstNotIn(patterns, patternFound.right.position, length);
          length -= patternFound.right.position - position;
          result.push({
            left: {
              id: patternFound.left.id,
              position: patternFound.left.position
            },
            right: {
              id: patternFound.right.id,
              position: patternFound.right.position
            },
            value: patternFound.value
          });
        } while (patternFound.right.id != -1);
        return result;
      }
    }, {
      key: "findFirstSequence",
      value: function findFirstSequence(patterns, start_, length_, backward_) {
        var _this$prepareFindPara7 = this.prepareFindParameters(start_, length_, backward_),
          start = _this$prepareFindPara7.start,
          length = _this$prepareFindPara7.length,
          backward = _this$prepareFindPara7.backward;
        var firstIn = this.skipNotPatterns(patterns, start, length, backward);
        if (firstIn == -1) {
          return {
            position: -1,
            value: new ByteStream()
          };
        }
        var firstNotIn = this.skipPatterns(patterns, firstIn, length - (backward ? start - firstIn : firstIn - start), backward);
        if (backward) {
          start = firstNotIn;
          length = firstIn - firstNotIn;
        } else {
          start = firstIn;
          length = firstNotIn - firstIn;
        }
        var value = new ByteStream({
          buffer: this._buffer.slice(start, start + length)
        });
        return {
          position: firstNotIn,
          value: value
        };
      }
    }, {
      key: "findAllSequences",
      value: function findAllSequences(patterns, start_, length_) {
        var _this$prepareFindPara8 = this.prepareFindParameters(start_, length_),
          start = _this$prepareFindPara8.start,
          length = _this$prepareFindPara8.length;
        var result = [];
        var patternFound = {
          position: start,
          value: new ByteStream()
        };
        do {
          var position = patternFound.position;
          patternFound = this.findFirstSequence(patterns, patternFound.position, length);
          if (patternFound.position != -1) {
            length -= patternFound.position - position;
            result.push({
              position: patternFound.position,
              value: patternFound.value
            });
          }
        } while (patternFound.position != -1);
        return result;
      }
    }, {
      key: "findPairedPatterns",
      value: function findPairedPatterns(leftPattern, rightPattern, start_, length_) {
        var result = [];
        if (leftPattern.isEqual(rightPattern)) return result;
        var _this$prepareFindPara9 = this.prepareFindParameters(start_, length_),
          start = _this$prepareFindPara9.start,
          length = _this$prepareFindPara9.length;
        var currentPositionLeft = 0;
        var leftPatterns = this.findAllPatternIn(leftPattern, start, length);
        if (!Array.isArray(leftPatterns) || leftPatterns.length == 0) {
          return result;
        }
        var rightPatterns = this.findAllPatternIn(rightPattern, start, length);
        if (!Array.isArray(rightPatterns) || rightPatterns.length == 0) {
          return result;
        }
        while (currentPositionLeft < leftPatterns.length) {
          if (rightPatterns.length == 0) {
            break;
          }
          if (leftPatterns[0] == rightPatterns[0]) {
            result.push({
              left: leftPatterns[0],
              right: rightPatterns[0]
            });
            leftPatterns.splice(0, 1);
            rightPatterns.splice(0, 1);
            continue;
          }
          if (leftPatterns[currentPositionLeft] > rightPatterns[0]) {
            break;
          }
          while (leftPatterns[currentPositionLeft] < rightPatterns[0]) {
            currentPositionLeft++;
            if (currentPositionLeft >= leftPatterns.length) {
              break;
            }
          }
          result.push({
            left: leftPatterns[currentPositionLeft - 1],
            right: rightPatterns[0]
          });
          leftPatterns.splice(currentPositionLeft - 1, 1);
          rightPatterns.splice(0, 1);
          currentPositionLeft = 0;
        }
        result.sort(function (a, b) {
          return a.left - b.left;
        });
        return result;
      }
    }, {
      key: "findPairedArrays",
      value: function findPairedArrays(inputLeftPatterns, inputRightPatterns, start_, length_) {
        var _this$prepareFindPara10 = this.prepareFindParameters(start_, length_),
          start = _this$prepareFindPara10.start,
          length = _this$prepareFindPara10.length;
        var result = [];
        var currentPositionLeft = 0;
        var leftPatterns = this.findAllIn(inputLeftPatterns, start, length);
        if (leftPatterns.length == 0) return result;
        var rightPatterns = this.findAllIn(inputRightPatterns, start, length);
        if (rightPatterns.length == 0) return result;
        while (currentPositionLeft < leftPatterns.length) {
          if (rightPatterns.length == 0) {
            break;
          }
          if (leftPatterns[0].position == rightPatterns[0].position) {
            result.push({
              left: leftPatterns[0],
              right: rightPatterns[0]
            });
            leftPatterns.splice(0, 1);
            rightPatterns.splice(0, 1);
            continue;
          }
          if (leftPatterns[currentPositionLeft].position > rightPatterns[0].position) {
            break;
          }
          while (leftPatterns[currentPositionLeft].position < rightPatterns[0].position) {
            currentPositionLeft++;
            if (currentPositionLeft >= leftPatterns.length) {
              break;
            }
          }
          result.push({
            left: leftPatterns[currentPositionLeft - 1],
            right: rightPatterns[0]
          });
          leftPatterns.splice(currentPositionLeft - 1, 1);
          rightPatterns.splice(0, 1);
          currentPositionLeft = 0;
        }
        result.sort(function (a, b) {
          return a.left.position - b.left.position;
        });
        return result;
      }
    }, {
      key: "replacePattern",
      value: function replacePattern(searchPattern, _replacePattern, start_, length_) {
        var _output$searchPattern;
        var findAllResult = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
        var result = [];
        var i;
        var output = {
          status: -1,
          searchPatternPositions: [],
          replacePatternPositions: []
        };
        var _this$prepareFindPara11 = this.prepareFindParameters(start_, length_),
          start = _this$prepareFindPara11.start,
          length = _this$prepareFindPara11.length;
        if (findAllResult == null) {
          result = this.findAllIn([searchPattern], start, length);
          if (result.length == 0) {
            return output;
          }
        } else {
          result = findAllResult;
        }
        (_output$searchPattern = output.searchPatternPositions).push.apply(_output$searchPattern, _toConsumableArray(Array.from(result, function (element) {
          return element.position;
        })));
        var patternDifference = searchPattern.length - _replacePattern.length;
        var changedBuffer = new ArrayBuffer(this.view.length - result.length * patternDifference);
        var changedView = new Uint8Array(changedBuffer);
        changedView.set(new Uint8Array(this.buffer, 0, start));
        for (i = 0; i < result.length; i++) {
          var currentPosition = i == 0 ? start : result[i - 1].position;
          changedView.set(new Uint8Array(this.buffer, currentPosition, result[i].position - searchPattern.length - currentPosition), currentPosition - i * patternDifference);
          changedView.set(_replacePattern.view, result[i].position - searchPattern.length - i * patternDifference);
          output.replacePatternPositions.push(result[i].position - searchPattern.length - i * patternDifference);
        }
        i--;
        changedView.set(new Uint8Array(this.buffer, result[i].position, this.length - result[i].position), result[i].position - searchPattern.length + _replacePattern.length - i * patternDifference);
        this.buffer = changedBuffer;
        this.view = new Uint8Array(this.buffer);
        output.status = 1;
        return output;
      }
    }, {
      key: "skipPatterns",
      value: function skipPatterns(patterns, start_, length_, backward_) {
        var _this$prepareFindPara12 = this.prepareFindParameters(start_, length_, backward_),
          start = _this$prepareFindPara12.start,
          length = _this$prepareFindPara12.length,
          backward = _this$prepareFindPara12.backward;
        var result = start;
        for (var k = 0; k < patterns.length; k++) {
          var patternLength = patterns[k].length;
          var equalStart = backward ? result - patternLength : result;
          var equal = true;
          for (var j = 0; j < patternLength; j++) {
            if (this.view[j + equalStart] != patterns[k].view[j]) {
              equal = false;
              break;
            }
          }
          if (equal) {
            k = -1;
            if (backward) {
              result -= patternLength;
              if (result <= 0) return result;
            } else {
              result += patternLength;
              if (result >= start + length) return result;
            }
          }
        }
        return result;
      }
    }, {
      key: "skipNotPatterns",
      value: function skipNotPatterns(patterns, start_, length_, backward_) {
        var _this$prepareFindPara13 = this.prepareFindParameters(start_, length_, backward_),
          start = _this$prepareFindPara13.start,
          length = _this$prepareFindPara13.length,
          backward = _this$prepareFindPara13.backward;
        var result = -1;
        for (var i = 0; i < length; i++) {
          for (var k = 0; k < patterns.length; k++) {
            var patternLength = patterns[k].length;
            var equalStart = backward ? start - i - patternLength : start + i;
            var equal = true;
            for (var j = 0; j < patternLength; j++) {
              if (this.view[j + equalStart] != patterns[k].view[j]) {
                equal = false;
                break;
              }
            }
            if (equal) {
              result = backward ? start - i : start + i;
              break;
            }
          }
          if (result != -1) {
            break;
          }
        }
        return result;
      }
    }, {
      key: "prepareFindParameters",
      value: function prepareFindParameters() {
        var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var backward = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        if (start === null) {
          start = backward ? this.length : 0;
        }
        if (start > this.length) {
          start = this.length;
        }
        if (backward) {
          if (length === null) {
            length = start;
          }
          if (length > start) {
            length = start;
          }
        } else {
          if (length === null) {
            length = this.length - start;
          }
          if (length > this.length - start) {
            length = this.length - start;
          }
        }
        return {
          start: start,
          length: length,
          backward: backward
        };
      }
    }]);
  }();
  var pow2_24 = 16777216;
  var SeqStream = function () {
    function SeqStream() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, SeqStream);
      this._stream = new ByteStream();
      this._length = 0;
      this._start = 0;
      this.backward = false;
      this.appendBlock = 0;
      this.prevLength = 0;
      this.prevStart = 0;
      if ("view" in parameters) {
        this.stream = new ByteStream({
          view: parameters.view
        });
      } else if ("buffer" in parameters) {
        this.stream = new ByteStream({
          buffer: parameters.buffer
        });
      } else if ("string" in parameters) {
        this.stream = new ByteStream({
          string: parameters.string
        });
      } else if ("hexstring" in parameters) {
        this.stream = new ByteStream({
          hexstring: parameters.hexstring
        });
      } else if ("stream" in parameters) {
        this.stream = parameters.stream.slice();
      } else {
        this.stream = new ByteStream();
      }
      if ("backward" in parameters && parameters.backward) {
        this.backward = parameters.backward;
        this._start = this.stream.length;
      }
      if ("length" in parameters && parameters.length > 0) {
        this._length = parameters.length;
      }
      if ("start" in parameters && parameters.start && parameters.start > 0) {
        this._start = parameters.start;
      }
      if ("appendBlock" in parameters && parameters.appendBlock && parameters.appendBlock > 0) {
        this.appendBlock = parameters.appendBlock;
      }
    }
    return _createClass(SeqStream, [{
      key: "stream",
      get: function get() {
        return this._stream;
      },
      set: function set(value) {
        this._stream = value;
        this.prevLength = this._length;
        this._length = value.length;
        this.prevStart = this._start;
        this._start = 0;
      }
    }, {
      key: "length",
      get: function get() {
        if (this.appendBlock) {
          return this.start;
        }
        return this._length;
      },
      set: function set(value) {
        this.prevLength = this._length;
        this._length = value;
      }
    }, {
      key: "start",
      get: function get() {
        return this._start;
      },
      set: function set(value) {
        if (value > this.stream.length) return;
        this.prevStart = this._start;
        this.prevLength = this._length;
        this._length -= this.backward ? this._start - value : value - this._start;
        this._start = value;
      }
    }, {
      key: "buffer",
      get: function get() {
        return this._stream.buffer.slice(0, this._length);
      }
    }, {
      key: "resetPosition",
      value: function resetPosition() {
        this._start = this.prevStart;
        this._length = this.prevLength;
      }
    }, {
      key: "findPattern",
      value: function findPattern(pattern) {
        var gap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        if (gap == null || gap > this.length) {
          gap = this.length;
        }
        var result = this.stream.findPattern(pattern, this.start, this.length, this.backward);
        if (result == -1) return result;
        if (this.backward) {
          if (result < this.start - pattern.length - gap) {
            return -1;
          }
        } else {
          if (result > this.start + pattern.length + gap) {
            return -1;
          }
        }
        this.start = result;
        return result;
      }
    }, {
      key: "findFirstIn",
      value: function findFirstIn(patterns) {
        var gap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        if (gap == null || gap > this.length) {
          gap = this.length;
        }
        var result = this.stream.findFirstIn(patterns, this.start, this.length, this.backward);
        if (result.id == -1) return result;
        if (this.backward) {
          if (result.position < this.start - patterns[result.id].length - gap) {
            return {
              id: -1,
              position: this.backward ? 0 : this.start + this.length
            };
          }
        } else {
          if (result.position > this.start + patterns[result.id].length + gap) {
            return {
              id: -1,
              position: this.backward ? 0 : this.start + this.length
            };
          }
        }
        this.start = result.position;
        return result;
      }
    }, {
      key: "findAllIn",
      value: function findAllIn(patterns) {
        var start = this.backward ? this.start - this.length : this.start;
        return this.stream.findAllIn(patterns, start, this.length);
      }
    }, {
      key: "findFirstNotIn",
      value: function findFirstNotIn(patterns) {
        var gap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        if (gap == null || gap > this._length) {
          gap = this._length;
        }
        var result = this._stream.findFirstNotIn(patterns, this._start, this._length, this.backward);
        if (result.left.id == -1 && result.right.id == -1) {
          return result;
        }
        if (this.backward) {
          if (result.right.id != -1) {
            if (result.right.position < this._start - patterns[result.right.id].length - gap) {
              return {
                left: {
                  id: -1,
                  position: this._start
                },
                right: {
                  id: -1,
                  position: 0
                },
                value: new ByteStream()
              };
            }
          }
        } else {
          if (result.left.id != -1) {
            if (result.left.position > this._start + patterns[result.left.id].length + gap) {
              return {
                left: {
                  id: -1,
                  position: this._start
                },
                right: {
                  id: -1,
                  position: 0
                },
                value: new ByteStream()
              };
            }
          }
        }
        if (this.backward) {
          if (result.left.id == -1) {
            this.start = 0;
          } else {
            this.start = result.left.position;
          }
        } else {
          if (result.right.id == -1) {
            this.start = this._start + this._length;
          } else {
            this.start = result.right.position;
          }
        }
        return result;
      }
    }, {
      key: "findAllNotIn",
      value: function findAllNotIn(patterns) {
        var start = this.backward ? this._start - this._length : this._start;
        return this._stream.findAllNotIn(patterns, start, this._length);
      }
    }, {
      key: "findFirstSequence",
      value: function findFirstSequence(patterns) {
        var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var gap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        if (length == null || length > this._length) {
          length = this._length;
        }
        if (gap == null || gap > length) {
          gap = length;
        }
        var result = this._stream.findFirstSequence(patterns, this._start, length, this.backward);
        if (result.value.length == 0) {
          return result;
        }
        if (this.backward) {
          if (result.position < this._start - result.value.length - gap) {
            return {
              position: -1,
              value: new ByteStream()
            };
          }
        } else {
          if (result.position > this._start + result.value.length + gap) {
            return {
              position: -1,
              value: new ByteStream()
            };
          }
        }
        this.start = result.position;
        return result;
      }
    }, {
      key: "findAllSequences",
      value: function findAllSequences(patterns) {
        var start = this.backward ? this.start - this.length : this.start;
        return this.stream.findAllSequences(patterns, start, this.length);
      }
    }, {
      key: "findPairedPatterns",
      value: function findPairedPatterns(leftPattern, rightPattern) {
        var gap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        if (gap == null || gap > this.length) {
          gap = this.length;
        }
        var start = this.backward ? this.start - this.length : this.start;
        var result = this.stream.findPairedPatterns(leftPattern, rightPattern, start, this.length);
        if (result.length) {
          if (this.backward) {
            if (result[0].right < this.start - rightPattern.length - gap) {
              return [];
            }
          } else {
            if (result[0].left > this.start + leftPattern.length + gap) {
              return [];
            }
          }
        }
        return result;
      }
    }, {
      key: "findPairedArrays",
      value: function findPairedArrays(leftPatterns, rightPatterns) {
        var gap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        if (gap == null || gap > this.length) {
          gap = this.length;
        }
        var start = this.backward ? this.start - this.length : this.start;
        var result = this.stream.findPairedArrays(leftPatterns, rightPatterns, start, this.length);
        if (result.length) {
          if (this.backward) {
            if (result[0].right.position < this.start - rightPatterns[result[0].right.id].length - gap) {
              return [];
            }
          } else {
            if (result[0].left.position > this.start + leftPatterns[result[0].left.id].length + gap) {
              return [];
            }
          }
        }
        return result;
      }
    }, {
      key: "replacePattern",
      value: function replacePattern(searchPattern, _replacePattern2) {
        var start = this.backward ? this.start - this.length : this.start;
        return this.stream.replacePattern(searchPattern, _replacePattern2, start, this.length);
      }
    }, {
      key: "skipPatterns",
      value: function skipPatterns(patterns) {
        var result = this.stream.skipPatterns(patterns, this.start, this.length, this.backward);
        this.start = result;
        return result;
      }
    }, {
      key: "skipNotPatterns",
      value: function skipNotPatterns(patterns) {
        var result = this.stream.skipNotPatterns(patterns, this.start, this.length, this.backward);
        if (result == -1) return -1;
        this.start = result;
        return result;
      }
    }, {
      key: "append",
      value: function append(stream) {
        this.beforeAppend(stream.length);
        this._stream.view.set(stream.view, this._start);
        this._length += stream.length * 2;
        this.start = this._start + stream.length;
        this.prevLength -= stream.length * 2;
      }
    }, {
      key: "appendView",
      value: function appendView(view) {
        this.beforeAppend(view.length);
        this._stream.view.set(view, this._start);
        this._length += view.length * 2;
        this.start = this._start + view.length;
        this.prevLength -= view.length * 2;
      }
    }, {
      key: "appendChar",
      value: function appendChar(char) {
        this.beforeAppend(1);
        this._stream.view[this._start] = char;
        this._length += 2;
        this.start = this._start + 1;
        this.prevLength -= 2;
      }
    }, {
      key: "appendUint16",
      value: function appendUint16(number) {
        this.beforeAppend(2);
        var value = new Uint16Array([number]);
        var view = new Uint8Array(value.buffer);
        this.stream.view[this._start] = view[1];
        this._stream.view[this._start + 1] = view[0];
        this._length += 4;
        this.start = this._start + 2;
        this.prevLength -= 4;
      }
    }, {
      key: "appendUint24",
      value: function appendUint24(number) {
        this.beforeAppend(3);
        var value = new Uint32Array([number]);
        var view = new Uint8Array(value.buffer);
        this._stream.view[this._start] = view[2];
        this._stream.view[this._start + 1] = view[1];
        this._stream.view[this._start + 2] = view[0];
        this._length += 6;
        this.start = this._start + 3;
        this.prevLength -= 6;
      }
    }, {
      key: "appendUint32",
      value: function appendUint32(number) {
        this.beforeAppend(4);
        var value = new Uint32Array([number]);
        var view = new Uint8Array(value.buffer);
        this._stream.view[this._start] = view[3];
        this._stream.view[this._start + 1] = view[2];
        this._stream.view[this._start + 2] = view[1];
        this._stream.view[this._start + 3] = view[0];
        this._length += 8;
        this.start = this._start + 4;
        this.prevLength -= 8;
      }
    }, {
      key: "appendInt16",
      value: function appendInt16(number) {
        this.beforeAppend(2);
        var value = new Int16Array([number]);
        var view = new Uint8Array(value.buffer);
        this._stream.view[this._start] = view[1];
        this._stream.view[this._start + 1] = view[0];
        this._length += 4;
        this.start = this._start + 2;
        this.prevLength -= 4;
      }
    }, {
      key: "appendInt32",
      value: function appendInt32(number) {
        this.beforeAppend(4);
        var value = new Int32Array([number]);
        var view = new Uint8Array(value.buffer);
        this._stream.view[this._start] = view[3];
        this._stream.view[this._start + 1] = view[2];
        this._stream.view[this._start + 2] = view[1];
        this._stream.view[this._start + 3] = view[0];
        this._length += 8;
        this.start = this._start + 4;
        this.prevLength -= 8;
      }
    }, {
      key: "getBlock",
      value: function getBlock(size) {
        var changeLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        if (this._length <= 0) {
          return new Uint8Array(0);
        }
        if (this._length < size) {
          size = this._length;
        }
        var result;
        if (this.backward) {
          var view = this._stream.view.subarray(this._length - size, this._length);
          result = new Uint8Array(size);
          for (var i = 0; i < size; i++) {
            result[size - 1 - i] = view[i];
          }
        } else {
          result = this._stream.view.subarray(this._start, this._start + size);
        }
        if (changeLength) {
          this.start += this.backward ? -1 * size : size;
        }
        return result;
      }
    }, {
      key: "getUint16",
      value: function getUint16() {
        var changeLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        var block = this.getBlock(2, changeLength);
        if (block.length < 2) return 0;
        return block[0] << 8 | block[1];
      }
    }, {
      key: "getInt16",
      value: function getInt16() {
        var changeLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        var num = this.getUint16(changeLength);
        var negative = 0x8000;
        if (num & negative) {
          return -(negative - (num ^ negative));
        }
        return num;
      }
    }, {
      key: "getUint24",
      value: function getUint24() {
        var changeLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        var block = this.getBlock(4, changeLength);
        if (block.length < 3) return 0;
        return block[0] << 16 | block[1] << 8 | block[2];
      }
    }, {
      key: "getUint32",
      value: function getUint32() {
        var changeLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        var block = this.getBlock(4, changeLength);
        if (block.length < 4) return 0;
        return block[0] * pow2_24 + (block[1] << 16) + (block[2] << 8) + block[3];
      }
    }, {
      key: "getInt32",
      value: function getInt32() {
        var changeLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        var num = this.getUint32(changeLength);
        var negative = 0x80000000;
        if (num & negative) {
          return -(negative - (num ^ negative));
        }
        return num;
      }
    }, {
      key: "beforeAppend",
      value: function beforeAppend(size) {
        if (this._start + size > this._stream.length) {
          if (size > this.appendBlock) {
            this.appendBlock = size + SeqStream.APPEND_BLOCK;
          }
          this._stream.realloc(this._stream.length + this.appendBlock);
        }
      }
    }]);
  }();
  SeqStream.APPEND_BLOCK = 1000;
  function isBytes(a) {
    return a instanceof Uint8Array || a != null && _typeof(a) === 'object' && a.constructor.name === 'Uint8Array';
  }
  function bytes(b) {
    if (!isBytes(b)) throw new Error('Uint8Array expected');
    for (var _len9 = arguments.length, lengths = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {
      lengths[_key9 - 1] = arguments[_key9];
    }
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error("Uint8Array expected of length ".concat(lengths, ", not of length=").concat(b.length));
  }
  function exists(instance) {
    var checkFinished = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    if (instance.destroyed) throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');
  }
  function output(out, instance) {
    bytes(out);
    var min = instance.outputLen;
    if (out.length < min) {
      throw new Error("digestInto() expects output buffer of length at least ".concat(min));
    }
  }
  var createView = function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  };
  var rotr = function rotr(word, shift) {
    return word << 32 - shift | word >>> shift;
  };
  var rotl = function rotl(word, shift) {
    return word << shift | word >>> 32 - shift >>> 0;
  };
  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
  function utf8ToBytes(str) {
    if (typeof str !== 'string') throw new Error("utf8ToBytes expected string, got ".concat(_typeof(str)));
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes(data) {
    if (typeof data === 'string') data = utf8ToBytes(data);
    bytes(data);
    return data;
  }
  var Hash = function () {
    function Hash() {
      _classCallCheck(this, Hash);
    }
    return _createClass(Hash, [{
      key: "clone",
      value: function clone() {
        return this._cloneInto();
      }
    }]);
  }();
  function wrapConstructor(hashCons) {
    var hashC = function hashC(msg) {
      return hashCons().update(toBytes(msg)).digest();
    };
    var tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = function () {
      return hashCons();
    };
    return hashC;
  }
  function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);
    var _32n = BigInt(32);
    var _u32_max = BigInt(0xffffffff);
    var wh = Number(value >> _32n & _u32_max);
    var wl = Number(value & _u32_max);
    var h = isLE ? 4 : 0;
    var l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
  }
  var Chi = function Chi(a, b, c) {
    return a & b ^ ~a & c;
  };
  var Maj = function Maj(a, b, c) {
    return a & b ^ a & c ^ b & c;
  };
  var HashMD = function (_Hash) {
    function HashMD(blockLen, outputLen, padOffset, isLE) {
      var _this52;
      _classCallCheck(this, HashMD);
      _this52 = _callSuper(this, HashMD);
      _this52.blockLen = blockLen;
      _this52.outputLen = outputLen;
      _this52.padOffset = padOffset;
      _this52.isLE = isLE;
      _this52.finished = false;
      _this52.length = 0;
      _this52.pos = 0;
      _this52.destroyed = false;
      _this52.buffer = new Uint8Array(blockLen);
      _this52.view = createView(_this52.buffer);
      return _this52;
    }
    _inherits(HashMD, _Hash);
    return _createClass(HashMD, [{
      key: "update",
      value: function update(data) {
        exists(this);
        var view = this.view,
          buffer = this.buffer,
          blockLen = this.blockLen;
        data = toBytes(data);
        var len = data.length;
        for (var pos = 0; pos < len;) {
          var take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            var dataView = createView(data);
            for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
    }, {
      key: "digestInto",
      value: function digestInto(out) {
        exists(this);
        output(out, this);
        this.finished = true;
        var buffer = this.buffer,
          view = this.view,
          blockLen = this.blockLen,
          isLE = this.isLE;
        var pos = this.pos;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (var i = pos; i < blockLen; i++) buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        var oview = createView(out);
        var len = this.outputLen;
        if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
        var outLen = len / 4;
        var state = this.get();
        if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');
        for (var _i21 = 0; _i21 < outLen; _i21++) oview.setUint32(4 * _i21, state[_i21], isLE);
      }
    }, {
      key: "digest",
      value: function digest() {
        var buffer = this.buffer,
          outputLen = this.outputLen;
        this.digestInto(buffer);
        var res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
    }, {
      key: "_cloneInto",
      value: function _cloneInto(to) {
        var _to;
        to || (to = new this.constructor());
        (_to = to).set.apply(_to, _toConsumableArray(this.get()));
        var blockLen = this.blockLen,
          buffer = this.buffer,
          length = this.length,
          finished = this.finished,
          destroyed = this.destroyed,
          pos = this.pos;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen) to.buffer.set(buffer);
        return to;
      }
    }]);
  }(Hash);
  var SHA1_IV = new Uint32Array([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0]);
  var SHA1_W = new Uint32Array(80);
  var SHA1$2 = function (_HashMD) {
    function SHA1() {
      var _this53;
      _classCallCheck(this, SHA1);
      _this53 = _callSuper(this, SHA1, [64, 20, 8, false]);
      _this53.A = SHA1_IV[0] | 0;
      _this53.B = SHA1_IV[1] | 0;
      _this53.C = SHA1_IV[2] | 0;
      _this53.D = SHA1_IV[3] | 0;
      _this53.E = SHA1_IV[4] | 0;
      return _this53;
    }
    _inherits(SHA1, _HashMD);
    return _createClass(SHA1, [{
      key: "get",
      value: function get() {
        var A = this.A,
          B = this.B,
          C = this.C,
          D = this.D,
          E = this.E;
        return [A, B, C, D, E];
      }
    }, {
      key: "set",
      value: function set(A, B, C, D, E) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
      }
    }, {
      key: "process",
      value: function process(view, offset) {
        for (var i = 0; i < 16; i++, offset += 4) SHA1_W[i] = view.getUint32(offset, false);
        for (var _i22 = 16; _i22 < 80; _i22++) SHA1_W[_i22] = rotl(SHA1_W[_i22 - 3] ^ SHA1_W[_i22 - 8] ^ SHA1_W[_i22 - 14] ^ SHA1_W[_i22 - 16], 1);
        var A = this.A,
          B = this.B,
          C = this.C,
          D = this.D,
          E = this.E;
        for (var _i23 = 0; _i23 < 80; _i23++) {
          var F = void 0,
            K = void 0;
          if (_i23 < 20) {
            F = Chi(B, C, D);
            K = 0x5a827999;
          } else if (_i23 < 40) {
            F = B ^ C ^ D;
            K = 0x6ed9eba1;
          } else if (_i23 < 60) {
            F = Maj(B, C, D);
            K = 0x8f1bbcdc;
          } else {
            F = B ^ C ^ D;
            K = 0xca62c1d6;
          }
          var T = rotl(A, 5) + F + E + K + SHA1_W[_i23] | 0;
          E = D;
          D = C;
          C = rotl(B, 30);
          B = A;
          A = T;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        this.set(A, B, C, D, E);
      }
    }, {
      key: "roundClean",
      value: function roundClean() {
        SHA1_W.fill(0);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.set(0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    }]);
  }(HashMD);
  var sha1 = wrapConstructor(function () {
    return new SHA1$2();
  });
  var SHA256_K = new Uint32Array([0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]);
  var SHA256_IV = new Uint32Array([0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]);
  var SHA256_W = new Uint32Array(64);
  var SHA256$2 = function (_HashMD2) {
    function SHA256() {
      var _this54;
      _classCallCheck(this, SHA256);
      _this54 = _callSuper(this, SHA256, [64, 32, 8, false]);
      _this54.A = SHA256_IV[0] | 0;
      _this54.B = SHA256_IV[1] | 0;
      _this54.C = SHA256_IV[2] | 0;
      _this54.D = SHA256_IV[3] | 0;
      _this54.E = SHA256_IV[4] | 0;
      _this54.F = SHA256_IV[5] | 0;
      _this54.G = SHA256_IV[6] | 0;
      _this54.H = SHA256_IV[7] | 0;
      return _this54;
    }
    _inherits(SHA256, _HashMD2);
    return _createClass(SHA256, [{
      key: "get",
      value: function get() {
        var A = this.A,
          B = this.B,
          C = this.C,
          D = this.D,
          E = this.E,
          F = this.F,
          G = this.G,
          H = this.H;
        return [A, B, C, D, E, F, G, H];
      }
    }, {
      key: "set",
      value: function set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
    }, {
      key: "process",
      value: function process(view, offset) {
        for (var i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);
        for (var _i24 = 16; _i24 < 64; _i24++) {
          var W15 = SHA256_W[_i24 - 15];
          var W2 = SHA256_W[_i24 - 2];
          var s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
          var s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
          SHA256_W[_i24] = s1 + SHA256_W[_i24 - 7] + s0 + SHA256_W[_i24 - 16] | 0;
        }
        var A = this.A,
          B = this.B,
          C = this.C,
          D = this.D,
          E = this.E,
          F = this.F,
          G = this.G,
          H = this.H;
        for (var _i25 = 0; _i25 < 64; _i25++) {
          var sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
          var T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[_i25] + SHA256_W[_i25] | 0;
          var sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
          var T2 = sigma0 + Maj(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
    }, {
      key: "roundClean",
      value: function roundClean() {
        SHA256_W.fill(0);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    }]);
  }(HashMD);
  var sha256 = wrapConstructor(function () {
    return new SHA256$2();
  });
  var U32_MASK64 = BigInt(Math.pow(2, 32) - 1);
  var _32n = BigInt(32);
  function fromBig(n) {
    var le = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (le) return {
      h: Number(n & U32_MASK64),
      l: Number(n >> _32n & U32_MASK64)
    };
    return {
      h: Number(n >> _32n & U32_MASK64) | 0,
      l: Number(n & U32_MASK64) | 0
    };
  }
  function split(lst) {
    var le = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var Ah = new Uint32Array(lst.length);
    var Al = new Uint32Array(lst.length);
    for (var i = 0; i < lst.length; i++) {
      var _fromBig = fromBig(lst[i], le),
        h = _fromBig.h,
        l = _fromBig.l;
      var _ref27 = [h, l];
      Ah[i] = _ref27[0];
      Al[i] = _ref27[1];
    }
    return [Ah, Al];
  }
  var toBig = function toBig(h, l) {
    return BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
  };
  var shrSH = function shrSH(h, _l, s) {
    return h >>> s;
  };
  var shrSL = function shrSL(h, l, s) {
    return h << 32 - s | l >>> s;
  };
  var rotrSH = function rotrSH(h, l, s) {
    return h >>> s | l << 32 - s;
  };
  var rotrSL = function rotrSL(h, l, s) {
    return h << 32 - s | l >>> s;
  };
  var rotrBH = function rotrBH(h, l, s) {
    return h << 64 - s | l >>> s - 32;
  };
  var rotrBL = function rotrBL(h, l, s) {
    return h >>> s - 32 | l << 64 - s;
  };
  var rotr32H = function rotr32H(_h, l) {
    return l;
  };
  var rotr32L = function rotr32L(h, _l) {
    return h;
  };
  var rotlSH = function rotlSH(h, l, s) {
    return h << s | l >>> 32 - s;
  };
  var rotlSL = function rotlSL(h, l, s) {
    return l << s | h >>> 32 - s;
  };
  var rotlBH = function rotlBH(h, l, s) {
    return l << s - 32 | h >>> 64 - s;
  };
  var rotlBL = function rotlBL(h, l, s) {
    return h << s - 32 | l >>> 64 - s;
  };
  function add(Ah, Al, Bh, Bl) {
    var l = (Al >>> 0) + (Bl >>> 0);
    return {
      h: Ah + Bh + (l / Math.pow(2, 32) | 0) | 0,
      l: l | 0
    };
  }
  var add3L = function add3L(Al, Bl, Cl) {
    return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  };
  var add3H = function add3H(low, Ah, Bh, Ch) {
    return Ah + Bh + Ch + (low / Math.pow(2, 32) | 0) | 0;
  };
  var add4L = function add4L(Al, Bl, Cl, Dl) {
    return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  };
  var add4H = function add4H(low, Ah, Bh, Ch, Dh) {
    return Ah + Bh + Ch + Dh + (low / Math.pow(2, 32) | 0) | 0;
  };
  var add5L = function add5L(Al, Bl, Cl, Dl, El) {
    return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  };
  var add5H = function add5H(low, Ah, Bh, Ch, Dh, Eh) {
    return Ah + Bh + Ch + Dh + Eh + (low / Math.pow(2, 32) | 0) | 0;
  };
  var u64 = {
    fromBig: fromBig,
    split: split,
    toBig: toBig,
    shrSH: shrSH,
    shrSL: shrSL,
    rotrSH: rotrSH,
    rotrSL: rotrSL,
    rotrBH: rotrBH,
    rotrBL: rotrBL,
    rotr32H: rotr32H,
    rotr32L: rotr32L,
    rotlSH: rotlSH,
    rotlSL: rotlSL,
    rotlBH: rotlBH,
    rotlBL: rotlBL,
    add: add,
    add3L: add3L,
    add3H: add3H,
    add4L: add4L,
    add4H: add4H,
    add5H: add5H,
    add5L: add5L
  };
  var u64$1 = u64;
  var _ref28 = function () {
      return u64$1.split(['0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc', '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118', '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2', '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694', '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65', '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5', '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4', '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70', '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df', '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b', '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30', '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8', '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8', '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3', '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec', '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b', '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178', '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b', '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c', '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'].map(function (n) {
        return BigInt(n);
      }));
    }(),
    _ref29 = _slicedToArray(_ref28, 2),
    SHA512_Kh = _ref29[0],
    SHA512_Kl = _ref29[1];
  var SHA512_W_H = new Uint32Array(80);
  var SHA512_W_L = new Uint32Array(80);
  var SHA512$2 = function (_HashMD3) {
    function SHA512() {
      var _this55;
      _classCallCheck(this, SHA512);
      _this55 = _callSuper(this, SHA512, [128, 64, 16, false]);
      _this55.Ah = 0x6a09e667 | 0;
      _this55.Al = 0xf3bcc908 | 0;
      _this55.Bh = 0xbb67ae85 | 0;
      _this55.Bl = 0x84caa73b | 0;
      _this55.Ch = 0x3c6ef372 | 0;
      _this55.Cl = 0xfe94f82b | 0;
      _this55.Dh = 0xa54ff53a | 0;
      _this55.Dl = 0x5f1d36f1 | 0;
      _this55.Eh = 0x510e527f | 0;
      _this55.El = 0xade682d1 | 0;
      _this55.Fh = 0x9b05688c | 0;
      _this55.Fl = 0x2b3e6c1f | 0;
      _this55.Gh = 0x1f83d9ab | 0;
      _this55.Gl = 0xfb41bd6b | 0;
      _this55.Hh = 0x5be0cd19 | 0;
      _this55.Hl = 0x137e2179 | 0;
      return _this55;
    }
    _inherits(SHA512, _HashMD3);
    return _createClass(SHA512, [{
      key: "get",
      value: function get() {
        var Ah = this.Ah,
          Al = this.Al,
          Bh = this.Bh,
          Bl = this.Bl,
          Ch = this.Ch,
          Cl = this.Cl,
          Dh = this.Dh,
          Dl = this.Dl,
          Eh = this.Eh,
          El = this.El,
          Fh = this.Fh,
          Fl = this.Fl,
          Gh = this.Gh,
          Gl = this.Gl,
          Hh = this.Hh,
          Hl = this.Hl;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
      }
    }, {
      key: "set",
      value: function set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
      }
    }, {
      key: "process",
      value: function process(view, offset) {
        for (var i = 0; i < 16; i++, offset += 4) {
          SHA512_W_H[i] = view.getUint32(offset);
          SHA512_W_L[i] = view.getUint32(offset += 4);
        }
        for (var _i26 = 16; _i26 < 80; _i26++) {
          var W15h = SHA512_W_H[_i26 - 15] | 0;
          var W15l = SHA512_W_L[_i26 - 15] | 0;
          var s0h = u64$1.rotrSH(W15h, W15l, 1) ^ u64$1.rotrSH(W15h, W15l, 8) ^ u64$1.shrSH(W15h, W15l, 7);
          var s0l = u64$1.rotrSL(W15h, W15l, 1) ^ u64$1.rotrSL(W15h, W15l, 8) ^ u64$1.shrSL(W15h, W15l, 7);
          var W2h = SHA512_W_H[_i26 - 2] | 0;
          var W2l = SHA512_W_L[_i26 - 2] | 0;
          var s1h = u64$1.rotrSH(W2h, W2l, 19) ^ u64$1.rotrBH(W2h, W2l, 61) ^ u64$1.shrSH(W2h, W2l, 6);
          var s1l = u64$1.rotrSL(W2h, W2l, 19) ^ u64$1.rotrBL(W2h, W2l, 61) ^ u64$1.shrSL(W2h, W2l, 6);
          var SUMl = u64$1.add4L(s0l, s1l, SHA512_W_L[_i26 - 7], SHA512_W_L[_i26 - 16]);
          var SUMh = u64$1.add4H(SUMl, s0h, s1h, SHA512_W_H[_i26 - 7], SHA512_W_H[_i26 - 16]);
          SHA512_W_H[_i26] = SUMh | 0;
          SHA512_W_L[_i26] = SUMl | 0;
        }
        var Ah = this.Ah,
          Al = this.Al,
          Bh = this.Bh,
          Bl = this.Bl,
          Ch = this.Ch,
          Cl = this.Cl,
          Dh = this.Dh,
          Dl = this.Dl,
          Eh = this.Eh,
          El = this.El,
          Fh = this.Fh,
          Fl = this.Fl,
          Gh = this.Gh,
          Gl = this.Gl,
          Hh = this.Hh,
          Hl = this.Hl;
        for (var _i27 = 0; _i27 < 80; _i27++) {
          var sigma1h = u64$1.rotrSH(Eh, El, 14) ^ u64$1.rotrSH(Eh, El, 18) ^ u64$1.rotrBH(Eh, El, 41);
          var sigma1l = u64$1.rotrSL(Eh, El, 14) ^ u64$1.rotrSL(Eh, El, 18) ^ u64$1.rotrBL(Eh, El, 41);
          var CHIh = Eh & Fh ^ ~Eh & Gh;
          var CHIl = El & Fl ^ ~El & Gl;
          var T1ll = u64$1.add5L(Hl, sigma1l, CHIl, SHA512_Kl[_i27], SHA512_W_L[_i27]);
          var T1h = u64$1.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[_i27], SHA512_W_H[_i27]);
          var T1l = T1ll | 0;
          var sigma0h = u64$1.rotrSH(Ah, Al, 28) ^ u64$1.rotrBH(Ah, Al, 34) ^ u64$1.rotrBH(Ah, Al, 39);
          var sigma0l = u64$1.rotrSL(Ah, Al, 28) ^ u64$1.rotrBL(Ah, Al, 34) ^ u64$1.rotrBL(Ah, Al, 39);
          var MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
          var MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;
          var _u64$1$add = u64$1.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0);
          Eh = _u64$1$add.h;
          El = _u64$1$add.l;
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl | 0;
          Bh = Ah | 0;
          Bl = Al | 0;
          var All = u64$1.add3L(T1l, sigma0l, MAJl);
          Ah = u64$1.add3H(All, T1h, sigma0h, MAJh);
          Al = All | 0;
        }
        var _u64$1$add2 = u64$1.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0);
        Ah = _u64$1$add2.h;
        Al = _u64$1$add2.l;
        var _u64$1$add3 = u64$1.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0);
        Bh = _u64$1$add3.h;
        Bl = _u64$1$add3.l;
        var _u64$1$add4 = u64$1.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0);
        Ch = _u64$1$add4.h;
        Cl = _u64$1$add4.l;
        var _u64$1$add5 = u64$1.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0);
        Dh = _u64$1$add5.h;
        Dl = _u64$1$add5.l;
        var _u64$1$add6 = u64$1.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0);
        Eh = _u64$1$add6.h;
        El = _u64$1$add6.l;
        var _u64$1$add7 = u64$1.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0);
        Fh = _u64$1$add7.h;
        Fl = _u64$1$add7.l;
        var _u64$1$add8 = u64$1.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0);
        Gh = _u64$1$add8.h;
        Gl = _u64$1$add8.l;
        var _u64$1$add9 = u64$1.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0);
        Hh = _u64$1$add9.h;
        Hl = _u64$1$add9.l;
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
      }
    }, {
      key: "roundClean",
      value: function roundClean() {
        SHA512_W_H.fill(0);
        SHA512_W_L.fill(0);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    }]);
  }(HashMD);
  var SHA384$2 = function (_SHA512$) {
    function SHA384() {
      var _this56;
      _classCallCheck(this, SHA384);
      _this56 = _callSuper(this, SHA384);
      _this56.Ah = 0xcbbb9d5d | 0;
      _this56.Al = 0xc1059ed8 | 0;
      _this56.Bh = 0x629a292a | 0;
      _this56.Bl = 0x367cd507 | 0;
      _this56.Ch = 0x9159015a | 0;
      _this56.Cl = 0x3070dd17 | 0;
      _this56.Dh = 0x152fecd8 | 0;
      _this56.Dl = 0xf70e5939 | 0;
      _this56.Eh = 0x67332667 | 0;
      _this56.El = 0xffc00b31 | 0;
      _this56.Fh = 0x8eb44a87 | 0;
      _this56.Fl = 0x68581511 | 0;
      _this56.Gh = 0xdb0c2e0d | 0;
      _this56.Gl = 0x64f98fa7 | 0;
      _this56.Hh = 0x47b5481d | 0;
      _this56.Hl = 0xbefa4fa4 | 0;
      _this56.outputLen = 48;
      return _this56;
    }
    _inherits(SHA384, _SHA512$);
    return _createClass(SHA384);
  }(SHA512$2);
  var sha512 = wrapConstructor(function () {
    return new SHA512$2();
  });
  var sha384 = wrapConstructor(function () {
    return new SHA384$2();
  });
  var EMPTY_BUFFER = new ArrayBuffer(0);
  var EMPTY_STRING = "";
  var ArgumentError = function (_TypeError) {
    function ArgumentError() {
      var _this57;
      _classCallCheck(this, ArgumentError);
      _this57 = _callSuper(this, ArgumentError, arguments);
      _this57.name = ArgumentError.NAME;
      return _this57;
    }
    _inherits(ArgumentError, _TypeError);
    return _createClass(ArgumentError, null, [{
      key: "isType",
      value: function isType(value, type) {
        if (typeof type === "string") {
          if (type === "Array" && Array.isArray(value)) {
            return true;
          } else if (type === "ArrayBuffer" && value instanceof ArrayBuffer) {
            return true;
          } else if (type === "ArrayBufferView" && ArrayBuffer.isView(value)) {
            return true;
          } else if (_typeof(value) === type) {
            return true;
          }
        } else if (value instanceof type) {
          return true;
        }
        return false;
      }
    }, {
      key: "assert",
      value: function assert(value, name) {
        for (var _len10 = arguments.length, types = new Array(_len10 > 2 ? _len10 - 2 : 0), _key10 = 2; _key10 < _len10; _key10++) {
          types[_key10 - 2] = arguments[_key10];
        }
        for (var _i28 = 0, _types = types; _i28 < _types.length; _i28++) {
          var type = _types[_i28];
          if (this.isType(value, type)) {
            return;
          }
        }
        var typeNames = types.map(function (o) {
          return o instanceof Function && "name" in o ? o.name : "".concat(o);
        });
        throw new ArgumentError("Parameter '".concat(name, "' is not of type ").concat(typeNames.length > 1 ? "(".concat(typeNames.join(" or "), ")") : typeNames[0]));
      }
    }]);
  }(_wrapNativeSuper(TypeError));
  ArgumentError.NAME = "ArgumentError";
  var ParameterError = function (_TypeError2) {
    function ParameterError(field) {
      var _this58;
      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var message = arguments.length > 2 ? arguments[2] : undefined;
      _classCallCheck(this, ParameterError);
      _this58 = _callSuper(this, ParameterError);
      _this58.name = ParameterError.NAME;
      _this58.field = field;
      if (target) {
        _this58.target = target;
      }
      if (message) {
        _this58.message = message;
      } else {
        _this58.message = "Absent mandatory parameter '".concat(field, "' ").concat(target ? " in '".concat(target, "'") : EMPTY_STRING);
      }
      return _this58;
    }
    _inherits(ParameterError, _TypeError2);
    return _createClass(ParameterError, null, [{
      key: "assert",
      value: function assert() {
        var target = null;
        var params;
        var fields;
        for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
          args[_key11] = arguments[_key11];
        }
        if (typeof args[0] === "string") {
          target = args[0];
          params = args[1];
          fields = args.slice(2);
        } else {
          params = args[0];
          fields = args.slice(1);
        }
        ArgumentError.assert(params, "parameters", "object");
        var _iterator15 = _createForOfIteratorHelper(fields),
          _step15;
        try {
          for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
            var field = _step15.value;
            var value = params[field];
            if (value === undefined || value === null) {
              throw new ParameterError(field, target);
            }
          }
        } catch (err) {
          _iterator15.e(err);
        } finally {
          _iterator15.f();
        }
      }
    }, {
      key: "assertEmpty",
      value: function assertEmpty(value, name, target) {
        if (value === undefined || value === null) {
          throw new ParameterError(name, target);
        }
      }
    }]);
  }(_wrapNativeSuper(TypeError));
  ParameterError.NAME = "ParameterError";
  var AsnError = function (_Error) {
    function AsnError(message) {
      var _this59;
      _classCallCheck(this, AsnError);
      _this59 = _callSuper(this, AsnError, [message]);
      _this59.name = "AsnError";
      return _this59;
    }
    _inherits(AsnError, _Error);
    return _createClass(AsnError, null, [{
      key: "assertSchema",
      value: function assertSchema(asn1, target) {
        if (!asn1.verified) {
          throw new Error("Object's schema was not verified against input data for ".concat(target));
        }
      }
    }, {
      key: "assert",
      value: function assert(asn, target) {
        if (asn.offset === -1) {
          throw new AsnError("Error during parsing of ASN.1 data. Data is not correct for '".concat(target, "'."));
        }
      }
    }]);
  }(_wrapNativeSuper(Error));
  var PkiObject = function () {
    function PkiObject() {
      _classCallCheck(this, PkiObject);
    }
    return _createClass(PkiObject, [{
      key: "className",
      get: function get() {
        return this.constructor.CLASS_NAME;
      }
    }, {
      key: "toString",
      value: function toString() {
        var encoding = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "hex";
        var schema;
        try {
          schema = this.toSchema();
        } catch (_unused) {
          schema = this.toSchema(true);
        }
        return Convert.ToString(schema.toBER(), encoding);
      }
    }], [{
      key: "blockName",
      value: function blockName() {
        return this.CLASS_NAME;
      }
    }, {
      key: "fromBER",
      value: function fromBER(raw) {
        var asn1 = _fromBER(raw);
        AsnError.assert(asn1, this.name);
        try {
          return new this({
            schema: asn1.result
          });
        } catch (e) {
          throw new AsnError("Cannot create '".concat(this.CLASS_NAME, "' from ASN.1 object"));
        }
      }
    }, {
      key: "defaultValues",
      value: function defaultValues(memberName) {
        throw new Error("Invalid member name for ".concat(this.CLASS_NAME, " class: ").concat(memberName));
      }
    }, {
      key: "schema",
      value: function schema() {
        throw new Error("Method '".concat(this.CLASS_NAME, ".schema' should be overridden"));
      }
    }]);
  }();
  PkiObject.CLASS_NAME = "PkiObject";
  function stringPrep(inputString) {
    var isSpace = false;
    var cutResult = EMPTY_STRING;
    var result = inputString.trim();
    for (var i = 0; i < result.length; i++) {
      if (result.charCodeAt(i) === 32) {
        if (isSpace === false) isSpace = true;
      } else {
        if (isSpace) {
          cutResult += " ";
          isSpace = false;
        }
        cutResult += result[i];
      }
    }
    return cutResult.toLowerCase();
  }
  var TYPE$5 = "type";
  var VALUE$6 = "value";
  var AttributeTypeAndValue = function (_PkiObject) {
    function AttributeTypeAndValue() {
      var _this60;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, AttributeTypeAndValue);
      _this60 = _callSuper(this, AttributeTypeAndValue);
      _this60.type = getParametersValue(parameters, TYPE$5, AttributeTypeAndValue.defaultValues(TYPE$5));
      _this60.value = getParametersValue(parameters, VALUE$6, AttributeTypeAndValue.defaultValues(VALUE$6));
      if (parameters.schema) {
        _this60.fromSchema(parameters.schema);
      }
      return _this60;
    }
    _inherits(AttributeTypeAndValue, _PkiObject);
    return _createClass(AttributeTypeAndValue, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, [TYPE$5, "typeValue"]);
        var asn1 = compareSchema(schema, schema, AttributeTypeAndValue.schema({
          names: {
            type: TYPE$5,
            value: "typeValue"
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.type = asn1.result.type.valueBlock.toString();
        this.value = asn1.result.typeValue;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: [new ObjectIdentifier({
            value: this.type
          }), this.value]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var _object = {
          type: this.type
        };
        if (Object.keys(this.value).length !== 0) {
          _object.value = this.value.toJSON();
        } else {
          _object.value = this.value;
        }
        return _object;
      }
    }, {
      key: "isEqual",
      value: function isEqual(compareTo) {
        var stringBlockNames = [Utf8String.blockName(), BmpString.blockName(), UniversalString.blockName(), NumericString.blockName(), PrintableString.blockName(), TeletexString.blockName(), VideotexString.blockName(), IA5String.blockName(), GraphicString.blockName(), VisibleString.blockName(), GeneralString.blockName(), CharacterString.blockName()];
        if (compareTo instanceof ArrayBuffer) {
          return BufferSourceConverter.isEqual(this.value.valueBeforeDecodeView, compareTo);
        }
        if (compareTo.constructor.blockName() === AttributeTypeAndValue.blockName()) {
          if (this.type !== compareTo.type) return false;
          var isStringPair = [false, false];
          var thisName = this.value.constructor.blockName();
          var _iterator16 = _createForOfIteratorHelper(stringBlockNames),
            _step16;
          try {
            for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
              var name = _step16.value;
              if (thisName === name) {
                isStringPair[0] = true;
              }
              if (compareTo.value.constructor.blockName() === name) {
                isStringPair[1] = true;
              }
            }
          } catch (err) {
            _iterator16.e(err);
          } finally {
            _iterator16.f();
          }
          if (isStringPair[0] !== isStringPair[1]) {
            return false;
          }
          var isString = isStringPair[0] && isStringPair[1];
          if (isString) {
            var value1 = stringPrep(this.value.valueBlock.value);
            var value2 = stringPrep(compareTo.value.valueBlock.value);
            if (value1.localeCompare(value2) !== 0) return false;
          } else {
            if (!BufferSourceConverter.isEqual(this.value.valueBeforeDecodeView, compareTo.value.valueBeforeDecodeView)) return false;
          }
          return true;
        }
        return false;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case TYPE$5:
            return EMPTY_STRING;
          case VALUE$6:
            return {};
          default:
            return _superPropGet(AttributeTypeAndValue, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new ObjectIdentifier({
            name: names.type || EMPTY_STRING
          }), new Any({
            name: names.value || EMPTY_STRING
          })]
        });
      }
    }]);
  }(PkiObject);
  AttributeTypeAndValue.CLASS_NAME = "AttributeTypeAndValue";
  var TYPE_AND_VALUES = "typesAndValues";
  var VALUE_BEFORE_DECODE = "valueBeforeDecode";
  var RDN = "RDN";
  var RelativeDistinguishedNames = function (_PkiObject2) {
    function RelativeDistinguishedNames() {
      var _this61;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, RelativeDistinguishedNames);
      _this61 = _callSuper(this, RelativeDistinguishedNames);
      _this61.typesAndValues = getParametersValue(parameters, TYPE_AND_VALUES, RelativeDistinguishedNames.defaultValues(TYPE_AND_VALUES));
      _this61.valueBeforeDecode = getParametersValue(parameters, VALUE_BEFORE_DECODE, RelativeDistinguishedNames.defaultValues(VALUE_BEFORE_DECODE));
      if (parameters.schema) {
        _this61.fromSchema(parameters.schema);
      }
      return _this61;
    }
    _inherits(RelativeDistinguishedNames, _PkiObject2);
    return _createClass(RelativeDistinguishedNames, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, [RDN, TYPE_AND_VALUES]);
        var asn1 = compareSchema(schema, schema, RelativeDistinguishedNames.schema({
          names: {
            blockName: RDN,
            repeatedSet: TYPE_AND_VALUES
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (TYPE_AND_VALUES in asn1.result) {
          this.typesAndValues = Array.from(asn1.result.typesAndValues, function (element) {
            return new AttributeTypeAndValue({
              schema: element
            });
          });
        }
        this.valueBeforeDecode = asn1.result.RDN.valueBeforeDecodeView.slice().buffer;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        if (this.valueBeforeDecode.byteLength === 0) {
          return new Sequence({
            value: [new Set({
              value: Array.from(this.typesAndValues, function (o) {
                return o.toSchema();
              })
            })]
          });
        }
        var asn1 = _fromBER(this.valueBeforeDecode);
        AsnError.assert(asn1, "RelativeDistinguishedNames");
        if (!(asn1.result instanceof Sequence)) {
          throw new Error("ASN.1 result should be SEQUENCE");
        }
        return asn1.result;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          typesAndValues: Array.from(this.typesAndValues, function (o) {
            return o.toJSON();
          })
        };
      }
    }, {
      key: "isEqual",
      value: function isEqual(compareTo) {
        if (compareTo instanceof RelativeDistinguishedNames) {
          if (this.typesAndValues.length !== compareTo.typesAndValues.length) return false;
          var _iterator17 = _createForOfIteratorHelper(this.typesAndValues.entries()),
            _step17;
          try {
            for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
              var _step17$value = _slicedToArray(_step17.value, 2),
                index = _step17$value[0],
                typeAndValue = _step17$value[1];
              if (typeAndValue.isEqual(compareTo.typesAndValues[index]) === false) return false;
            }
          } catch (err) {
            _iterator17.e(err);
          } finally {
            _iterator17.f();
          }
          return true;
        }
        if (compareTo instanceof ArrayBuffer) {
          return isEqualBuffer(this.valueBeforeDecode, compareTo);
        }
        return false;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case TYPE_AND_VALUES:
            return [];
          case VALUE_BEFORE_DECODE:
            return EMPTY_BUFFER;
          default:
            return _superPropGet(RelativeDistinguishedNames, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case TYPE_AND_VALUES:
            return memberValue.length === 0;
          case VALUE_BEFORE_DECODE:
            return memberValue.byteLength === 0;
          default:
            return _superPropGet(RelativeDistinguishedNames, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Repeated({
            name: names.repeatedSequence || EMPTY_STRING,
            value: new Set({
              value: [new Repeated({
                name: names.repeatedSet || EMPTY_STRING,
                value: AttributeTypeAndValue.schema(names.typeAndValue || {})
              })]
            })
          })]
        });
      }
    }]);
  }(PkiObject);
  RelativeDistinguishedNames.CLASS_NAME = "RelativeDistinguishedNames";
  var TYPE$4 = "type";
  var VALUE$5 = "value";
  function builtInStandardAttributes() {
    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var optional = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var names = getParametersValue(parameters, "names", {});
    return new Sequence({
      optional: optional,
      value: [new Constructed({
        optional: true,
        idBlock: {
          tagClass: 2,
          tagNumber: 1
        },
        name: names.country_name || EMPTY_STRING,
        value: [new Choice({
          value: [new NumericString(), new PrintableString()]
        })]
      }), new Constructed({
        optional: true,
        idBlock: {
          tagClass: 2,
          tagNumber: 2
        },
        name: names.administration_domain_name || EMPTY_STRING,
        value: [new Choice({
          value: [new NumericString(), new PrintableString()]
        })]
      }), new Primitive({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        name: names.network_address || EMPTY_STRING,
        isHexOnly: true
      }), new Primitive({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 1
        },
        name: names.terminal_identifier || EMPTY_STRING,
        isHexOnly: true
      }), new Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 2
        },
        name: names.private_domain_name || EMPTY_STRING,
        value: [new Choice({
          value: [new NumericString(), new PrintableString()]
        })]
      }), new Primitive({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 3
        },
        name: names.organization_name || EMPTY_STRING,
        isHexOnly: true
      }), new Primitive({
        optional: true,
        name: names.numeric_user_identifier || EMPTY_STRING,
        idBlock: {
          tagClass: 3,
          tagNumber: 4
        },
        isHexOnly: true
      }), new Constructed({
        optional: true,
        name: names.personal_name || EMPTY_STRING,
        idBlock: {
          tagClass: 3,
          tagNumber: 5
        },
        value: [new Primitive({
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          isHexOnly: true
        }), new Primitive({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          },
          isHexOnly: true
        }), new Primitive({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 2
          },
          isHexOnly: true
        }), new Primitive({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 3
          },
          isHexOnly: true
        })]
      }), new Constructed({
        optional: true,
        name: names.organizational_unit_names || EMPTY_STRING,
        idBlock: {
          tagClass: 3,
          tagNumber: 6
        },
        value: [new Repeated({
          value: new PrintableString()
        })]
      })]
    });
  }
  function builtInDomainDefinedAttributes() {
    var optional = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return new Sequence({
      optional: optional,
      value: [new PrintableString(), new PrintableString()]
    });
  }
  function extensionAttributes() {
    var optional = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return new Set({
      optional: optional,
      value: [new Primitive({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        isHexOnly: true
      }), new Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 1
        },
        value: [new Any()]
      })]
    });
  }
  var GeneralName = function (_PkiObject3) {
    function GeneralName() {
      var _this62;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, GeneralName);
      _this62 = _callSuper(this, GeneralName);
      _this62.type = getParametersValue(parameters, TYPE$4, GeneralName.defaultValues(TYPE$4));
      _this62.value = getParametersValue(parameters, VALUE$5, GeneralName.defaultValues(VALUE$5));
      if (parameters.schema) {
        _this62.fromSchema(parameters.schema);
      }
      return _this62;
    }
    _inherits(GeneralName, _PkiObject3);
    return _createClass(GeneralName, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, ["blockName", "otherName", "rfc822Name", "dNSName", "x400Address", "directoryName", "ediPartyName", "uniformResourceIdentifier", "iPAddress", "registeredID"]);
        var asn1 = compareSchema(schema, schema, GeneralName.schema({
          names: {
            blockName: "blockName",
            otherName: "otherName",
            rfc822Name: "rfc822Name",
            dNSName: "dNSName",
            x400Address: "x400Address",
            directoryName: {
              names: {
                blockName: "directoryName"
              }
            },
            ediPartyName: "ediPartyName",
            uniformResourceIdentifier: "uniformResourceIdentifier",
            iPAddress: "iPAddress",
            registeredID: "registeredID"
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.type = asn1.result.blockName.idBlock.tagNumber;
        switch (this.type) {
          case 0:
            this.value = asn1.result.blockName;
            break;
          case 1:
          case 2:
          case 6:
            {
              var value = asn1.result.blockName;
              value.idBlock.tagClass = 1;
              value.idBlock.tagNumber = 22;
              var valueBER = value.toBER(false);
              var asnValue = _fromBER(valueBER);
              AsnError.assert(asnValue, "GeneralName value");
              this.value = asnValue.result.valueBlock.value;
            }
            break;
          case 3:
            this.value = asn1.result.blockName;
            break;
          case 4:
            this.value = new RelativeDistinguishedNames({
              schema: asn1.result.directoryName
            });
            break;
          case 5:
            this.value = asn1.result.ediPartyName;
            break;
          case 7:
            this.value = new OctetString({
              valueHex: asn1.result.blockName.valueBlock.valueHex
            });
            break;
          case 8:
            {
              var _value6 = asn1.result.blockName;
              _value6.idBlock.tagClass = 1;
              _value6.idBlock.tagNumber = 6;
              var _valueBER = _value6.toBER(false);
              var _asnValue = _fromBER(_valueBER);
              AsnError.assert(_asnValue, "GeneralName registeredID");
              this.value = _asnValue.result.valueBlock.toString();
            }
            break;
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        switch (this.type) {
          case 0:
          case 3:
          case 5:
            return new Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: this.type
              },
              value: [this.value]
            });
          case 1:
          case 2:
          case 6:
            {
              var value = new IA5String({
                value: this.value
              });
              value.idBlock.tagClass = 3;
              value.idBlock.tagNumber = this.type;
              return value;
            }
          case 4:
            return new Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 4
              },
              value: [this.value.toSchema()]
            });
          case 7:
            {
              var _value7 = this.value;
              _value7.idBlock.tagClass = 3;
              _value7.idBlock.tagNumber = this.type;
              return _value7;
            }
          case 8:
            {
              var _value8 = new ObjectIdentifier({
                value: this.value
              });
              _value8.idBlock.tagClass = 3;
              _value8.idBlock.tagNumber = this.type;
              return _value8;
            }
          default:
            return GeneralName.schema();
        }
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var _object = {
          type: this.type,
          value: EMPTY_STRING
        };
        if (typeof this.value === "string") _object.value = this.value;else {
          try {
            _object.value = this.value.toJSON();
          } catch (ex) {}
        }
        return _object;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case TYPE$4:
            return 9;
          case VALUE$5:
            return {};
          default:
            return _superPropGet(GeneralName, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case TYPE$4:
            return memberValue === GeneralName.defaultValues(memberName);
          case VALUE$5:
            return Object.keys(memberValue).length === 0;
          default:
            return _superPropGet(GeneralName, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Choice({
          value: [new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            name: names.blockName || EMPTY_STRING,
            value: [new ObjectIdentifier(), new Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [new Any()]
            })]
          }), new Primitive({
            name: names.blockName || EMPTY_STRING,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            }
          }), new Primitive({
            name: names.blockName || EMPTY_STRING,
            idBlock: {
              tagClass: 3,
              tagNumber: 2
            }
          }), new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 3
            },
            name: names.blockName || EMPTY_STRING,
            value: [builtInStandardAttributes(names.builtInStandardAttributes || {}, false), builtInDomainDefinedAttributes(true), extensionAttributes(true)]
          }), new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 4
            },
            name: names.blockName || EMPTY_STRING,
            value: [RelativeDistinguishedNames.schema(names.directoryName || {})]
          }), new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 5
            },
            name: names.blockName || EMPTY_STRING,
            value: [new Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [new Choice({
                value: [new TeletexString(), new PrintableString(), new UniversalString(), new Utf8String(), new BmpString()]
              })]
            }), new Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: [new Choice({
                value: [new TeletexString(), new PrintableString(), new UniversalString(), new Utf8String(), new BmpString()]
              })]
            })]
          }), new Primitive({
            name: names.blockName || EMPTY_STRING,
            idBlock: {
              tagClass: 3,
              tagNumber: 6
            }
          }), new Primitive({
            name: names.blockName || EMPTY_STRING,
            idBlock: {
              tagClass: 3,
              tagNumber: 7
            }
          }), new Primitive({
            name: names.blockName || EMPTY_STRING,
            idBlock: {
              tagClass: 3,
              tagNumber: 8
            }
          })]
        });
      }
    }]);
  }(PkiObject);
  GeneralName.CLASS_NAME = "GeneralName";
  var ACCESS_METHOD = "accessMethod";
  var ACCESS_LOCATION = "accessLocation";
  var CLEAR_PROPS$1v = [ACCESS_METHOD, ACCESS_LOCATION];
  var AccessDescription = function (_PkiObject4) {
    function AccessDescription() {
      var _this63;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, AccessDescription);
      _this63 = _callSuper(this, AccessDescription);
      _this63.accessMethod = getParametersValue(parameters, ACCESS_METHOD, AccessDescription.defaultValues(ACCESS_METHOD));
      _this63.accessLocation = getParametersValue(parameters, ACCESS_LOCATION, AccessDescription.defaultValues(ACCESS_LOCATION));
      if (parameters.schema) {
        _this63.fromSchema(parameters.schema);
      }
      return _this63;
    }
    _inherits(AccessDescription, _PkiObject4);
    return _createClass(AccessDescription, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$1v);
        var asn1 = compareSchema(schema, schema, AccessDescription.schema({
          names: {
            accessMethod: ACCESS_METHOD,
            accessLocation: {
              names: {
                blockName: ACCESS_LOCATION
              }
            }
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.accessMethod = asn1.result.accessMethod.valueBlock.toString();
        this.accessLocation = new GeneralName({
          schema: asn1.result.accessLocation
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: [new ObjectIdentifier({
            value: this.accessMethod
          }), this.accessLocation.toSchema()]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          accessMethod: this.accessMethod,
          accessLocation: this.accessLocation.toJSON()
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case ACCESS_METHOD:
            return EMPTY_STRING;
          case ACCESS_LOCATION:
            return new GeneralName();
          default:
            return _superPropGet(AccessDescription, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new ObjectIdentifier({
            name: names.accessMethod || EMPTY_STRING
          }), GeneralName.schema(names.accessLocation || {})]
        });
      }
    }]);
  }(PkiObject);
  AccessDescription.CLASS_NAME = "AccessDescription";
  var SECONDS = "seconds";
  var MILLIS = "millis";
  var MICROS = "micros";
  var Accuracy = function (_PkiObject5) {
    function Accuracy() {
      var _this64;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Accuracy);
      _this64 = _callSuper(this, Accuracy);
      if (SECONDS in parameters) {
        _this64.seconds = getParametersValue(parameters, SECONDS, Accuracy.defaultValues(SECONDS));
      }
      if (MILLIS in parameters) {
        _this64.millis = getParametersValue(parameters, MILLIS, Accuracy.defaultValues(MILLIS));
      }
      if (MICROS in parameters) {
        _this64.micros = getParametersValue(parameters, MICROS, Accuracy.defaultValues(MICROS));
      }
      if (parameters.schema) {
        _this64.fromSchema(parameters.schema);
      }
      return _this64;
    }
    _inherits(Accuracy, _PkiObject5);
    return _createClass(Accuracy, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, [SECONDS, MILLIS, MICROS]);
        var asn1 = compareSchema(schema, schema, Accuracy.schema({
          names: {
            seconds: SECONDS,
            millis: MILLIS,
            micros: MICROS
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if ("seconds" in asn1.result) {
          this.seconds = asn1.result.seconds.valueBlock.valueDec;
        }
        if ("millis" in asn1.result) {
          var intMillis = new Integer({
            valueHex: asn1.result.millis.valueBlock.valueHex
          });
          this.millis = intMillis.valueBlock.valueDec;
        }
        if ("micros" in asn1.result) {
          var intMicros = new Integer({
            valueHex: asn1.result.micros.valueBlock.valueHex
          });
          this.micros = intMicros.valueBlock.valueDec;
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        if (this.seconds !== undefined) outputArray.push(new Integer({
          value: this.seconds
        }));
        if (this.millis !== undefined) {
          var intMillis = new Integer({
            value: this.millis
          });
          outputArray.push(new Primitive({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            valueHex: intMillis.valueBlock.valueHexView
          }));
        }
        if (this.micros !== undefined) {
          var intMicros = new Integer({
            value: this.micros
          });
          outputArray.push(new Primitive({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            valueHex: intMicros.valueBlock.valueHexView
          }));
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var _object = {};
        if (this.seconds !== undefined) _object.seconds = this.seconds;
        if (this.millis !== undefined) _object.millis = this.millis;
        if (this.micros !== undefined) _object.micros = this.micros;
        return _object;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case SECONDS:
          case MILLIS:
          case MICROS:
            return 0;
          default:
            return _superPropGet(Accuracy, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case SECONDS:
          case MILLIS:
          case MICROS:
            return memberValue === Accuracy.defaultValues(memberName);
          default:
            return _superPropGet(Accuracy, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          optional: true,
          value: [new Integer({
            optional: true,
            name: names.seconds || EMPTY_STRING
          }), new Primitive({
            name: names.millis || EMPTY_STRING,
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            }
          }), new Primitive({
            name: names.micros || EMPTY_STRING,
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            }
          })]
        });
      }
    }]);
  }(PkiObject);
  Accuracy.CLASS_NAME = "Accuracy";
  var ALGORITHM_ID = "algorithmId";
  var ALGORITHM_PARAMS = "algorithmParams";
  var ALGORITHM$2 = "algorithm";
  var PARAMS = "params";
  var CLEAR_PROPS$1u = [ALGORITHM$2, PARAMS];
  var AlgorithmIdentifier = function (_PkiObject6) {
    function AlgorithmIdentifier() {
      var _this65;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, AlgorithmIdentifier);
      _this65 = _callSuper(this, AlgorithmIdentifier);
      _this65.algorithmId = getParametersValue(parameters, ALGORITHM_ID, AlgorithmIdentifier.defaultValues(ALGORITHM_ID));
      if (ALGORITHM_PARAMS in parameters) {
        _this65.algorithmParams = getParametersValue(parameters, ALGORITHM_PARAMS, AlgorithmIdentifier.defaultValues(ALGORITHM_PARAMS));
      }
      if (parameters.schema) {
        _this65.fromSchema(parameters.schema);
      }
      return _this65;
    }
    _inherits(AlgorithmIdentifier, _PkiObject6);
    return _createClass(AlgorithmIdentifier, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$1u);
        var asn1 = compareSchema(schema, schema, AlgorithmIdentifier.schema({
          names: {
            algorithmIdentifier: ALGORITHM$2,
            algorithmParams: PARAMS
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.algorithmId = asn1.result.algorithm.valueBlock.toString();
        if (PARAMS in asn1.result) {
          this.algorithmParams = asn1.result.params;
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        outputArray.push(new ObjectIdentifier({
          value: this.algorithmId
        }));
        if (this.algorithmParams && !(this.algorithmParams instanceof Any)) {
          outputArray.push(this.algorithmParams);
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var object = {
          algorithmId: this.algorithmId
        };
        if (this.algorithmParams && !(this.algorithmParams instanceof Any)) {
          object.algorithmParams = this.algorithmParams.toJSON();
        }
        return object;
      }
    }, {
      key: "isEqual",
      value: function isEqual(algorithmIdentifier) {
        if (!(algorithmIdentifier instanceof AlgorithmIdentifier)) {
          return false;
        }
        if (this.algorithmId !== algorithmIdentifier.algorithmId) {
          return false;
        }
        if (this.algorithmParams) {
          if (algorithmIdentifier.algorithmParams) {
            return JSON.stringify(this.algorithmParams) === JSON.stringify(algorithmIdentifier.algorithmParams);
          }
          return false;
        }
        if (algorithmIdentifier.algorithmParams) {
          return false;
        }
        return true;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case ALGORITHM_ID:
            return EMPTY_STRING;
          case ALGORITHM_PARAMS:
            return new Any();
          default:
            return _superPropGet(AlgorithmIdentifier, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case ALGORITHM_ID:
            return memberValue === EMPTY_STRING;
          case ALGORITHM_PARAMS:
            return memberValue instanceof Any;
          default:
            return _superPropGet(AlgorithmIdentifier, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          optional: names.optional || false,
          value: [new ObjectIdentifier({
            name: names.algorithmIdentifier || EMPTY_STRING
          }), new Any({
            name: names.algorithmParams || EMPTY_STRING,
            optional: true
          })]
        });
      }
    }]);
  }(PkiObject);
  AlgorithmIdentifier.CLASS_NAME = "AlgorithmIdentifier";
  var ALT_NAMES = "altNames";
  var CLEAR_PROPS$1t = [ALT_NAMES];
  var AltName = function (_PkiObject7) {
    function AltName() {
      var _this66;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, AltName);
      _this66 = _callSuper(this, AltName);
      _this66.altNames = getParametersValue(parameters, ALT_NAMES, AltName.defaultValues(ALT_NAMES));
      if (parameters.schema) {
        _this66.fromSchema(parameters.schema);
      }
      return _this66;
    }
    _inherits(AltName, _PkiObject7);
    return _createClass(AltName, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$1t);
        var asn1 = compareSchema(schema, schema, AltName.schema({
          names: {
            altNames: ALT_NAMES
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (ALT_NAMES in asn1.result) {
          this.altNames = Array.from(asn1.result.altNames, function (element) {
            return new GeneralName({
              schema: element
            });
          });
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: Array.from(this.altNames, function (o) {
            return o.toSchema();
          })
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          altNames: Array.from(this.altNames, function (o) {
            return o.toJSON();
          })
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case ALT_NAMES:
            return [];
          default:
            return _superPropGet(AltName, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Repeated({
            name: names.altNames || EMPTY_STRING,
            value: GeneralName.schema()
          })]
        });
      }
    }]);
  }(PkiObject);
  AltName.CLASS_NAME = "AltName";
  var TYPE$3 = "type";
  var VALUES$1 = "values";
  var CLEAR_PROPS$1s = [TYPE$3, VALUES$1];
  var Attribute = function (_PkiObject8) {
    function Attribute() {
      var _this67;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Attribute);
      _this67 = _callSuper(this, Attribute);
      _this67.type = getParametersValue(parameters, TYPE$3, Attribute.defaultValues(TYPE$3));
      _this67.values = getParametersValue(parameters, VALUES$1, Attribute.defaultValues(VALUES$1));
      if (parameters.schema) {
        _this67.fromSchema(parameters.schema);
      }
      return _this67;
    }
    _inherits(Attribute, _PkiObject8);
    return _createClass(Attribute, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$1s);
        var asn1 = compareSchema(schema, schema, Attribute.schema({
          names: {
            type: TYPE$3,
            values: VALUES$1
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.type = asn1.result.type.valueBlock.toString();
        this.values = asn1.result.values;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: [new ObjectIdentifier({
            value: this.type
          }), new Set({
            value: this.values
          })]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          type: this.type,
          values: Array.from(this.values, function (o) {
            return o.toJSON();
          })
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case TYPE$3:
            return EMPTY_STRING;
          case VALUES$1:
            return [];
          default:
            return _superPropGet(Attribute, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case TYPE$3:
            return memberValue === EMPTY_STRING;
          case VALUES$1:
            return memberValue.length === 0;
          default:
            return _superPropGet(Attribute, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new ObjectIdentifier({
            name: names.type || EMPTY_STRING
          }), new Set({
            name: names.setName || EMPTY_STRING,
            value: [new Repeated({
              name: names.values || EMPTY_STRING,
              value: new Any()
            })]
          })]
        });
      }
    }]);
  }(PkiObject);
  Attribute.CLASS_NAME = "Attribute";
  var NOT_BEFORE_TIME = "notBeforeTime";
  var NOT_AFTER_TIME = "notAfterTime";
  var CLEAR_PROPS$1r = [NOT_BEFORE_TIME, NOT_AFTER_TIME];
  var AttCertValidityPeriod = function (_PkiObject9) {
    function AttCertValidityPeriod() {
      var _this68;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, AttCertValidityPeriod);
      _this68 = _callSuper(this, AttCertValidityPeriod);
      _this68.notBeforeTime = getParametersValue(parameters, NOT_BEFORE_TIME, AttCertValidityPeriod.defaultValues(NOT_BEFORE_TIME));
      _this68.notAfterTime = getParametersValue(parameters, NOT_AFTER_TIME, AttCertValidityPeriod.defaultValues(NOT_AFTER_TIME));
      if (parameters.schema) {
        _this68.fromSchema(parameters.schema);
      }
      return _this68;
    }
    _inherits(AttCertValidityPeriod, _PkiObject9);
    return _createClass(AttCertValidityPeriod, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$1r);
        var asn1 = compareSchema(schema, schema, AttCertValidityPeriod.schema({
          names: {
            notBeforeTime: NOT_BEFORE_TIME,
            notAfterTime: NOT_AFTER_TIME
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.notBeforeTime = asn1.result.notBeforeTime.toDate();
        this.notAfterTime = asn1.result.notAfterTime.toDate();
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: [new GeneralizedTime({
            valueDate: this.notBeforeTime
          }), new GeneralizedTime({
            valueDate: this.notAfterTime
          })]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          notBeforeTime: this.notBeforeTime,
          notAfterTime: this.notAfterTime
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case NOT_BEFORE_TIME:
          case NOT_AFTER_TIME:
            return new Date(0, 0, 0);
          default:
            return _superPropGet(AttCertValidityPeriod, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new GeneralizedTime({
            name: names.notBeforeTime || EMPTY_STRING
          }), new GeneralizedTime({
            name: names.notAfterTime || EMPTY_STRING
          })]
        });
      }
    }]);
  }(PkiObject);
  AttCertValidityPeriod.CLASS_NAME = "AttCertValidityPeriod";
  var NAMES = "names";
  var GENERAL_NAMES = "generalNames";
  var GeneralNames = function (_PkiObject10) {
    function GeneralNames() {
      var _this69;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, GeneralNames);
      _this69 = _callSuper(this, GeneralNames);
      _this69.names = getParametersValue(parameters, NAMES, GeneralNames.defaultValues(NAMES));
      if (parameters.schema) {
        _this69.fromSchema(parameters.schema);
      }
      return _this69;
    }
    _inherits(GeneralNames, _PkiObject10);
    return _createClass(GeneralNames, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, [NAMES, GENERAL_NAMES]);
        var asn1 = compareSchema(schema, schema, GeneralNames.schema({
          names: {
            blockName: NAMES,
            generalNames: GENERAL_NAMES
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.names = Array.from(asn1.result.generalNames, function (element) {
          return new GeneralName({
            schema: element
          });
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: Array.from(this.names, function (o) {
            return o.toSchema();
          })
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          names: Array.from(this.names, function (o) {
            return o.toJSON();
          })
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case "names":
            return [];
          default:
            return _superPropGet(GeneralNames, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var optional = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var names = getParametersValue(parameters, NAMES, {});
        return new Sequence({
          optional: optional,
          name: names.blockName || EMPTY_STRING,
          value: [new Repeated({
            name: names.generalNames || EMPTY_STRING,
            value: GeneralName.schema()
          })]
        });
      }
    }]);
  }(PkiObject);
  GeneralNames.CLASS_NAME = "GeneralNames";
  var id_SubjectDirectoryAttributes = "2.5.29.9";
  var id_SubjectKeyIdentifier = "2.5.29.14";
  var id_KeyUsage = "2.5.29.15";
  var id_PrivateKeyUsagePeriod = "2.5.29.16";
  var id_SubjectAltName = "2.5.29.17";
  var id_IssuerAltName = "2.5.29.18";
  var id_BasicConstraints = "2.5.29.19";
  var id_CRLNumber = "2.5.29.20";
  var id_BaseCRLNumber = "2.5.29.27";
  var id_CRLReason = "2.5.29.21";
  var id_InvalidityDate = "2.5.29.24";
  var id_IssuingDistributionPoint = "2.5.29.28";
  var id_CertificateIssuer = "2.5.29.29";
  var id_NameConstraints = "2.5.29.30";
  var id_CRLDistributionPoints = "2.5.29.31";
  var id_FreshestCRL = "2.5.29.46";
  var id_CertificatePolicies = "2.5.29.32";
  var id_AnyPolicy = "2.5.29.32.0";
  var id_MicrosoftAppPolicies = "1.3.6.1.4.1.311.21.10";
  var id_PolicyMappings = "2.5.29.33";
  var id_AuthorityKeyIdentifier = "2.5.29.35";
  var id_PolicyConstraints = "2.5.29.36";
  var id_ExtKeyUsage = "2.5.29.37";
  var id_InhibitAnyPolicy = "2.5.29.54";
  var id_AuthorityInfoAccess = "1.3.6.1.5.5.7.1.1";
  var id_SubjectInfoAccess = "1.3.6.1.5.5.7.1.11";
  var id_SignedCertificateTimestampList = "1.3.6.1.4.1.11129.2.4.2";
  var id_MicrosoftCertTemplateV2 = "1.3.6.1.4.1.311.21.7";
  var id_MicrosoftCaVersion = "1.3.6.1.4.1.311.21.1";
  var id_QCStatements = "1.3.6.1.5.5.7.1.3";
  var id_ContentType_Data = "1.2.840.113549.1.7.1";
  var id_ContentType_SignedData = "1.2.840.113549.1.7.2";
  var id_ContentType_EnvelopedData = "1.2.840.113549.1.7.3";
  var id_ContentType_EncryptedData = "1.2.840.113549.1.7.6";
  var id_eContentType_TSTInfo = "1.2.840.113549.1.9.16.1.4";
  var id_CertBag_X509Certificate = "1.2.840.113549.1.9.22.1";
  var id_CertBag_SDSICertificate = "1.2.840.113549.1.9.22.2";
  var id_CertBag_AttributeCertificate = "1.2.840.113549.1.9.22.3";
  var id_CRLBag_X509CRL = "1.2.840.113549.1.9.23.1";
  var id_pkix = "1.3.6.1.5.5.7";
  var id_ad = "".concat(id_pkix, ".48");
  var id_PKIX_OCSP_Basic = "".concat(id_ad, ".1.1");
  var KEY_IDENTIFIER$1 = "keyIdentifier";
  var AUTHORITY_CERT_ISSUER = "authorityCertIssuer";
  var AUTHORITY_CERT_SERIAL_NUMBER = "authorityCertSerialNumber";
  var CLEAR_PROPS$1q = [KEY_IDENTIFIER$1, AUTHORITY_CERT_ISSUER, AUTHORITY_CERT_SERIAL_NUMBER];
  var AuthorityKeyIdentifier = function (_PkiObject11) {
    function AuthorityKeyIdentifier() {
      var _this70;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, AuthorityKeyIdentifier);
      _this70 = _callSuper(this, AuthorityKeyIdentifier);
      if (KEY_IDENTIFIER$1 in parameters) {
        _this70.keyIdentifier = getParametersValue(parameters, KEY_IDENTIFIER$1, AuthorityKeyIdentifier.defaultValues(KEY_IDENTIFIER$1));
      }
      if (AUTHORITY_CERT_ISSUER in parameters) {
        _this70.authorityCertIssuer = getParametersValue(parameters, AUTHORITY_CERT_ISSUER, AuthorityKeyIdentifier.defaultValues(AUTHORITY_CERT_ISSUER));
      }
      if (AUTHORITY_CERT_SERIAL_NUMBER in parameters) {
        _this70.authorityCertSerialNumber = getParametersValue(parameters, AUTHORITY_CERT_SERIAL_NUMBER, AuthorityKeyIdentifier.defaultValues(AUTHORITY_CERT_SERIAL_NUMBER));
      }
      if (parameters.schema) {
        _this70.fromSchema(parameters.schema);
      }
      return _this70;
    }
    _inherits(AuthorityKeyIdentifier, _PkiObject11);
    return _createClass(AuthorityKeyIdentifier, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$1q);
        var asn1 = compareSchema(schema, schema, AuthorityKeyIdentifier.schema({
          names: {
            keyIdentifier: KEY_IDENTIFIER$1,
            authorityCertIssuer: AUTHORITY_CERT_ISSUER,
            authorityCertSerialNumber: AUTHORITY_CERT_SERIAL_NUMBER
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (KEY_IDENTIFIER$1 in asn1.result) this.keyIdentifier = new OctetString({
          valueHex: asn1.result.keyIdentifier.valueBlock.valueHex
        });
        if (AUTHORITY_CERT_ISSUER in asn1.result) this.authorityCertIssuer = Array.from(asn1.result.authorityCertIssuer, function (o) {
          return new GeneralName({
            schema: o
          });
        });
        if (AUTHORITY_CERT_SERIAL_NUMBER in asn1.result) this.authorityCertSerialNumber = new Integer({
          valueHex: asn1.result.authorityCertSerialNumber.valueBlock.valueHex
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        if (this.keyIdentifier) {
          outputArray.push(new Primitive({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            valueHex: this.keyIdentifier.valueBlock.valueHexView
          }));
        }
        if (this.authorityCertIssuer) {
          outputArray.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: Array.from(this.authorityCertIssuer, function (o) {
              return o.toSchema();
            })
          }));
        }
        if (this.authorityCertSerialNumber) {
          outputArray.push(new Primitive({
            idBlock: {
              tagClass: 3,
              tagNumber: 2
            },
            valueHex: this.authorityCertSerialNumber.valueBlock.valueHexView
          }));
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var object = {};
        if (this.keyIdentifier) {
          object.keyIdentifier = this.keyIdentifier.toJSON();
        }
        if (this.authorityCertIssuer) {
          object.authorityCertIssuer = Array.from(this.authorityCertIssuer, function (o) {
            return o.toJSON();
          });
        }
        if (this.authorityCertSerialNumber) {
          object.authorityCertSerialNumber = this.authorityCertSerialNumber.toJSON();
        }
        return object;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case KEY_IDENTIFIER$1:
            return new OctetString();
          case AUTHORITY_CERT_ISSUER:
            return [];
          case AUTHORITY_CERT_SERIAL_NUMBER:
            return new Integer();
          default:
            return _superPropGet(AuthorityKeyIdentifier, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Primitive({
            name: names.keyIdentifier || EMPTY_STRING,
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            }
          }), new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: [new Repeated({
              name: names.authorityCertIssuer || EMPTY_STRING,
              value: GeneralName.schema()
            })]
          }), new Primitive({
            name: names.authorityCertSerialNumber || EMPTY_STRING,
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 2
            }
          })]
        });
      }
    }]);
  }(PkiObject);
  AuthorityKeyIdentifier.CLASS_NAME = "AuthorityKeyIdentifier";
  var PATH_LENGTH_CONSTRAINT = "pathLenConstraint";
  var CA = "cA";
  var BasicConstraints = function (_PkiObject12) {
    function BasicConstraints() {
      var _this71;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, BasicConstraints);
      _this71 = _callSuper(this, BasicConstraints);
      _this71.cA = getParametersValue(parameters, CA, false);
      if (PATH_LENGTH_CONSTRAINT in parameters) {
        _this71.pathLenConstraint = getParametersValue(parameters, PATH_LENGTH_CONSTRAINT, 0);
      }
      if (parameters.schema) {
        _this71.fromSchema(parameters.schema);
      }
      return _this71;
    }
    _inherits(BasicConstraints, _PkiObject12);
    return _createClass(BasicConstraints, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, [CA, PATH_LENGTH_CONSTRAINT]);
        var asn1 = compareSchema(schema, schema, BasicConstraints.schema({
          names: {
            cA: CA,
            pathLenConstraint: PATH_LENGTH_CONSTRAINT
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (CA in asn1.result) {
          this.cA = asn1.result.cA.valueBlock.value;
        }
        if (PATH_LENGTH_CONSTRAINT in asn1.result) {
          if (asn1.result.pathLenConstraint.valueBlock.isHexOnly) {
            this.pathLenConstraint = asn1.result.pathLenConstraint;
          } else {
            this.pathLenConstraint = asn1.result.pathLenConstraint.valueBlock.valueDec;
          }
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        if (this.cA !== BasicConstraints.defaultValues(CA)) outputArray.push(new Boolean$1({
          value: this.cA
        }));
        if (PATH_LENGTH_CONSTRAINT in this) {
          if (this.pathLenConstraint instanceof Integer) {
            outputArray.push(this.pathLenConstraint);
          } else {
            outputArray.push(new Integer({
              value: this.pathLenConstraint
            }));
          }
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var object = {};
        if (this.cA !== BasicConstraints.defaultValues(CA)) {
          object.cA = this.cA;
        }
        if (PATH_LENGTH_CONSTRAINT in this) {
          if (this.pathLenConstraint instanceof Integer) {
            object.pathLenConstraint = this.pathLenConstraint.toJSON();
          } else {
            object.pathLenConstraint = this.pathLenConstraint;
          }
        }
        return object;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case CA:
            return false;
          default:
            return _superPropGet(BasicConstraints, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Boolean$1({
            optional: true,
            name: names.cA || EMPTY_STRING
          }), new Integer({
            optional: true,
            name: names.pathLenConstraint || EMPTY_STRING
          })]
        });
      }
    }]);
  }(PkiObject);
  BasicConstraints.CLASS_NAME = "BasicConstraints";
  var CERTIFICATE_INDEX = "certificateIndex";
  var KEY_INDEX = "keyIndex";
  var CAVersion = function (_PkiObject13) {
    function CAVersion() {
      var _this72;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, CAVersion);
      _this72 = _callSuper(this, CAVersion);
      _this72.certificateIndex = getParametersValue(parameters, CERTIFICATE_INDEX, CAVersion.defaultValues(CERTIFICATE_INDEX));
      _this72.keyIndex = getParametersValue(parameters, KEY_INDEX, CAVersion.defaultValues(KEY_INDEX));
      if (parameters.schema) {
        _this72.fromSchema(parameters.schema);
      }
      return _this72;
    }
    _inherits(CAVersion, _PkiObject13);
    return _createClass(CAVersion, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        if (schema.constructor.blockName() !== Integer.blockName()) {
          throw new Error("Object's schema was not verified against input data for CAVersion");
        }
        var value = schema.valueBlock.valueHex.slice(0);
        var valueView = new Uint8Array(value);
        switch (true) {
          case value.byteLength < 4:
            {
              var tempValue = new ArrayBuffer(4);
              var tempValueView = new Uint8Array(tempValue);
              tempValueView.set(valueView, 4 - value.byteLength);
              value = tempValue.slice(0);
            }
            break;
          case value.byteLength > 4:
            {
              var _tempValue = new ArrayBuffer(4);
              var _tempValueView = new Uint8Array(_tempValue);
              _tempValueView.set(valueView.slice(0, 4));
              value = _tempValue.slice(0);
            }
            break;
        }
        var keyIndexBuffer = value.slice(0, 2);
        var keyIndexView8 = new Uint8Array(keyIndexBuffer);
        var temp = keyIndexView8[0];
        keyIndexView8[0] = keyIndexView8[1];
        keyIndexView8[1] = temp;
        var keyIndexView16 = new Uint16Array(keyIndexBuffer);
        this.keyIndex = keyIndexView16[0];
        var certificateIndexBuffer = value.slice(2);
        var certificateIndexView8 = new Uint8Array(certificateIndexBuffer);
        temp = certificateIndexView8[0];
        certificateIndexView8[0] = certificateIndexView8[1];
        certificateIndexView8[1] = temp;
        var certificateIndexView16 = new Uint16Array(certificateIndexBuffer);
        this.certificateIndex = certificateIndexView16[0];
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var certificateIndexBuffer = new ArrayBuffer(2);
        var certificateIndexView = new Uint16Array(certificateIndexBuffer);
        certificateIndexView[0] = this.certificateIndex;
        var certificateIndexView8 = new Uint8Array(certificateIndexBuffer);
        var temp = certificateIndexView8[0];
        certificateIndexView8[0] = certificateIndexView8[1];
        certificateIndexView8[1] = temp;
        var keyIndexBuffer = new ArrayBuffer(2);
        var keyIndexView = new Uint16Array(keyIndexBuffer);
        keyIndexView[0] = this.keyIndex;
        var keyIndexView8 = new Uint8Array(keyIndexBuffer);
        temp = keyIndexView8[0];
        keyIndexView8[0] = keyIndexView8[1];
        keyIndexView8[1] = temp;
        return new Integer({
          valueHex: utilConcatBuf(keyIndexBuffer, certificateIndexBuffer)
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          certificateIndex: this.certificateIndex,
          keyIndex: this.keyIndex
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case CERTIFICATE_INDEX:
          case KEY_INDEX:
            return 0;
          default:
            return _superPropGet(CAVersion, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        return new Integer();
      }
    }]);
  }(PkiObject);
  CAVersion.CLASS_NAME = "CAVersion";
  var POLICY_QUALIFIER_ID = "policyQualifierId";
  var QUALIFIER = "qualifier";
  var CLEAR_PROPS$1p = [POLICY_QUALIFIER_ID, QUALIFIER];
  var PolicyQualifierInfo = function (_PkiObject14) {
    function PolicyQualifierInfo() {
      var _this73;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, PolicyQualifierInfo);
      _this73 = _callSuper(this, PolicyQualifierInfo);
      _this73.policyQualifierId = getParametersValue(parameters, POLICY_QUALIFIER_ID, PolicyQualifierInfo.defaultValues(POLICY_QUALIFIER_ID));
      _this73.qualifier = getParametersValue(parameters, QUALIFIER, PolicyQualifierInfo.defaultValues(QUALIFIER));
      if (parameters.schema) {
        _this73.fromSchema(parameters.schema);
      }
      return _this73;
    }
    _inherits(PolicyQualifierInfo, _PkiObject14);
    return _createClass(PolicyQualifierInfo, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$1p);
        var asn1 = compareSchema(schema, schema, PolicyQualifierInfo.schema({
          names: {
            policyQualifierId: POLICY_QUALIFIER_ID,
            qualifier: QUALIFIER
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.policyQualifierId = asn1.result.policyQualifierId.valueBlock.toString();
        this.qualifier = asn1.result.qualifier;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: [new ObjectIdentifier({
            value: this.policyQualifierId
          }), this.qualifier]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          policyQualifierId: this.policyQualifierId,
          qualifier: this.qualifier.toJSON()
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case POLICY_QUALIFIER_ID:
            return EMPTY_STRING;
          case QUALIFIER:
            return new Any();
          default:
            return _superPropGet(PolicyQualifierInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new ObjectIdentifier({
            name: names.policyQualifierId || EMPTY_STRING
          }), new Any({
            name: names.qualifier || EMPTY_STRING
          })]
        });
      }
    }]);
  }(PkiObject);
  PolicyQualifierInfo.CLASS_NAME = "PolicyQualifierInfo";
  var POLICY_IDENTIFIER = "policyIdentifier";
  var POLICY_QUALIFIERS = "policyQualifiers";
  var CLEAR_PROPS$1o = [POLICY_IDENTIFIER, POLICY_QUALIFIERS];
  var PolicyInformation = function (_PkiObject15) {
    function PolicyInformation() {
      var _this74;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, PolicyInformation);
      _this74 = _callSuper(this, PolicyInformation);
      _this74.policyIdentifier = getParametersValue(parameters, POLICY_IDENTIFIER, PolicyInformation.defaultValues(POLICY_IDENTIFIER));
      if (POLICY_QUALIFIERS in parameters) {
        _this74.policyQualifiers = getParametersValue(parameters, POLICY_QUALIFIERS, PolicyInformation.defaultValues(POLICY_QUALIFIERS));
      }
      if (parameters.schema) {
        _this74.fromSchema(parameters.schema);
      }
      return _this74;
    }
    _inherits(PolicyInformation, _PkiObject15);
    return _createClass(PolicyInformation, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$1o);
        var asn1 = compareSchema(schema, schema, PolicyInformation.schema({
          names: {
            policyIdentifier: POLICY_IDENTIFIER,
            policyQualifiers: POLICY_QUALIFIERS
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.policyIdentifier = asn1.result.policyIdentifier.valueBlock.toString();
        if (POLICY_QUALIFIERS in asn1.result) {
          this.policyQualifiers = Array.from(asn1.result.policyQualifiers, function (element) {
            return new PolicyQualifierInfo({
              schema: element
            });
          });
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        outputArray.push(new ObjectIdentifier({
          value: this.policyIdentifier
        }));
        if (this.policyQualifiers) {
          outputArray.push(new Sequence({
            value: Array.from(this.policyQualifiers, function (o) {
              return o.toSchema();
            })
          }));
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          policyIdentifier: this.policyIdentifier
        };
        if (this.policyQualifiers) res.policyQualifiers = Array.from(this.policyQualifiers, function (o) {
          return o.toJSON();
        });
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case POLICY_IDENTIFIER:
            return EMPTY_STRING;
          case POLICY_QUALIFIERS:
            return [];
          default:
            return _superPropGet(PolicyInformation, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new ObjectIdentifier({
            name: names.policyIdentifier || EMPTY_STRING
          }), new Sequence({
            optional: true,
            value: [new Repeated({
              name: names.policyQualifiers || EMPTY_STRING,
              value: PolicyQualifierInfo.schema()
            })]
          })]
        });
      }
    }]);
  }(PkiObject);
  PolicyInformation.CLASS_NAME = "PolicyInformation";
  var CERTIFICATE_POLICIES = "certificatePolicies";
  var CLEAR_PROPS$1n = [CERTIFICATE_POLICIES];
  var CertificatePolicies = function (_PkiObject16) {
    function CertificatePolicies() {
      var _this75;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, CertificatePolicies);
      _this75 = _callSuper(this, CertificatePolicies);
      _this75.certificatePolicies = getParametersValue(parameters, CERTIFICATE_POLICIES, CertificatePolicies.defaultValues(CERTIFICATE_POLICIES));
      if (parameters.schema) {
        _this75.fromSchema(parameters.schema);
      }
      return _this75;
    }
    _inherits(CertificatePolicies, _PkiObject16);
    return _createClass(CertificatePolicies, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$1n);
        var asn1 = compareSchema(schema, schema, CertificatePolicies.schema({
          names: {
            certificatePolicies: CERTIFICATE_POLICIES
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.certificatePolicies = Array.from(asn1.result.certificatePolicies, function (element) {
          return new PolicyInformation({
            schema: element
          });
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: Array.from(this.certificatePolicies, function (o) {
            return o.toSchema();
          })
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          certificatePolicies: Array.from(this.certificatePolicies, function (o) {
            return o.toJSON();
          })
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case CERTIFICATE_POLICIES:
            return [];
          default:
            return _superPropGet(CertificatePolicies, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Repeated({
            name: names.certificatePolicies || EMPTY_STRING,
            value: PolicyInformation.schema()
          })]
        });
      }
    }]);
  }(PkiObject);
  CertificatePolicies.CLASS_NAME = "CertificatePolicies";
  var TEMPLATE_ID = "templateID";
  var TEMPLATE_MAJOR_VERSION = "templateMajorVersion";
  var TEMPLATE_MINOR_VERSION = "templateMinorVersion";
  var CLEAR_PROPS$1m = [TEMPLATE_ID, TEMPLATE_MAJOR_VERSION, TEMPLATE_MINOR_VERSION];
  var CertificateTemplate = function (_PkiObject17) {
    function CertificateTemplate() {
      var _this76;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, CertificateTemplate);
      _this76 = _callSuper(this, CertificateTemplate);
      _this76.templateID = getParametersValue(parameters, TEMPLATE_ID, CertificateTemplate.defaultValues(TEMPLATE_ID));
      if (TEMPLATE_MAJOR_VERSION in parameters) {
        _this76.templateMajorVersion = getParametersValue(parameters, TEMPLATE_MAJOR_VERSION, CertificateTemplate.defaultValues(TEMPLATE_MAJOR_VERSION));
      }
      if (TEMPLATE_MINOR_VERSION in parameters) {
        _this76.templateMinorVersion = getParametersValue(parameters, TEMPLATE_MINOR_VERSION, CertificateTemplate.defaultValues(TEMPLATE_MINOR_VERSION));
      }
      if (parameters.schema) {
        _this76.fromSchema(parameters.schema);
      }
      return _this76;
    }
    _inherits(CertificateTemplate, _PkiObject17);
    return _createClass(CertificateTemplate, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$1m);
        var asn1 = compareSchema(schema, schema, CertificateTemplate.schema({
          names: {
            templateID: TEMPLATE_ID,
            templateMajorVersion: TEMPLATE_MAJOR_VERSION,
            templateMinorVersion: TEMPLATE_MINOR_VERSION
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.templateID = asn1.result.templateID.valueBlock.toString();
        if (TEMPLATE_MAJOR_VERSION in asn1.result) {
          this.templateMajorVersion = asn1.result.templateMajorVersion.valueBlock.valueDec;
        }
        if (TEMPLATE_MINOR_VERSION in asn1.result) {
          this.templateMinorVersion = asn1.result.templateMinorVersion.valueBlock.valueDec;
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        outputArray.push(new ObjectIdentifier({
          value: this.templateID
        }));
        if (TEMPLATE_MAJOR_VERSION in this) {
          outputArray.push(new Integer({
            value: this.templateMajorVersion
          }));
        }
        if (TEMPLATE_MINOR_VERSION in this) {
          outputArray.push(new Integer({
            value: this.templateMinorVersion
          }));
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          templateID: this.templateID
        };
        if (TEMPLATE_MAJOR_VERSION in this) res.templateMajorVersion = this.templateMajorVersion;
        if (TEMPLATE_MINOR_VERSION in this) res.templateMinorVersion = this.templateMinorVersion;
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case TEMPLATE_ID:
            return EMPTY_STRING;
          case TEMPLATE_MAJOR_VERSION:
          case TEMPLATE_MINOR_VERSION:
            return 0;
          default:
            return _superPropGet(CertificateTemplate, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new ObjectIdentifier({
            name: names.templateID || EMPTY_STRING
          }), new Integer({
            name: names.templateMajorVersion || EMPTY_STRING,
            optional: true
          }), new Integer({
            name: names.templateMinorVersion || EMPTY_STRING,
            optional: true
          })]
        });
      }
    }]);
  }(PkiObject);
  var DISTRIBUTION_POINT$1 = "distributionPoint";
  var DISTRIBUTION_POINT_NAMES$1 = "distributionPointNames";
  var REASONS = "reasons";
  var CRL_ISSUER = "cRLIssuer";
  var CRL_ISSUER_NAMES = "cRLIssuerNames";
  var CLEAR_PROPS$1l = [DISTRIBUTION_POINT$1, DISTRIBUTION_POINT_NAMES$1, REASONS, CRL_ISSUER, CRL_ISSUER_NAMES];
  var DistributionPoint = function (_PkiObject18) {
    function DistributionPoint() {
      var _this77;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, DistributionPoint);
      _this77 = _callSuper(this, DistributionPoint);
      if (DISTRIBUTION_POINT$1 in parameters) {
        _this77.distributionPoint = getParametersValue(parameters, DISTRIBUTION_POINT$1, DistributionPoint.defaultValues(DISTRIBUTION_POINT$1));
      }
      if (REASONS in parameters) {
        _this77.reasons = getParametersValue(parameters, REASONS, DistributionPoint.defaultValues(REASONS));
      }
      if (CRL_ISSUER in parameters) {
        _this77.cRLIssuer = getParametersValue(parameters, CRL_ISSUER, DistributionPoint.defaultValues(CRL_ISSUER));
      }
      if (parameters.schema) {
        _this77.fromSchema(parameters.schema);
      }
      return _this77;
    }
    _inherits(DistributionPoint, _PkiObject18);
    return _createClass(DistributionPoint, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$1l);
        var asn1 = compareSchema(schema, schema, DistributionPoint.schema({
          names: {
            distributionPoint: DISTRIBUTION_POINT$1,
            distributionPointNames: DISTRIBUTION_POINT_NAMES$1,
            reasons: REASONS,
            cRLIssuer: CRL_ISSUER,
            cRLIssuerNames: CRL_ISSUER_NAMES
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (DISTRIBUTION_POINT$1 in asn1.result) {
          if (asn1.result.distributionPoint.idBlock.tagNumber === 0) {
            this.distributionPoint = Array.from(asn1.result.distributionPointNames, function (element) {
              return new GeneralName({
                schema: element
              });
            });
          }
          if (asn1.result.distributionPoint.idBlock.tagNumber === 1) {
            this.distributionPoint = new RelativeDistinguishedNames({
              schema: new Sequence({
                value: asn1.result.distributionPoint.valueBlock.value
              })
            });
          }
        }
        if (REASONS in asn1.result) {
          this.reasons = new BitString({
            valueHex: asn1.result.reasons.valueBlock.valueHex
          });
        }
        if (CRL_ISSUER in asn1.result) {
          this.cRLIssuer = Array.from(asn1.result.cRLIssuerNames, function (element) {
            return new GeneralName({
              schema: element
            });
          });
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        if (this.distributionPoint) {
          var internalValue;
          if (this.distributionPoint instanceof Array) {
            internalValue = new Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: Array.from(this.distributionPoint, function (o) {
                return o.toSchema();
              })
            });
          } else {
            internalValue = new Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: [this.distributionPoint.toSchema()]
            });
          }
          outputArray.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [internalValue]
          }));
        }
        if (this.reasons) {
          outputArray.push(new Primitive({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            valueHex: this.reasons.valueBlock.valueHexView
          }));
        }
        if (this.cRLIssuer) {
          outputArray.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 2
            },
            value: Array.from(this.cRLIssuer, function (o) {
              return o.toSchema();
            })
          }));
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var object = {};
        if (this.distributionPoint) {
          if (this.distributionPoint instanceof Array) {
            object.distributionPoint = Array.from(this.distributionPoint, function (o) {
              return o.toJSON();
            });
          } else {
            object.distributionPoint = this.distributionPoint.toJSON();
          }
        }
        if (this.reasons) {
          object.reasons = this.reasons.toJSON();
        }
        if (this.cRLIssuer) {
          object.cRLIssuer = Array.from(this.cRLIssuer, function (o) {
            return o.toJSON();
          });
        }
        return object;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case DISTRIBUTION_POINT$1:
            return [];
          case REASONS:
            return new BitString();
          case CRL_ISSUER:
            return [];
          default:
            return _superPropGet(DistributionPoint, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [new Choice({
              value: [new Constructed({
                name: names.distributionPoint || EMPTY_STRING,
                optional: true,
                idBlock: {
                  tagClass: 3,
                  tagNumber: 0
                },
                value: [new Repeated({
                  name: names.distributionPointNames || EMPTY_STRING,
                  value: GeneralName.schema()
                })]
              }), new Constructed({
                name: names.distributionPoint || EMPTY_STRING,
                optional: true,
                idBlock: {
                  tagClass: 3,
                  tagNumber: 1
                },
                value: RelativeDistinguishedNames.schema().valueBlock.value
              })]
            })]
          }), new Primitive({
            name: names.reasons || EMPTY_STRING,
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            }
          }), new Constructed({
            name: names.cRLIssuer || EMPTY_STRING,
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 2
            },
            value: [new Repeated({
              name: names.cRLIssuerNames || EMPTY_STRING,
              value: GeneralName.schema()
            })]
          })]
        });
      }
    }]);
  }(PkiObject);
  DistributionPoint.CLASS_NAME = "DistributionPoint";
  var DISTRIBUTION_POINTS = "distributionPoints";
  var CLEAR_PROPS$1k = [DISTRIBUTION_POINTS];
  var CRLDistributionPoints = function (_PkiObject19) {
    function CRLDistributionPoints() {
      var _this78;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, CRLDistributionPoints);
      _this78 = _callSuper(this, CRLDistributionPoints);
      _this78.distributionPoints = getParametersValue(parameters, DISTRIBUTION_POINTS, CRLDistributionPoints.defaultValues(DISTRIBUTION_POINTS));
      if (parameters.schema) {
        _this78.fromSchema(parameters.schema);
      }
      return _this78;
    }
    _inherits(CRLDistributionPoints, _PkiObject19);
    return _createClass(CRLDistributionPoints, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$1k);
        var asn1 = compareSchema(schema, schema, CRLDistributionPoints.schema({
          names: {
            distributionPoints: DISTRIBUTION_POINTS
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.distributionPoints = Array.from(asn1.result.distributionPoints, function (element) {
          return new DistributionPoint({
            schema: element
          });
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: Array.from(this.distributionPoints, function (o) {
            return o.toSchema();
          })
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          distributionPoints: Array.from(this.distributionPoints, function (o) {
            return o.toJSON();
          })
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case DISTRIBUTION_POINTS:
            return [];
          default:
            return _superPropGet(CRLDistributionPoints, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Repeated({
            name: names.distributionPoints || EMPTY_STRING,
            value: DistributionPoint.schema()
          })]
        });
      }
    }]);
  }(PkiObject);
  CRLDistributionPoints.CLASS_NAME = "CRLDistributionPoints";
  var KEY_PURPOSES = "keyPurposes";
  var CLEAR_PROPS$1j = [KEY_PURPOSES];
  var ExtKeyUsage = function (_PkiObject20) {
    function ExtKeyUsage() {
      var _this79;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, ExtKeyUsage);
      _this79 = _callSuper(this, ExtKeyUsage);
      _this79.keyPurposes = getParametersValue(parameters, KEY_PURPOSES, ExtKeyUsage.defaultValues(KEY_PURPOSES));
      if (parameters.schema) {
        _this79.fromSchema(parameters.schema);
      }
      return _this79;
    }
    _inherits(ExtKeyUsage, _PkiObject20);
    return _createClass(ExtKeyUsage, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$1j);
        var asn1 = compareSchema(schema, schema, ExtKeyUsage.schema({
          names: {
            keyPurposes: KEY_PURPOSES
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.keyPurposes = Array.from(asn1.result.keyPurposes, function (element) {
          return element.valueBlock.toString();
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: Array.from(this.keyPurposes, function (element) {
            return new ObjectIdentifier({
              value: element
            });
          })
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          keyPurposes: Array.from(this.keyPurposes)
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case KEY_PURPOSES:
            return [];
          default:
            return _superPropGet(ExtKeyUsage, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Repeated({
            name: names.keyPurposes || EMPTY_STRING,
            value: new ObjectIdentifier()
          })]
        });
      }
    }]);
  }(PkiObject);
  ExtKeyUsage.CLASS_NAME = "ExtKeyUsage";
  var ACCESS_DESCRIPTIONS = "accessDescriptions";
  var InfoAccess = function (_PkiObject21) {
    function InfoAccess() {
      var _this80;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, InfoAccess);
      _this80 = _callSuper(this, InfoAccess);
      _this80.accessDescriptions = getParametersValue(parameters, ACCESS_DESCRIPTIONS, InfoAccess.defaultValues(ACCESS_DESCRIPTIONS));
      if (parameters.schema) {
        _this80.fromSchema(parameters.schema);
      }
      return _this80;
    }
    _inherits(InfoAccess, _PkiObject21);
    return _createClass(InfoAccess, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, [ACCESS_DESCRIPTIONS]);
        var asn1 = compareSchema(schema, schema, InfoAccess.schema({
          names: {
            accessDescriptions: ACCESS_DESCRIPTIONS
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.accessDescriptions = Array.from(asn1.result.accessDescriptions, function (element) {
          return new AccessDescription({
            schema: element
          });
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: Array.from(this.accessDescriptions, function (o) {
            return o.toSchema();
          })
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          accessDescriptions: Array.from(this.accessDescriptions, function (o) {
            return o.toJSON();
          })
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case ACCESS_DESCRIPTIONS:
            return [];
          default:
            return _superPropGet(InfoAccess, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Repeated({
            name: names.accessDescriptions || EMPTY_STRING,
            value: AccessDescription.schema()
          })]
        });
      }
    }]);
  }(PkiObject);
  InfoAccess.CLASS_NAME = "InfoAccess";
  var DISTRIBUTION_POINT = "distributionPoint";
  var DISTRIBUTION_POINT_NAMES = "distributionPointNames";
  var ONLY_CONTAINS_USER_CERTS = "onlyContainsUserCerts";
  var ONLY_CONTAINS_CA_CERTS = "onlyContainsCACerts";
  var ONLY_SOME_REASON = "onlySomeReasons";
  var INDIRECT_CRL = "indirectCRL";
  var ONLY_CONTAINS_ATTRIBUTE_CERTS = "onlyContainsAttributeCerts";
  var CLEAR_PROPS$1i = [DISTRIBUTION_POINT, DISTRIBUTION_POINT_NAMES, ONLY_CONTAINS_USER_CERTS, ONLY_CONTAINS_CA_CERTS, ONLY_SOME_REASON, INDIRECT_CRL, ONLY_CONTAINS_ATTRIBUTE_CERTS];
  var IssuingDistributionPoint = function (_PkiObject22) {
    function IssuingDistributionPoint() {
      var _this81;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, IssuingDistributionPoint);
      _this81 = _callSuper(this, IssuingDistributionPoint);
      if (DISTRIBUTION_POINT in parameters) {
        _this81.distributionPoint = getParametersValue(parameters, DISTRIBUTION_POINT, IssuingDistributionPoint.defaultValues(DISTRIBUTION_POINT));
      }
      _this81.onlyContainsUserCerts = getParametersValue(parameters, ONLY_CONTAINS_USER_CERTS, IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_USER_CERTS));
      _this81.onlyContainsCACerts = getParametersValue(parameters, ONLY_CONTAINS_CA_CERTS, IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_CA_CERTS));
      if (ONLY_SOME_REASON in parameters) {
        _this81.onlySomeReasons = getParametersValue(parameters, ONLY_SOME_REASON, IssuingDistributionPoint.defaultValues(ONLY_SOME_REASON));
      }
      _this81.indirectCRL = getParametersValue(parameters, INDIRECT_CRL, IssuingDistributionPoint.defaultValues(INDIRECT_CRL));
      _this81.onlyContainsAttributeCerts = getParametersValue(parameters, ONLY_CONTAINS_ATTRIBUTE_CERTS, IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_ATTRIBUTE_CERTS));
      if (parameters.schema) {
        _this81.fromSchema(parameters.schema);
      }
      return _this81;
    }
    _inherits(IssuingDistributionPoint, _PkiObject22);
    return _createClass(IssuingDistributionPoint, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$1i);
        var asn1 = compareSchema(schema, schema, IssuingDistributionPoint.schema({
          names: {
            distributionPoint: DISTRIBUTION_POINT,
            distributionPointNames: DISTRIBUTION_POINT_NAMES,
            onlyContainsUserCerts: ONLY_CONTAINS_USER_CERTS,
            onlyContainsCACerts: ONLY_CONTAINS_CA_CERTS,
            onlySomeReasons: ONLY_SOME_REASON,
            indirectCRL: INDIRECT_CRL,
            onlyContainsAttributeCerts: ONLY_CONTAINS_ATTRIBUTE_CERTS
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (DISTRIBUTION_POINT in asn1.result) {
          switch (true) {
            case asn1.result.distributionPoint.idBlock.tagNumber === 0:
              this.distributionPoint = Array.from(asn1.result.distributionPointNames, function (element) {
                return new GeneralName({
                  schema: element
                });
              });
              break;
            case asn1.result.distributionPoint.idBlock.tagNumber === 1:
              {
                this.distributionPoint = new RelativeDistinguishedNames({
                  schema: new Sequence({
                    value: asn1.result.distributionPoint.valueBlock.value
                  })
                });
              }
              break;
            default:
              throw new Error("Unknown tagNumber for distributionPoint: {$asn1.result.distributionPoint.idBlock.tagNumber}");
          }
        }
        if (ONLY_CONTAINS_USER_CERTS in asn1.result) {
          var view = new Uint8Array(asn1.result.onlyContainsUserCerts.valueBlock.valueHex);
          this.onlyContainsUserCerts = view[0] !== 0x00;
        }
        if (ONLY_CONTAINS_CA_CERTS in asn1.result) {
          var _view3 = new Uint8Array(asn1.result.onlyContainsCACerts.valueBlock.valueHex);
          this.onlyContainsCACerts = _view3[0] !== 0x00;
        }
        if (ONLY_SOME_REASON in asn1.result) {
          var _view4 = new Uint8Array(asn1.result.onlySomeReasons.valueBlock.valueHex);
          this.onlySomeReasons = _view4[0];
        }
        if (INDIRECT_CRL in asn1.result) {
          var _view5 = new Uint8Array(asn1.result.indirectCRL.valueBlock.valueHex);
          this.indirectCRL = _view5[0] !== 0x00;
        }
        if (ONLY_CONTAINS_ATTRIBUTE_CERTS in asn1.result) {
          var _view6 = new Uint8Array(asn1.result.onlyContainsAttributeCerts.valueBlock.valueHex);
          this.onlyContainsAttributeCerts = _view6[0] !== 0x00;
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        if (this.distributionPoint) {
          var value;
          if (this.distributionPoint instanceof Array) {
            value = new Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: Array.from(this.distributionPoint, function (o) {
                return o.toSchema();
              })
            });
          } else {
            value = this.distributionPoint.toSchema();
            value.idBlock.tagClass = 3;
            value.idBlock.tagNumber = 1;
          }
          outputArray.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [value]
          }));
        }
        if (this.onlyContainsUserCerts !== IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_USER_CERTS)) {
          outputArray.push(new Primitive({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            valueHex: new Uint8Array([0xFF]).buffer
          }));
        }
        if (this.onlyContainsCACerts !== IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_CA_CERTS)) {
          outputArray.push(new Primitive({
            idBlock: {
              tagClass: 3,
              tagNumber: 2
            },
            valueHex: new Uint8Array([0xFF]).buffer
          }));
        }
        if (this.onlySomeReasons !== undefined) {
          var buffer = new ArrayBuffer(1);
          var view = new Uint8Array(buffer);
          view[0] = this.onlySomeReasons;
          outputArray.push(new Primitive({
            idBlock: {
              tagClass: 3,
              tagNumber: 3
            },
            valueHex: buffer
          }));
        }
        if (this.indirectCRL !== IssuingDistributionPoint.defaultValues(INDIRECT_CRL)) {
          outputArray.push(new Primitive({
            idBlock: {
              tagClass: 3,
              tagNumber: 4
            },
            valueHex: new Uint8Array([0xFF]).buffer
          }));
        }
        if (this.onlyContainsAttributeCerts !== IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_ATTRIBUTE_CERTS)) {
          outputArray.push(new Primitive({
            idBlock: {
              tagClass: 3,
              tagNumber: 5
            },
            valueHex: new Uint8Array([0xFF]).buffer
          }));
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var obj = {};
        if (this.distributionPoint) {
          if (this.distributionPoint instanceof Array) {
            obj.distributionPoint = Array.from(this.distributionPoint, function (o) {
              return o.toJSON();
            });
          } else {
            obj.distributionPoint = this.distributionPoint.toJSON();
          }
        }
        if (this.onlyContainsUserCerts !== IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_USER_CERTS)) {
          obj.onlyContainsUserCerts = this.onlyContainsUserCerts;
        }
        if (this.onlyContainsCACerts !== IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_CA_CERTS)) {
          obj.onlyContainsCACerts = this.onlyContainsCACerts;
        }
        if (ONLY_SOME_REASON in this) {
          obj.onlySomeReasons = this.onlySomeReasons;
        }
        if (this.indirectCRL !== IssuingDistributionPoint.defaultValues(INDIRECT_CRL)) {
          obj.indirectCRL = this.indirectCRL;
        }
        if (this.onlyContainsAttributeCerts !== IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_ATTRIBUTE_CERTS)) {
          obj.onlyContainsAttributeCerts = this.onlyContainsAttributeCerts;
        }
        return obj;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case DISTRIBUTION_POINT:
            return [];
          case ONLY_CONTAINS_USER_CERTS:
            return false;
          case ONLY_CONTAINS_CA_CERTS:
            return false;
          case ONLY_SOME_REASON:
            return 0;
          case INDIRECT_CRL:
            return false;
          case ONLY_CONTAINS_ATTRIBUTE_CERTS:
            return false;
          default:
            return _superPropGet(IssuingDistributionPoint, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [new Choice({
              value: [new Constructed({
                name: names.distributionPoint || EMPTY_STRING,
                idBlock: {
                  tagClass: 3,
                  tagNumber: 0
                },
                value: [new Repeated({
                  name: names.distributionPointNames || EMPTY_STRING,
                  value: GeneralName.schema()
                })]
              }), new Constructed({
                name: names.distributionPoint || EMPTY_STRING,
                idBlock: {
                  tagClass: 3,
                  tagNumber: 1
                },
                value: RelativeDistinguishedNames.schema().valueBlock.value
              })]
            })]
          }), new Primitive({
            name: names.onlyContainsUserCerts || EMPTY_STRING,
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            }
          }), new Primitive({
            name: names.onlyContainsCACerts || EMPTY_STRING,
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 2
            }
          }), new Primitive({
            name: names.onlySomeReasons || EMPTY_STRING,
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 3
            }
          }), new Primitive({
            name: names.indirectCRL || EMPTY_STRING,
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 4
            }
          }), new Primitive({
            name: names.onlyContainsAttributeCerts || EMPTY_STRING,
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 5
            }
          })]
        });
      }
    }]);
  }(PkiObject);
  IssuingDistributionPoint.CLASS_NAME = "IssuingDistributionPoint";
  var BASE = "base";
  var MINIMUM = "minimum";
  var MAXIMUM = "maximum";
  var CLEAR_PROPS$1h = [BASE, MINIMUM, MAXIMUM];
  var GeneralSubtree = function (_PkiObject23) {
    function GeneralSubtree() {
      var _this82;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, GeneralSubtree);
      _this82 = _callSuper(this, GeneralSubtree);
      _this82.base = getParametersValue(parameters, BASE, GeneralSubtree.defaultValues(BASE));
      _this82.minimum = getParametersValue(parameters, MINIMUM, GeneralSubtree.defaultValues(MINIMUM));
      if (MAXIMUM in parameters) {
        _this82.maximum = getParametersValue(parameters, MAXIMUM, GeneralSubtree.defaultValues(MAXIMUM));
      }
      if (parameters.schema) {
        _this82.fromSchema(parameters.schema);
      }
      return _this82;
    }
    _inherits(GeneralSubtree, _PkiObject23);
    return _createClass(GeneralSubtree, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$1h);
        var asn1 = compareSchema(schema, schema, GeneralSubtree.schema({
          names: {
            base: {
              names: {
                blockName: BASE
              }
            },
            minimum: MINIMUM,
            maximum: MAXIMUM
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.base = new GeneralName({
          schema: asn1.result.base
        });
        if (MINIMUM in asn1.result) {
          if (asn1.result.minimum.valueBlock.isHexOnly) this.minimum = asn1.result.minimum;else this.minimum = asn1.result.minimum.valueBlock.valueDec;
        }
        if (MAXIMUM in asn1.result) {
          if (asn1.result.maximum.valueBlock.isHexOnly) this.maximum = asn1.result.maximum;else this.maximum = asn1.result.maximum.valueBlock.valueDec;
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        outputArray.push(this.base.toSchema());
        if (this.minimum !== 0) {
          var valueMinimum = 0;
          if (this.minimum instanceof Integer) {
            valueMinimum = this.minimum;
          } else {
            valueMinimum = new Integer({
              value: this.minimum
            });
          }
          outputArray.push(new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [valueMinimum]
          }));
        }
        if (MAXIMUM in this) {
          var valueMaximum = 0;
          if (this.maximum instanceof Integer) {
            valueMaximum = this.maximum;
          } else {
            valueMaximum = new Integer({
              value: this.maximum
            });
          }
          outputArray.push(new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: [valueMaximum]
          }));
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          base: this.base.toJSON()
        };
        if (this.minimum !== 0) {
          if (typeof this.minimum === "number") {
            res.minimum = this.minimum;
          } else {
            res.minimum = this.minimum.toJSON();
          }
        }
        if (this.maximum !== undefined) {
          if (typeof this.maximum === "number") {
            res.maximum = this.maximum;
          } else {
            res.maximum = this.maximum.toJSON();
          }
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case BASE:
            return new GeneralName();
          case MINIMUM:
            return 0;
          case MAXIMUM:
            return 0;
          default:
            return _superPropGet(GeneralSubtree, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [GeneralName.schema(names.base || {}), new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [new Integer({
              name: names.minimum || EMPTY_STRING
            })]
          }), new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: [new Integer({
              name: names.maximum || EMPTY_STRING
            })]
          })]
        });
      }
    }]);
  }(PkiObject);
  GeneralSubtree.CLASS_NAME = "GeneralSubtree";
  var PERMITTED_SUBTREES = "permittedSubtrees";
  var EXCLUDED_SUBTREES = "excludedSubtrees";
  var CLEAR_PROPS$1g = [PERMITTED_SUBTREES, EXCLUDED_SUBTREES];
  var NameConstraints = function (_PkiObject24) {
    function NameConstraints() {
      var _this83;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, NameConstraints);
      _this83 = _callSuper(this, NameConstraints);
      if (PERMITTED_SUBTREES in parameters) {
        _this83.permittedSubtrees = getParametersValue(parameters, PERMITTED_SUBTREES, NameConstraints.defaultValues(PERMITTED_SUBTREES));
      }
      if (EXCLUDED_SUBTREES in parameters) {
        _this83.excludedSubtrees = getParametersValue(parameters, EXCLUDED_SUBTREES, NameConstraints.defaultValues(EXCLUDED_SUBTREES));
      }
      if (parameters.schema) {
        _this83.fromSchema(parameters.schema);
      }
      return _this83;
    }
    _inherits(NameConstraints, _PkiObject24);
    return _createClass(NameConstraints, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$1g);
        var asn1 = compareSchema(schema, schema, NameConstraints.schema({
          names: {
            permittedSubtrees: PERMITTED_SUBTREES,
            excludedSubtrees: EXCLUDED_SUBTREES
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (PERMITTED_SUBTREES in asn1.result) this.permittedSubtrees = Array.from(asn1.result.permittedSubtrees, function (element) {
          return new GeneralSubtree({
            schema: element
          });
        });
        if (EXCLUDED_SUBTREES in asn1.result) this.excludedSubtrees = Array.from(asn1.result.excludedSubtrees, function (element) {
          return new GeneralSubtree({
            schema: element
          });
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        if (this.permittedSubtrees) {
          outputArray.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: Array.from(this.permittedSubtrees, function (o) {
              return o.toSchema();
            })
          }));
        }
        if (this.excludedSubtrees) {
          outputArray.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: Array.from(this.excludedSubtrees, function (o) {
              return o.toSchema();
            })
          }));
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var object = {};
        if (this.permittedSubtrees) {
          object.permittedSubtrees = Array.from(this.permittedSubtrees, function (o) {
            return o.toJSON();
          });
        }
        if (this.excludedSubtrees) {
          object.excludedSubtrees = Array.from(this.excludedSubtrees, function (o) {
            return o.toJSON();
          });
        }
        return object;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case PERMITTED_SUBTREES:
          case EXCLUDED_SUBTREES:
            return [];
          default:
            return _superPropGet(NameConstraints, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [new Repeated({
              name: names.permittedSubtrees || EMPTY_STRING,
              value: GeneralSubtree.schema()
            })]
          }), new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: [new Repeated({
              name: names.excludedSubtrees || EMPTY_STRING,
              value: GeneralSubtree.schema()
            })]
          })]
        });
      }
    }]);
  }(PkiObject);
  NameConstraints.CLASS_NAME = "NameConstraints";
  var REQUIRE_EXPLICIT_POLICY = "requireExplicitPolicy";
  var INHIBIT_POLICY_MAPPING = "inhibitPolicyMapping";
  var CLEAR_PROPS$1f = [REQUIRE_EXPLICIT_POLICY, INHIBIT_POLICY_MAPPING];
  var PolicyConstraints = function (_PkiObject25) {
    function PolicyConstraints() {
      var _this84;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, PolicyConstraints);
      _this84 = _callSuper(this, PolicyConstraints);
      if (REQUIRE_EXPLICIT_POLICY in parameters) {
        _this84.requireExplicitPolicy = getParametersValue(parameters, REQUIRE_EXPLICIT_POLICY, PolicyConstraints.defaultValues(REQUIRE_EXPLICIT_POLICY));
      }
      if (INHIBIT_POLICY_MAPPING in parameters) {
        _this84.inhibitPolicyMapping = getParametersValue(parameters, INHIBIT_POLICY_MAPPING, PolicyConstraints.defaultValues(INHIBIT_POLICY_MAPPING));
      }
      if (parameters.schema) {
        _this84.fromSchema(parameters.schema);
      }
      return _this84;
    }
    _inherits(PolicyConstraints, _PkiObject25);
    return _createClass(PolicyConstraints, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$1f);
        var asn1 = compareSchema(schema, schema, PolicyConstraints.schema({
          names: {
            requireExplicitPolicy: REQUIRE_EXPLICIT_POLICY,
            inhibitPolicyMapping: INHIBIT_POLICY_MAPPING
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (REQUIRE_EXPLICIT_POLICY in asn1.result) {
          var field1 = asn1.result.requireExplicitPolicy;
          field1.idBlock.tagClass = 1;
          field1.idBlock.tagNumber = 2;
          var ber1 = field1.toBER(false);
          var int1 = _fromBER(ber1);
          AsnError.assert(int1, "Integer");
          this.requireExplicitPolicy = int1.result.valueBlock.valueDec;
        }
        if (INHIBIT_POLICY_MAPPING in asn1.result) {
          var field2 = asn1.result.inhibitPolicyMapping;
          field2.idBlock.tagClass = 1;
          field2.idBlock.tagNumber = 2;
          var ber2 = field2.toBER(false);
          var int2 = _fromBER(ber2);
          AsnError.assert(int2, "Integer");
          this.inhibitPolicyMapping = int2.result.valueBlock.valueDec;
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        if (REQUIRE_EXPLICIT_POLICY in this) {
          var int1 = new Integer({
            value: this.requireExplicitPolicy
          });
          int1.idBlock.tagClass = 3;
          int1.idBlock.tagNumber = 0;
          outputArray.push(int1);
        }
        if (INHIBIT_POLICY_MAPPING in this) {
          var int2 = new Integer({
            value: this.inhibitPolicyMapping
          });
          int2.idBlock.tagClass = 3;
          int2.idBlock.tagNumber = 1;
          outputArray.push(int2);
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {};
        if (REQUIRE_EXPLICIT_POLICY in this) {
          res.requireExplicitPolicy = this.requireExplicitPolicy;
        }
        if (INHIBIT_POLICY_MAPPING in this) {
          res.inhibitPolicyMapping = this.inhibitPolicyMapping;
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case REQUIRE_EXPLICIT_POLICY:
            return 0;
          case INHIBIT_POLICY_MAPPING:
            return 0;
          default:
            return _superPropGet(PolicyConstraints, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Primitive({
            name: names.requireExplicitPolicy || EMPTY_STRING,
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            }
          }), new Primitive({
            name: names.inhibitPolicyMapping || EMPTY_STRING,
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            }
          })]
        });
      }
    }]);
  }(PkiObject);
  PolicyConstraints.CLASS_NAME = "PolicyConstraints";
  var ISSUER_DOMAIN_POLICY = "issuerDomainPolicy";
  var SUBJECT_DOMAIN_POLICY = "subjectDomainPolicy";
  var CLEAR_PROPS$1e = [ISSUER_DOMAIN_POLICY, SUBJECT_DOMAIN_POLICY];
  var PolicyMapping = function (_PkiObject26) {
    function PolicyMapping() {
      var _this85;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, PolicyMapping);
      _this85 = _callSuper(this, PolicyMapping);
      _this85.issuerDomainPolicy = getParametersValue(parameters, ISSUER_DOMAIN_POLICY, PolicyMapping.defaultValues(ISSUER_DOMAIN_POLICY));
      _this85.subjectDomainPolicy = getParametersValue(parameters, SUBJECT_DOMAIN_POLICY, PolicyMapping.defaultValues(SUBJECT_DOMAIN_POLICY));
      if (parameters.schema) {
        _this85.fromSchema(parameters.schema);
      }
      return _this85;
    }
    _inherits(PolicyMapping, _PkiObject26);
    return _createClass(PolicyMapping, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$1e);
        var asn1 = compareSchema(schema, schema, PolicyMapping.schema({
          names: {
            issuerDomainPolicy: ISSUER_DOMAIN_POLICY,
            subjectDomainPolicy: SUBJECT_DOMAIN_POLICY
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.issuerDomainPolicy = asn1.result.issuerDomainPolicy.valueBlock.toString();
        this.subjectDomainPolicy = asn1.result.subjectDomainPolicy.valueBlock.toString();
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: [new ObjectIdentifier({
            value: this.issuerDomainPolicy
          }), new ObjectIdentifier({
            value: this.subjectDomainPolicy
          })]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          issuerDomainPolicy: this.issuerDomainPolicy,
          subjectDomainPolicy: this.subjectDomainPolicy
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case ISSUER_DOMAIN_POLICY:
            return EMPTY_STRING;
          case SUBJECT_DOMAIN_POLICY:
            return EMPTY_STRING;
          default:
            return _superPropGet(PolicyMapping, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new ObjectIdentifier({
            name: names.issuerDomainPolicy || EMPTY_STRING
          }), new ObjectIdentifier({
            name: names.subjectDomainPolicy || EMPTY_STRING
          })]
        });
      }
    }]);
  }(PkiObject);
  PolicyMapping.CLASS_NAME = "PolicyMapping";
  var MAPPINGS = "mappings";
  var CLEAR_PROPS$1d = [MAPPINGS];
  var PolicyMappings = function (_PkiObject27) {
    function PolicyMappings() {
      var _this86;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, PolicyMappings);
      _this86 = _callSuper(this, PolicyMappings);
      _this86.mappings = getParametersValue(parameters, MAPPINGS, PolicyMappings.defaultValues(MAPPINGS));
      if (parameters.schema) {
        _this86.fromSchema(parameters.schema);
      }
      return _this86;
    }
    _inherits(PolicyMappings, _PkiObject27);
    return _createClass(PolicyMappings, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$1d);
        var asn1 = compareSchema(schema, schema, PolicyMappings.schema({
          names: {
            mappings: MAPPINGS
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.mappings = Array.from(asn1.result.mappings, function (element) {
          return new PolicyMapping({
            schema: element
          });
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: Array.from(this.mappings, function (o) {
            return o.toSchema();
          })
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          mappings: Array.from(this.mappings, function (o) {
            return o.toJSON();
          })
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case MAPPINGS:
            return [];
          default:
            return _superPropGet(PolicyMappings, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Repeated({
            name: names.mappings || EMPTY_STRING,
            value: PolicyMapping.schema()
          })]
        });
      }
    }]);
  }(PkiObject);
  PolicyMappings.CLASS_NAME = "PolicyMappings";
  var NOT_BEFORE$1 = "notBefore";
  var NOT_AFTER$1 = "notAfter";
  var CLEAR_PROPS$1c = [NOT_BEFORE$1, NOT_AFTER$1];
  var PrivateKeyUsagePeriod = function (_PkiObject28) {
    function PrivateKeyUsagePeriod() {
      var _this87;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, PrivateKeyUsagePeriod);
      _this87 = _callSuper(this, PrivateKeyUsagePeriod);
      if (NOT_BEFORE$1 in parameters) {
        _this87.notBefore = getParametersValue(parameters, NOT_BEFORE$1, PrivateKeyUsagePeriod.defaultValues(NOT_BEFORE$1));
      }
      if (NOT_AFTER$1 in parameters) {
        _this87.notAfter = getParametersValue(parameters, NOT_AFTER$1, PrivateKeyUsagePeriod.defaultValues(NOT_AFTER$1));
      }
      if (parameters.schema) {
        _this87.fromSchema(parameters.schema);
      }
      return _this87;
    }
    _inherits(PrivateKeyUsagePeriod, _PkiObject28);
    return _createClass(PrivateKeyUsagePeriod, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$1c);
        var asn1 = compareSchema(schema, schema, PrivateKeyUsagePeriod.schema({
          names: {
            notBefore: NOT_BEFORE$1,
            notAfter: NOT_AFTER$1
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (NOT_BEFORE$1 in asn1.result) {
          var localNotBefore = new GeneralizedTime();
          localNotBefore.fromBuffer(asn1.result.notBefore.valueBlock.valueHex);
          this.notBefore = localNotBefore.toDate();
        }
        if (NOT_AFTER$1 in asn1.result) {
          var localNotAfter = new GeneralizedTime({
            valueHex: asn1.result.notAfter.valueBlock.valueHex
          });
          localNotAfter.fromBuffer(asn1.result.notAfter.valueBlock.valueHex);
          this.notAfter = localNotAfter.toDate();
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        if (NOT_BEFORE$1 in this) {
          outputArray.push(new Primitive({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            valueHex: new GeneralizedTime({
              valueDate: this.notBefore
            }).valueBlock.valueHexView
          }));
        }
        if (NOT_AFTER$1 in this) {
          outputArray.push(new Primitive({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            valueHex: new GeneralizedTime({
              valueDate: this.notAfter
            }).valueBlock.valueHexView
          }));
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {};
        if (this.notBefore) {
          res.notBefore = this.notBefore;
        }
        if (this.notAfter) {
          res.notAfter = this.notAfter;
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case NOT_BEFORE$1:
            return new Date();
          case NOT_AFTER$1:
            return new Date();
          default:
            return _superPropGet(PrivateKeyUsagePeriod, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Primitive({
            name: names.notBefore || EMPTY_STRING,
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            }
          }), new Primitive({
            name: names.notAfter || EMPTY_STRING,
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            }
          })]
        });
      }
    }]);
  }(PkiObject);
  PrivateKeyUsagePeriod.CLASS_NAME = "PrivateKeyUsagePeriod";
  var ID = "id";
  var TYPE$2 = "type";
  var VALUES = "values";
  var QC_STATEMENT_CLEAR_PROPS = [ID, TYPE$2];
  var QC_STATEMENTS_CLEAR_PROPS = [VALUES];
  var QCStatement = function (_PkiObject29) {
    function QCStatement() {
      var _this88;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, QCStatement);
      _this88 = _callSuper(this, QCStatement);
      _this88.id = getParametersValue(parameters, ID, QCStatement.defaultValues(ID));
      if (TYPE$2 in parameters) {
        _this88.type = getParametersValue(parameters, TYPE$2, QCStatement.defaultValues(TYPE$2));
      }
      if (parameters.schema) {
        _this88.fromSchema(parameters.schema);
      }
      return _this88;
    }
    _inherits(QCStatement, _PkiObject29);
    return _createClass(QCStatement, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, QC_STATEMENT_CLEAR_PROPS);
        var asn1 = compareSchema(schema, schema, QCStatement.schema({
          names: {
            id: ID,
            type: TYPE$2
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.id = asn1.result.id.valueBlock.toString();
        if (TYPE$2 in asn1.result) this.type = asn1.result.type;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var value = [new ObjectIdentifier({
          value: this.id
        })];
        if (TYPE$2 in this) value.push(this.type);
        return new Sequence({
          value: value
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var object = {
          id: this.id
        };
        if (this.type) {
          object.type = this.type.toJSON();
        }
        return object;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case ID:
            return EMPTY_STRING;
          case TYPE$2:
            return new Null();
          default:
            return _superPropGet(QCStatement, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case ID:
            return memberValue === EMPTY_STRING;
          case TYPE$2:
            return memberValue instanceof Null;
          default:
            return _superPropGet(QCStatement, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new ObjectIdentifier({
            name: names.id || EMPTY_STRING
          }), new Any({
            name: names.type || EMPTY_STRING,
            optional: true
          })]
        });
      }
    }]);
  }(PkiObject);
  QCStatement.CLASS_NAME = "QCStatement";
  var QCStatements = function (_PkiObject30) {
    function QCStatements() {
      var _this89;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, QCStatements);
      _this89 = _callSuper(this, QCStatements);
      _this89.values = getParametersValue(parameters, VALUES, QCStatements.defaultValues(VALUES));
      if (parameters.schema) {
        _this89.fromSchema(parameters.schema);
      }
      return _this89;
    }
    _inherits(QCStatements, _PkiObject30);
    return _createClass(QCStatements, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, QC_STATEMENTS_CLEAR_PROPS);
        var asn1 = compareSchema(schema, schema, QCStatements.schema({
          names: {
            values: VALUES
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.values = Array.from(asn1.result.values, function (element) {
          return new QCStatement({
            schema: element
          });
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: Array.from(this.values, function (o) {
            return o.toSchema();
          })
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          values: Array.from(this.values, function (o) {
            return o.toJSON();
          })
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case VALUES:
            return [];
          default:
            return _superPropGet(QCStatements, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VALUES:
            return memberValue.length === 0;
          default:
            return _superPropGet(QCStatements, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Repeated({
            name: names.values || EMPTY_STRING,
            value: QCStatement.schema(names.value || {})
          })]
        });
      }
    }]);
  }(PkiObject);
  QCStatements.CLASS_NAME = "QCStatements";
  var _a;
  var ECNamedCurves = function () {
    function ECNamedCurves() {
      _classCallCheck(this, ECNamedCurves);
    }
    return _createClass(ECNamedCurves, null, [{
      key: "register",
      value: function register(name, id, size) {
        this.namedCurves[name.toLowerCase()] = this.namedCurves[id] = {
          name: name,
          id: id,
          size: size
        };
      }
    }, {
      key: "find",
      value: function find(nameOrId) {
        return this.namedCurves[nameOrId.toLowerCase()] || null;
      }
    }]);
  }();
  _a = ECNamedCurves;
  ECNamedCurves.namedCurves = {};
  (function () {
    _a.register("P-256", "1.2.840.10045.3.1.7", 32);
    _a.register("P-384", "1.3.132.0.34", 48);
    _a.register("P-521", "1.3.132.0.35", 66);
    _a.register("brainpoolP256r1", "1.3.36.3.3.2.8.1.1.7", 32);
    _a.register("brainpoolP384r1", "1.3.36.3.3.2.8.1.1.11", 48);
    _a.register("brainpoolP512r1", "1.3.36.3.3.2.8.1.1.13", 64);
  })();
  var X = "x";
  var Y = "y";
  var NAMED_CURVE$1 = "namedCurve";
  var ECPublicKey = function (_PkiObject31) {
    function ECPublicKey() {
      var _this90;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, ECPublicKey);
      _this90 = _callSuper(this, ECPublicKey);
      _this90.x = getParametersValue(parameters, X, ECPublicKey.defaultValues(X));
      _this90.y = getParametersValue(parameters, Y, ECPublicKey.defaultValues(Y));
      _this90.namedCurve = getParametersValue(parameters, NAMED_CURVE$1, ECPublicKey.defaultValues(NAMED_CURVE$1));
      if (parameters.json) {
        _this90.fromJSON(parameters.json);
      }
      if (parameters.schema) {
        _this90.fromSchema(parameters.schema);
      }
      return _this90;
    }
    _inherits(ECPublicKey, _PkiObject31);
    return _createClass(ECPublicKey, [{
      key: "fromSchema",
      value: function fromSchema(schema1) {
        var view = BufferSourceConverter.toUint8Array(schema1);
        if (view[0] !== 0x04) {
          throw new Error("Object's schema was not verified against input data for ECPublicKey");
        }
        var namedCurve = ECNamedCurves.find(this.namedCurve);
        if (!namedCurve) {
          throw new Error("Incorrect curve OID: ".concat(this.namedCurve));
        }
        var coordinateLength = namedCurve.size;
        if (view.byteLength !== coordinateLength * 2 + 1) {
          throw new Error("Object's schema was not verified against input data for ECPublicKey");
        }
        this.namedCurve = namedCurve.name;
        this.x = view.slice(1, coordinateLength + 1).buffer;
        this.y = view.slice(1 + coordinateLength, coordinateLength * 2 + 1).buffer;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new RawData({
          data: utilConcatBuf(new Uint8Array([0x04]).buffer, this.x, this.y)
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var namedCurve = ECNamedCurves.find(this.namedCurve);
        return {
          crv: namedCurve ? namedCurve.name : this.namedCurve,
          x: toBase64(arrayBufferToString(this.x), true, true, false),
          y: toBase64(arrayBufferToString(this.y), true, true, false)
        };
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(json) {
        ParameterError.assert("json", json, "crv", "x", "y");
        var coordinateLength = 0;
        var namedCurve = ECNamedCurves.find(json.crv);
        if (namedCurve) {
          this.namedCurve = namedCurve.id;
          coordinateLength = namedCurve.size;
        }
        var xConvertBuffer = stringToArrayBuffer(fromBase64(json.x, true));
        if (xConvertBuffer.byteLength < coordinateLength) {
          this.x = new ArrayBuffer(coordinateLength);
          var view = new Uint8Array(this.x);
          var convertBufferView = new Uint8Array(xConvertBuffer);
          view.set(convertBufferView, 1);
        } else {
          this.x = xConvertBuffer.slice(0, coordinateLength);
        }
        var yConvertBuffer = stringToArrayBuffer(fromBase64(json.y, true));
        if (yConvertBuffer.byteLength < coordinateLength) {
          this.y = new ArrayBuffer(coordinateLength);
          var _view7 = new Uint8Array(this.y);
          var _convertBufferView = new Uint8Array(yConvertBuffer);
          _view7.set(_convertBufferView, 1);
        } else {
          this.y = yConvertBuffer.slice(0, coordinateLength);
        }
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case X:
          case Y:
            return EMPTY_BUFFER;
          case NAMED_CURVE$1:
            return EMPTY_STRING;
          default:
            return _superPropGet(ECPublicKey, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case X:
          case Y:
            return memberValue instanceof ArrayBuffer && isEqualBuffer(memberValue, ECPublicKey.defaultValues(memberName));
          case NAMED_CURVE$1:
            return typeof memberValue === "string" && memberValue === ECPublicKey.defaultValues(memberName);
          default:
            return _superPropGet(ECPublicKey, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        return new RawData();
      }
    }]);
  }(PkiObject);
  ECPublicKey.CLASS_NAME = "ECPublicKey";
  var MODULUS$1 = "modulus";
  var PUBLIC_EXPONENT$1 = "publicExponent";
  var CLEAR_PROPS$1b = [MODULUS$1, PUBLIC_EXPONENT$1];
  var RSAPublicKey = function (_PkiObject32) {
    function RSAPublicKey() {
      var _this91;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, RSAPublicKey);
      _this91 = _callSuper(this, RSAPublicKey);
      _this91.modulus = getParametersValue(parameters, MODULUS$1, RSAPublicKey.defaultValues(MODULUS$1));
      _this91.publicExponent = getParametersValue(parameters, PUBLIC_EXPONENT$1, RSAPublicKey.defaultValues(PUBLIC_EXPONENT$1));
      if (parameters.json) {
        _this91.fromJSON(parameters.json);
      }
      if (parameters.schema) {
        _this91.fromSchema(parameters.schema);
      }
      return _this91;
    }
    _inherits(RSAPublicKey, _PkiObject32);
    return _createClass(RSAPublicKey, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$1b);
        var asn1 = compareSchema(schema, schema, RSAPublicKey.schema({
          names: {
            modulus: MODULUS$1,
            publicExponent: PUBLIC_EXPONENT$1
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.modulus = asn1.result.modulus.convertFromDER(256);
        this.publicExponent = asn1.result.publicExponent;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: [this.modulus.convertToDER(), this.publicExponent]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          n: Convert.ToBase64Url(this.modulus.valueBlock.valueHexView),
          e: Convert.ToBase64Url(this.publicExponent.valueBlock.valueHexView)
        };
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(json) {
        ParameterError.assert("json", json, "n", "e");
        var array = stringToArrayBuffer(fromBase64(json.n, true));
        this.modulus = new Integer({
          valueHex: array.slice(0, Math.pow(2, nearestPowerOf2(array.byteLength)))
        });
        this.publicExponent = new Integer({
          valueHex: stringToArrayBuffer(fromBase64(json.e, true)).slice(0, 3)
        });
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case MODULUS$1:
            return new Integer();
          case PUBLIC_EXPONENT$1:
            return new Integer();
          default:
            return _superPropGet(RSAPublicKey, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Integer({
            name: names.modulus || EMPTY_STRING
          }), new Integer({
            name: names.publicExponent || EMPTY_STRING
          })]
        });
      }
    }]);
  }(PkiObject);
  RSAPublicKey.CLASS_NAME = "RSAPublicKey";
  var ALGORITHM$1 = "algorithm";
  var SUBJECT_PUBLIC_KEY = "subjectPublicKey";
  var CLEAR_PROPS$1a = [ALGORITHM$1, SUBJECT_PUBLIC_KEY];
  var PublicKeyInfo = function (_PkiObject33) {
    function PublicKeyInfo() {
      var _this92;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, PublicKeyInfo);
      _this92 = _callSuper(this, PublicKeyInfo);
      _this92.algorithm = getParametersValue(parameters, ALGORITHM$1, PublicKeyInfo.defaultValues(ALGORITHM$1));
      _this92.subjectPublicKey = getParametersValue(parameters, SUBJECT_PUBLIC_KEY, PublicKeyInfo.defaultValues(SUBJECT_PUBLIC_KEY));
      var parsedKey = getParametersValue(parameters, "parsedKey", null);
      if (parsedKey) {
        _this92.parsedKey = parsedKey;
      }
      if (parameters.json) {
        _this92.fromJSON(parameters.json);
      }
      if (parameters.schema) {
        _this92.fromSchema(parameters.schema);
      }
      return _this92;
    }
    _inherits(PublicKeyInfo, _PkiObject33);
    return _createClass(PublicKeyInfo, [{
      key: "parsedKey",
      get: function get() {
        if (this._parsedKey === undefined) {
          switch (this.algorithm.algorithmId) {
            case "1.2.840.10045.2.1":
              if ("algorithmParams" in this.algorithm) {
                if (this.algorithm.algorithmParams.constructor.blockName() === ObjectIdentifier.blockName()) {
                  try {
                    this._parsedKey = new ECPublicKey({
                      namedCurve: this.algorithm.algorithmParams.valueBlock.toString(),
                      schema: this.subjectPublicKey.valueBlock.valueHexView
                    });
                  } catch (ex) {}
                }
              }
              break;
            case "1.2.840.113549.1.1.1":
              {
                var publicKeyASN1 = _fromBER(this.subjectPublicKey.valueBlock.valueHexView);
                if (publicKeyASN1.offset !== -1) {
                  try {
                    this._parsedKey = new RSAPublicKey({
                      schema: publicKeyASN1.result
                    });
                  } catch (ex) {}
                }
              }
              break;
          }
          this._parsedKey || (this._parsedKey = null);
        }
        return this._parsedKey || undefined;
      },
      set: function set(value) {
        this._parsedKey = value;
      }
    }, {
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$1a);
        var asn1 = compareSchema(schema, schema, PublicKeyInfo.schema({
          names: {
            algorithm: {
              names: {
                blockName: ALGORITHM$1
              }
            },
            subjectPublicKey: SUBJECT_PUBLIC_KEY
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.algorithm = new AlgorithmIdentifier({
          schema: asn1.result.algorithm
        });
        this.subjectPublicKey = asn1.result.subjectPublicKey;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: [this.algorithm.toSchema(), this.subjectPublicKey]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        if (!this.parsedKey) {
          return {
            algorithm: this.algorithm.toJSON(),
            subjectPublicKey: this.subjectPublicKey.toJSON()
          };
        }
        var jwk = {};
        switch (this.algorithm.algorithmId) {
          case "1.2.840.10045.2.1":
            jwk.kty = "EC";
            break;
          case "1.2.840.113549.1.1.1":
            jwk.kty = "RSA";
            break;
        }
        var publicKeyJWK = this.parsedKey.toJSON();
        Object.assign(jwk, publicKeyJWK);
        return jwk;
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(json) {
        if ("kty" in json) {
          switch (json.kty.toUpperCase()) {
            case "EC":
              this.parsedKey = new ECPublicKey({
                json: json
              });
              this.algorithm = new AlgorithmIdentifier({
                algorithmId: "1.2.840.10045.2.1",
                algorithmParams: new ObjectIdentifier({
                  value: this.parsedKey.namedCurve
                })
              });
              break;
            case "RSA":
              this.parsedKey = new RSAPublicKey({
                json: json
              });
              this.algorithm = new AlgorithmIdentifier({
                algorithmId: "1.2.840.113549.1.1.1",
                algorithmParams: new Null()
              });
              break;
            default:
              throw new Error("Invalid value for \"kty\" parameter: ".concat(json.kty));
          }
          this.subjectPublicKey = new BitString({
            valueHex: this.parsedKey.toSchema().toBER(false)
          });
        }
      }
    }, {
      key: "importKey",
      value: function () {
        var _importKey = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(publicKey) {
          var crypto,
            exportedKey,
            asn1,
            message,
            _args = arguments;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                crypto = _args.length > 1 && _args[1] !== undefined ? _args[1] : getCrypto(true);
                _context.prev = 1;
                if (publicKey) {
                  _context.next = 4;
                  break;
                }
                throw new Error("Need to provide publicKey input parameter");
              case 4:
                _context.next = 6;
                return crypto.exportKey("spki", publicKey);
              case 6:
                exportedKey = _context.sent;
                asn1 = _fromBER(exportedKey);
                _context.prev = 8;
                this.fromSchema(asn1.result);
                _context.next = 15;
                break;
              case 12:
                _context.prev = 12;
                _context.t0 = _context["catch"](8);
                throw new Error("Error during initializing object from schema");
              case 15:
                _context.next = 21;
                break;
              case 17:
                _context.prev = 17;
                _context.t1 = _context["catch"](1);
                message = _context.t1 instanceof Error ? _context.t1.message : "".concat(_context.t1);
                throw new Error("Error during exporting public key: ".concat(message));
              case 21:
              case "end":
                return _context.stop();
            }
          }, _callee, this, [[1, 17], [8, 12]]);
        }));
        function importKey(_x) {
          return _importKey.apply(this, arguments);
        }
        return importKey;
      }()
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case ALGORITHM$1:
            return new AlgorithmIdentifier();
          case SUBJECT_PUBLIC_KEY:
            return new BitString();
          default:
            return _superPropGet(PublicKeyInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [AlgorithmIdentifier.schema(names.algorithm || {}), new BitString({
            name: names.subjectPublicKey || EMPTY_STRING
          })]
        });
      }
    }]);
  }(PkiObject);
  PublicKeyInfo.CLASS_NAME = "PublicKeyInfo";
  var VERSION$l = "version";
  var PRIVATE_KEY$1 = "privateKey";
  var NAMED_CURVE = "namedCurve";
  var PUBLIC_KEY$1 = "publicKey";
  var CLEAR_PROPS$19 = [VERSION$l, PRIVATE_KEY$1, NAMED_CURVE, PUBLIC_KEY$1];
  var ECPrivateKey = function (_PkiObject34) {
    function ECPrivateKey() {
      var _this93;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, ECPrivateKey);
      _this93 = _callSuper(this, ECPrivateKey);
      _this93.version = getParametersValue(parameters, VERSION$l, ECPrivateKey.defaultValues(VERSION$l));
      _this93.privateKey = getParametersValue(parameters, PRIVATE_KEY$1, ECPrivateKey.defaultValues(PRIVATE_KEY$1));
      if (NAMED_CURVE in parameters) {
        _this93.namedCurve = getParametersValue(parameters, NAMED_CURVE, ECPrivateKey.defaultValues(NAMED_CURVE));
      }
      if (PUBLIC_KEY$1 in parameters) {
        _this93.publicKey = getParametersValue(parameters, PUBLIC_KEY$1, ECPrivateKey.defaultValues(PUBLIC_KEY$1));
      }
      if (parameters.json) {
        _this93.fromJSON(parameters.json);
      }
      if (parameters.schema) {
        _this93.fromSchema(parameters.schema);
      }
      return _this93;
    }
    _inherits(ECPrivateKey, _PkiObject34);
    return _createClass(ECPrivateKey, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$19);
        var asn1 = compareSchema(schema, schema, ECPrivateKey.schema({
          names: {
            version: VERSION$l,
            privateKey: PRIVATE_KEY$1,
            namedCurve: NAMED_CURVE,
            publicKey: PUBLIC_KEY$1
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result.version.valueBlock.valueDec;
        this.privateKey = asn1.result.privateKey;
        if (NAMED_CURVE in asn1.result) {
          this.namedCurve = asn1.result.namedCurve.valueBlock.toString();
        }
        if (PUBLIC_KEY$1 in asn1.result) {
          var publicKeyData = {
            schema: asn1.result.publicKey.valueBlock.valueHex
          };
          if (NAMED_CURVE in this) {
            publicKeyData.namedCurve = this.namedCurve;
          }
          this.publicKey = new ECPublicKey(publicKeyData);
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [new Integer({
          value: this.version
        }), this.privateKey];
        if (this.namedCurve) {
          outputArray.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [new ObjectIdentifier({
              value: this.namedCurve
            })]
          }));
        }
        if (this.publicKey) {
          outputArray.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: [new BitString({
              valueHex: this.publicKey.toSchema().toBER(false)
            })]
          }));
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        if (!this.namedCurve || ECPrivateKey.compareWithDefault(NAMED_CURVE, this.namedCurve)) {
          throw new Error("Not enough information for making JSON: absent \"namedCurve\" value");
        }
        var curve = ECNamedCurves.find(this.namedCurve);
        var privateKeyJSON = {
          crv: curve ? curve.name : this.namedCurve,
          d: Convert.ToBase64Url(this.privateKey.valueBlock.valueHexView)
        };
        if (this.publicKey) {
          var publicKeyJSON = this.publicKey.toJSON();
          privateKeyJSON.x = publicKeyJSON.x;
          privateKeyJSON.y = publicKeyJSON.y;
        }
        return privateKeyJSON;
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(json) {
        ParameterError.assert("json", json, "crv", "d");
        var coordinateLength = 0;
        var curve = ECNamedCurves.find(json.crv);
        if (curve) {
          this.namedCurve = curve.id;
          coordinateLength = curve.size;
        }
        var convertBuffer = Convert.FromBase64Url(json.d);
        if (convertBuffer.byteLength < coordinateLength) {
          var buffer = new ArrayBuffer(coordinateLength);
          var view = new Uint8Array(buffer);
          var convertBufferView = new Uint8Array(convertBuffer);
          view.set(convertBufferView, 1);
          this.privateKey = new OctetString({
            valueHex: buffer
          });
        } else {
          this.privateKey = new OctetString({
            valueHex: convertBuffer.slice(0, coordinateLength)
          });
        }
        if (json.x && json.y) {
          this.publicKey = new ECPublicKey({
            json: json
          });
        }
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case VERSION$l:
            return 1;
          case PRIVATE_KEY$1:
            return new OctetString();
          case NAMED_CURVE:
            return EMPTY_STRING;
          case PUBLIC_KEY$1:
            return new ECPublicKey();
          default:
            return _superPropGet(ECPrivateKey, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VERSION$l:
            return memberValue === ECPrivateKey.defaultValues(memberName);
          case PRIVATE_KEY$1:
            return memberValue.isEqual(ECPrivateKey.defaultValues(memberName));
          case NAMED_CURVE:
            return memberValue === EMPTY_STRING;
          case PUBLIC_KEY$1:
            return ECPublicKey.compareWithDefault(NAMED_CURVE, memberValue.namedCurve) && ECPublicKey.compareWithDefault("x", memberValue.x) && ECPublicKey.compareWithDefault("y", memberValue.y);
          default:
            return _superPropGet(ECPrivateKey, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Integer({
            name: names.version || EMPTY_STRING
          }), new OctetString({
            name: names.privateKey || EMPTY_STRING
          }), new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [new ObjectIdentifier({
              name: names.namedCurve || EMPTY_STRING
            })]
          }), new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: [new BitString({
              name: names.publicKey || EMPTY_STRING
            })]
          })]
        });
      }
    }]);
  }(PkiObject);
  ECPrivateKey.CLASS_NAME = "ECPrivateKey";
  var PRIME = "prime";
  var EXPONENT = "exponent";
  var COEFFICIENT$1 = "coefficient";
  var CLEAR_PROPS$18 = [PRIME, EXPONENT, COEFFICIENT$1];
  var OtherPrimeInfo = function (_PkiObject35) {
    function OtherPrimeInfo() {
      var _this94;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, OtherPrimeInfo);
      _this94 = _callSuper(this, OtherPrimeInfo);
      _this94.prime = getParametersValue(parameters, PRIME, OtherPrimeInfo.defaultValues(PRIME));
      _this94.exponent = getParametersValue(parameters, EXPONENT, OtherPrimeInfo.defaultValues(EXPONENT));
      _this94.coefficient = getParametersValue(parameters, COEFFICIENT$1, OtherPrimeInfo.defaultValues(COEFFICIENT$1));
      if (parameters.json) {
        _this94.fromJSON(parameters.json);
      }
      if (parameters.schema) {
        _this94.fromSchema(parameters.schema);
      }
      return _this94;
    }
    _inherits(OtherPrimeInfo, _PkiObject35);
    return _createClass(OtherPrimeInfo, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$18);
        var asn1 = compareSchema(schema, schema, OtherPrimeInfo.schema({
          names: {
            prime: PRIME,
            exponent: EXPONENT,
            coefficient: COEFFICIENT$1
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.prime = asn1.result.prime.convertFromDER();
        this.exponent = asn1.result.exponent.convertFromDER();
        this.coefficient = asn1.result.coefficient.convertFromDER();
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: [this.prime.convertToDER(), this.exponent.convertToDER(), this.coefficient.convertToDER()]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          r: Convert.ToBase64Url(this.prime.valueBlock.valueHexView),
          d: Convert.ToBase64Url(this.exponent.valueBlock.valueHexView),
          t: Convert.ToBase64Url(this.coefficient.valueBlock.valueHexView)
        };
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(json) {
        ParameterError.assert("json", json, "r", "d", "r");
        this.prime = new Integer({
          valueHex: Convert.FromBase64Url(json.r)
        });
        this.exponent = new Integer({
          valueHex: Convert.FromBase64Url(json.d)
        });
        this.coefficient = new Integer({
          valueHex: Convert.FromBase64Url(json.t)
        });
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case PRIME:
            return new Integer();
          case EXPONENT:
            return new Integer();
          case COEFFICIENT$1:
            return new Integer();
          default:
            return _superPropGet(OtherPrimeInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Integer({
            name: names.prime || EMPTY_STRING
          }), new Integer({
            name: names.exponent || EMPTY_STRING
          }), new Integer({
            name: names.coefficient || EMPTY_STRING
          })]
        });
      }
    }]);
  }(PkiObject);
  OtherPrimeInfo.CLASS_NAME = "OtherPrimeInfo";
  var VERSION$k = "version";
  var MODULUS = "modulus";
  var PUBLIC_EXPONENT = "publicExponent";
  var PRIVATE_EXPONENT = "privateExponent";
  var PRIME1 = "prime1";
  var PRIME2 = "prime2";
  var EXPONENT1 = "exponent1";
  var EXPONENT2 = "exponent2";
  var COEFFICIENT = "coefficient";
  var OTHER_PRIME_INFOS = "otherPrimeInfos";
  var CLEAR_PROPS$17 = [VERSION$k, MODULUS, PUBLIC_EXPONENT, PRIVATE_EXPONENT, PRIME1, PRIME2, EXPONENT1, EXPONENT2, COEFFICIENT, OTHER_PRIME_INFOS];
  var RSAPrivateKey = function (_PkiObject36) {
    function RSAPrivateKey() {
      var _this95;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, RSAPrivateKey);
      _this95 = _callSuper(this, RSAPrivateKey);
      _this95.version = getParametersValue(parameters, VERSION$k, RSAPrivateKey.defaultValues(VERSION$k));
      _this95.modulus = getParametersValue(parameters, MODULUS, RSAPrivateKey.defaultValues(MODULUS));
      _this95.publicExponent = getParametersValue(parameters, PUBLIC_EXPONENT, RSAPrivateKey.defaultValues(PUBLIC_EXPONENT));
      _this95.privateExponent = getParametersValue(parameters, PRIVATE_EXPONENT, RSAPrivateKey.defaultValues(PRIVATE_EXPONENT));
      _this95.prime1 = getParametersValue(parameters, PRIME1, RSAPrivateKey.defaultValues(PRIME1));
      _this95.prime2 = getParametersValue(parameters, PRIME2, RSAPrivateKey.defaultValues(PRIME2));
      _this95.exponent1 = getParametersValue(parameters, EXPONENT1, RSAPrivateKey.defaultValues(EXPONENT1));
      _this95.exponent2 = getParametersValue(parameters, EXPONENT2, RSAPrivateKey.defaultValues(EXPONENT2));
      _this95.coefficient = getParametersValue(parameters, COEFFICIENT, RSAPrivateKey.defaultValues(COEFFICIENT));
      if (OTHER_PRIME_INFOS in parameters) {
        _this95.otherPrimeInfos = getParametersValue(parameters, OTHER_PRIME_INFOS, RSAPrivateKey.defaultValues(OTHER_PRIME_INFOS));
      }
      if (parameters.json) {
        _this95.fromJSON(parameters.json);
      }
      if (parameters.schema) {
        _this95.fromSchema(parameters.schema);
      }
      return _this95;
    }
    _inherits(RSAPrivateKey, _PkiObject36);
    return _createClass(RSAPrivateKey, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$17);
        var asn1 = compareSchema(schema, schema, RSAPrivateKey.schema({
          names: {
            version: VERSION$k,
            modulus: MODULUS,
            publicExponent: PUBLIC_EXPONENT,
            privateExponent: PRIVATE_EXPONENT,
            prime1: PRIME1,
            prime2: PRIME2,
            exponent1: EXPONENT1,
            exponent2: EXPONENT2,
            coefficient: COEFFICIENT,
            otherPrimeInfo: {
              names: {
                blockName: OTHER_PRIME_INFOS
              }
            }
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result.version.valueBlock.valueDec;
        this.modulus = asn1.result.modulus.convertFromDER(256);
        this.publicExponent = asn1.result.publicExponent;
        this.privateExponent = asn1.result.privateExponent.convertFromDER(256);
        this.prime1 = asn1.result.prime1.convertFromDER(128);
        this.prime2 = asn1.result.prime2.convertFromDER(128);
        this.exponent1 = asn1.result.exponent1.convertFromDER(128);
        this.exponent2 = asn1.result.exponent2.convertFromDER(128);
        this.coefficient = asn1.result.coefficient.convertFromDER(128);
        if (OTHER_PRIME_INFOS in asn1.result) this.otherPrimeInfos = Array.from(asn1.result.otherPrimeInfos, function (element) {
          return new OtherPrimeInfo({
            schema: element
          });
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        outputArray.push(new Integer({
          value: this.version
        }));
        outputArray.push(this.modulus.convertToDER());
        outputArray.push(this.publicExponent);
        outputArray.push(this.privateExponent.convertToDER());
        outputArray.push(this.prime1.convertToDER());
        outputArray.push(this.prime2.convertToDER());
        outputArray.push(this.exponent1.convertToDER());
        outputArray.push(this.exponent2.convertToDER());
        outputArray.push(this.coefficient.convertToDER());
        if (this.otherPrimeInfos) {
          outputArray.push(new Sequence({
            value: Array.from(this.otherPrimeInfos, function (o) {
              return o.toSchema();
            })
          }));
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var jwk = {
          n: Convert.ToBase64Url(this.modulus.valueBlock.valueHexView),
          e: Convert.ToBase64Url(this.publicExponent.valueBlock.valueHexView),
          d: Convert.ToBase64Url(this.privateExponent.valueBlock.valueHexView),
          p: Convert.ToBase64Url(this.prime1.valueBlock.valueHexView),
          q: Convert.ToBase64Url(this.prime2.valueBlock.valueHexView),
          dp: Convert.ToBase64Url(this.exponent1.valueBlock.valueHexView),
          dq: Convert.ToBase64Url(this.exponent2.valueBlock.valueHexView),
          qi: Convert.ToBase64Url(this.coefficient.valueBlock.valueHexView)
        };
        if (this.otherPrimeInfos) {
          jwk.oth = Array.from(this.otherPrimeInfos, function (o) {
            return o.toJSON();
          });
        }
        return jwk;
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(json) {
        ParameterError.assert("json", json, "n", "e", "d", "p", "q", "dp", "dq", "qi");
        this.modulus = new Integer({
          valueHex: Convert.FromBase64Url(json.n)
        });
        this.publicExponent = new Integer({
          valueHex: Convert.FromBase64Url(json.e)
        });
        this.privateExponent = new Integer({
          valueHex: Convert.FromBase64Url(json.d)
        });
        this.prime1 = new Integer({
          valueHex: Convert.FromBase64Url(json.p)
        });
        this.prime2 = new Integer({
          valueHex: Convert.FromBase64Url(json.q)
        });
        this.exponent1 = new Integer({
          valueHex: Convert.FromBase64Url(json.dp)
        });
        this.exponent2 = new Integer({
          valueHex: Convert.FromBase64Url(json.dq)
        });
        this.coefficient = new Integer({
          valueHex: Convert.FromBase64Url(json.qi)
        });
        if (json.oth) {
          this.otherPrimeInfos = Array.from(json.oth, function (element) {
            return new OtherPrimeInfo({
              json: element
            });
          });
        }
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case VERSION$k:
            return 0;
          case MODULUS:
            return new Integer();
          case PUBLIC_EXPONENT:
            return new Integer();
          case PRIVATE_EXPONENT:
            return new Integer();
          case PRIME1:
            return new Integer();
          case PRIME2:
            return new Integer();
          case EXPONENT1:
            return new Integer();
          case EXPONENT2:
            return new Integer();
          case COEFFICIENT:
            return new Integer();
          case OTHER_PRIME_INFOS:
            return [];
          default:
            return _superPropGet(RSAPrivateKey, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Integer({
            name: names.version || EMPTY_STRING
          }), new Integer({
            name: names.modulus || EMPTY_STRING
          }), new Integer({
            name: names.publicExponent || EMPTY_STRING
          }), new Integer({
            name: names.privateExponent || EMPTY_STRING
          }), new Integer({
            name: names.prime1 || EMPTY_STRING
          }), new Integer({
            name: names.prime2 || EMPTY_STRING
          }), new Integer({
            name: names.exponent1 || EMPTY_STRING
          }), new Integer({
            name: names.exponent2 || EMPTY_STRING
          }), new Integer({
            name: names.coefficient || EMPTY_STRING
          }), new Sequence({
            optional: true,
            value: [new Repeated({
              name: names.otherPrimeInfosName || EMPTY_STRING,
              value: OtherPrimeInfo.schema(names.otherPrimeInfo || {})
            })]
          })]
        });
      }
    }]);
  }(PkiObject);
  RSAPrivateKey.CLASS_NAME = "RSAPrivateKey";
  var VERSION$j = "version";
  var PRIVATE_KEY_ALGORITHM = "privateKeyAlgorithm";
  var PRIVATE_KEY = "privateKey";
  var ATTRIBUTES$5 = "attributes";
  var PARSED_KEY = "parsedKey";
  var CLEAR_PROPS$16 = [VERSION$j, PRIVATE_KEY_ALGORITHM, PRIVATE_KEY, ATTRIBUTES$5];
  var PrivateKeyInfo = function (_PkiObject37) {
    function PrivateKeyInfo() {
      var _this96;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, PrivateKeyInfo);
      _this96 = _callSuper(this, PrivateKeyInfo);
      _this96.version = getParametersValue(parameters, VERSION$j, PrivateKeyInfo.defaultValues(VERSION$j));
      _this96.privateKeyAlgorithm = getParametersValue(parameters, PRIVATE_KEY_ALGORITHM, PrivateKeyInfo.defaultValues(PRIVATE_KEY_ALGORITHM));
      _this96.privateKey = getParametersValue(parameters, PRIVATE_KEY, PrivateKeyInfo.defaultValues(PRIVATE_KEY));
      if (ATTRIBUTES$5 in parameters) {
        _this96.attributes = getParametersValue(parameters, ATTRIBUTES$5, PrivateKeyInfo.defaultValues(ATTRIBUTES$5));
      }
      if (PARSED_KEY in parameters) {
        _this96.parsedKey = getParametersValue(parameters, PARSED_KEY, PrivateKeyInfo.defaultValues(PARSED_KEY));
      }
      if (parameters.json) {
        _this96.fromJSON(parameters.json);
      }
      if (parameters.schema) {
        _this96.fromSchema(parameters.schema);
      }
      return _this96;
    }
    _inherits(PrivateKeyInfo, _PkiObject37);
    return _createClass(PrivateKeyInfo, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$16);
        var asn1 = compareSchema(schema, schema, PrivateKeyInfo.schema({
          names: {
            version: VERSION$j,
            privateKeyAlgorithm: {
              names: {
                blockName: PRIVATE_KEY_ALGORITHM
              }
            },
            privateKey: PRIVATE_KEY,
            attributes: ATTRIBUTES$5
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result.version.valueBlock.valueDec;
        this.privateKeyAlgorithm = new AlgorithmIdentifier({
          schema: asn1.result.privateKeyAlgorithm
        });
        this.privateKey = asn1.result.privateKey;
        if (ATTRIBUTES$5 in asn1.result) this.attributes = Array.from(asn1.result.attributes, function (element) {
          return new Attribute({
            schema: element
          });
        });
        switch (this.privateKeyAlgorithm.algorithmId) {
          case "1.2.840.113549.1.1.1":
            {
              var privateKeyASN1 = _fromBER(this.privateKey.valueBlock.valueHexView);
              if (privateKeyASN1.offset !== -1) this.parsedKey = new RSAPrivateKey({
                schema: privateKeyASN1.result
              });
            }
            break;
          case "1.2.840.10045.2.1":
            if ("algorithmParams" in this.privateKeyAlgorithm) {
              if (this.privateKeyAlgorithm.algorithmParams instanceof ObjectIdentifier) {
                var _privateKeyASN = _fromBER(this.privateKey.valueBlock.valueHexView);
                if (_privateKeyASN.offset !== -1) {
                  this.parsedKey = new ECPrivateKey({
                    namedCurve: this.privateKeyAlgorithm.algorithmParams.valueBlock.toString(),
                    schema: _privateKeyASN.result
                  });
                }
              }
            }
            break;
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [new Integer({
          value: this.version
        }), this.privateKeyAlgorithm.toSchema(), this.privateKey];
        if (this.attributes) {
          outputArray.push(new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: Array.from(this.attributes, function (o) {
              return o.toSchema();
            })
          }));
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        if (!this.parsedKey) {
          var object = {
            version: this.version,
            privateKeyAlgorithm: this.privateKeyAlgorithm.toJSON(),
            privateKey: this.privateKey.toJSON()
          };
          if (this.attributes) {
            object.attributes = Array.from(this.attributes, function (o) {
              return o.toJSON();
            });
          }
          return object;
        }
        var jwk = {};
        switch (this.privateKeyAlgorithm.algorithmId) {
          case "1.2.840.10045.2.1":
            jwk.kty = "EC";
            break;
          case "1.2.840.113549.1.1.1":
            jwk.kty = "RSA";
            break;
        }
        var publicKeyJWK = this.parsedKey.toJSON();
        Object.assign(jwk, publicKeyJWK);
        return jwk;
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(json) {
        if ("kty" in json) {
          switch (json.kty.toUpperCase()) {
            case "EC":
              this.parsedKey = new ECPrivateKey({
                json: json
              });
              this.privateKeyAlgorithm = new AlgorithmIdentifier({
                algorithmId: "1.2.840.10045.2.1",
                algorithmParams: new ObjectIdentifier({
                  value: this.parsedKey.namedCurve
                })
              });
              break;
            case "RSA":
              this.parsedKey = new RSAPrivateKey({
                json: json
              });
              this.privateKeyAlgorithm = new AlgorithmIdentifier({
                algorithmId: "1.2.840.113549.1.1.1",
                algorithmParams: new Null()
              });
              break;
            default:
              throw new Error("Invalid value for \"kty\" parameter: ".concat(json.kty));
          }
          this.privateKey = new OctetString({
            valueHex: this.parsedKey.toSchema().toBER(false)
          });
        }
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case VERSION$j:
            return 0;
          case PRIVATE_KEY_ALGORITHM:
            return new AlgorithmIdentifier();
          case PRIVATE_KEY:
            return new OctetString();
          case ATTRIBUTES$5:
            return [];
          case PARSED_KEY:
            return {};
          default:
            return _superPropGet(PrivateKeyInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Integer({
            name: names.version || EMPTY_STRING
          }), AlgorithmIdentifier.schema(names.privateKeyAlgorithm || {}), new OctetString({
            name: names.privateKey || EMPTY_STRING
          }), new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [new Repeated({
              name: names.attributes || EMPTY_STRING,
              value: Attribute.schema()
            })]
          })]
        });
      }
    }]);
  }(PkiObject);
  PrivateKeyInfo.CLASS_NAME = "PrivateKeyInfo";
  var CONTENT_TYPE$1 = "contentType";
  var CONTENT_ENCRYPTION_ALGORITHM = "contentEncryptionAlgorithm";
  var ENCRYPTED_CONTENT = "encryptedContent";
  var CLEAR_PROPS$15 = [CONTENT_TYPE$1, CONTENT_ENCRYPTION_ALGORITHM, ENCRYPTED_CONTENT];
  var PIECE_SIZE = 1024;
  var EncryptedContentInfo = function (_PkiObject38) {
    function EncryptedContentInfo() {
      var _this97;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, EncryptedContentInfo);
      _this97 = _callSuper(this, EncryptedContentInfo);
      _this97.contentType = getParametersValue(parameters, CONTENT_TYPE$1, EncryptedContentInfo.defaultValues(CONTENT_TYPE$1));
      _this97.contentEncryptionAlgorithm = getParametersValue(parameters, CONTENT_ENCRYPTION_ALGORITHM, EncryptedContentInfo.defaultValues(CONTENT_ENCRYPTION_ALGORITHM));
      if (ENCRYPTED_CONTENT in parameters && parameters.encryptedContent) {
        _this97.encryptedContent = parameters.encryptedContent;
        if (_this97.encryptedContent.idBlock.tagClass === 1 && _this97.encryptedContent.idBlock.tagNumber === 4) {
          if (_this97.encryptedContent.idBlock.isConstructed === false && !parameters.disableSplit) {
            var constrString = new OctetString({
              idBlock: {
                isConstructed: true
              },
              isConstructed: true
            });
            var offset = 0;
            var valueHex = _this97.encryptedContent.valueBlock.valueHexView.slice().buffer;
            var length = valueHex.byteLength;
            while (length > 0) {
              var pieceView = new Uint8Array(valueHex, offset, offset + PIECE_SIZE > valueHex.byteLength ? valueHex.byteLength - offset : PIECE_SIZE);
              var _array = new ArrayBuffer(pieceView.length);
              var _view = new Uint8Array(_array);
              for (var i = 0; i < _view.length; i++) _view[i] = pieceView[i];
              constrString.valueBlock.value.push(new OctetString({
                valueHex: _array
              }));
              length -= pieceView.length;
              offset += pieceView.length;
            }
            _this97.encryptedContent = constrString;
          }
        }
      }
      if (parameters.schema) {
        _this97.fromSchema(parameters.schema);
      }
      return _this97;
    }
    _inherits(EncryptedContentInfo, _PkiObject38);
    return _createClass(EncryptedContentInfo, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$15);
        var asn1 = compareSchema(schema, schema, EncryptedContentInfo.schema({
          names: {
            contentType: CONTENT_TYPE$1,
            contentEncryptionAlgorithm: {
              names: {
                blockName: CONTENT_ENCRYPTION_ALGORITHM
              }
            },
            encryptedContent: ENCRYPTED_CONTENT
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.contentType = asn1.result.contentType.valueBlock.toString();
        this.contentEncryptionAlgorithm = new AlgorithmIdentifier({
          schema: asn1.result.contentEncryptionAlgorithm
        });
        if (ENCRYPTED_CONTENT in asn1.result) {
          this.encryptedContent = asn1.result.encryptedContent;
          this.encryptedContent.idBlock.tagClass = 1;
          this.encryptedContent.idBlock.tagNumber = 4;
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var sequenceLengthBlock = {
          isIndefiniteForm: false
        };
        var outputArray = [];
        outputArray.push(new ObjectIdentifier({
          value: this.contentType
        }));
        outputArray.push(this.contentEncryptionAlgorithm.toSchema());
        if (this.encryptedContent) {
          sequenceLengthBlock.isIndefiniteForm = this.encryptedContent.idBlock.isConstructed;
          var encryptedValue = this.encryptedContent;
          encryptedValue.idBlock.tagClass = 3;
          encryptedValue.idBlock.tagNumber = 0;
          encryptedValue.lenBlock.isIndefiniteForm = this.encryptedContent.idBlock.isConstructed;
          outputArray.push(encryptedValue);
        }
        return new Sequence({
          lenBlock: sequenceLengthBlock,
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          contentType: this.contentType,
          contentEncryptionAlgorithm: this.contentEncryptionAlgorithm.toJSON()
        };
        if (this.encryptedContent) {
          res.encryptedContent = this.encryptedContent.toJSON();
        }
        return res;
      }
    }, {
      key: "getEncryptedContent",
      value: function getEncryptedContent() {
        if (!this.encryptedContent) {
          throw new Error("Parameter 'encryptedContent' is undefined");
        }
        return OctetString.prototype.getValue.call(this.encryptedContent);
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case CONTENT_TYPE$1:
            return EMPTY_STRING;
          case CONTENT_ENCRYPTION_ALGORITHM:
            return new AlgorithmIdentifier();
          case ENCRYPTED_CONTENT:
            return new OctetString();
          default:
            return _superPropGet(EncryptedContentInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case CONTENT_TYPE$1:
            return memberValue === EMPTY_STRING;
          case CONTENT_ENCRYPTION_ALGORITHM:
            return memberValue.algorithmId === EMPTY_STRING && "algorithmParams" in memberValue === false;
          case ENCRYPTED_CONTENT:
            return memberValue.isEqual(EncryptedContentInfo.defaultValues(ENCRYPTED_CONTENT));
          default:
            return _superPropGet(EncryptedContentInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new ObjectIdentifier({
            name: names.contentType || EMPTY_STRING
          }), AlgorithmIdentifier.schema(names.contentEncryptionAlgorithm || {}), new Choice({
            value: [new Constructed({
              name: names.encryptedContent || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [new Repeated({
                value: new OctetString()
              })]
            }), new Primitive({
              name: names.encryptedContent || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              }
            })]
          })]
        });
      }
    }]);
  }(PkiObject);
  EncryptedContentInfo.CLASS_NAME = "EncryptedContentInfo";
  var HASH_ALGORITHM$4 = "hashAlgorithm";
  var MASK_GEN_ALGORITHM$1 = "maskGenAlgorithm";
  var SALT_LENGTH = "saltLength";
  var TRAILER_FIELD = "trailerField";
  var CLEAR_PROPS$14 = [HASH_ALGORITHM$4, MASK_GEN_ALGORITHM$1, SALT_LENGTH, TRAILER_FIELD];
  var RSASSAPSSParams = function (_PkiObject39) {
    function RSASSAPSSParams() {
      var _this98;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, RSASSAPSSParams);
      _this98 = _callSuper(this, RSASSAPSSParams);
      _this98.hashAlgorithm = getParametersValue(parameters, HASH_ALGORITHM$4, RSASSAPSSParams.defaultValues(HASH_ALGORITHM$4));
      _this98.maskGenAlgorithm = getParametersValue(parameters, MASK_GEN_ALGORITHM$1, RSASSAPSSParams.defaultValues(MASK_GEN_ALGORITHM$1));
      _this98.saltLength = getParametersValue(parameters, SALT_LENGTH, RSASSAPSSParams.defaultValues(SALT_LENGTH));
      _this98.trailerField = getParametersValue(parameters, TRAILER_FIELD, RSASSAPSSParams.defaultValues(TRAILER_FIELD));
      if (parameters.schema) {
        _this98.fromSchema(parameters.schema);
      }
      return _this98;
    }
    _inherits(RSASSAPSSParams, _PkiObject39);
    return _createClass(RSASSAPSSParams, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$14);
        var asn1 = compareSchema(schema, schema, RSASSAPSSParams.schema({
          names: {
            hashAlgorithm: {
              names: {
                blockName: HASH_ALGORITHM$4
              }
            },
            maskGenAlgorithm: {
              names: {
                blockName: MASK_GEN_ALGORITHM$1
              }
            },
            saltLength: SALT_LENGTH,
            trailerField: TRAILER_FIELD
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (HASH_ALGORITHM$4 in asn1.result) this.hashAlgorithm = new AlgorithmIdentifier({
          schema: asn1.result.hashAlgorithm
        });
        if (MASK_GEN_ALGORITHM$1 in asn1.result) this.maskGenAlgorithm = new AlgorithmIdentifier({
          schema: asn1.result.maskGenAlgorithm
        });
        if (SALT_LENGTH in asn1.result) this.saltLength = asn1.result.saltLength.valueBlock.valueDec;
        if (TRAILER_FIELD in asn1.result) this.trailerField = asn1.result.trailerField.valueBlock.valueDec;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        if (!this.hashAlgorithm.isEqual(RSASSAPSSParams.defaultValues(HASH_ALGORITHM$4))) {
          outputArray.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [this.hashAlgorithm.toSchema()]
          }));
        }
        if (!this.maskGenAlgorithm.isEqual(RSASSAPSSParams.defaultValues(MASK_GEN_ALGORITHM$1))) {
          outputArray.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: [this.maskGenAlgorithm.toSchema()]
          }));
        }
        if (this.saltLength !== RSASSAPSSParams.defaultValues(SALT_LENGTH)) {
          outputArray.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 2
            },
            value: [new Integer({
              value: this.saltLength
            })]
          }));
        }
        if (this.trailerField !== RSASSAPSSParams.defaultValues(TRAILER_FIELD)) {
          outputArray.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 3
            },
            value: [new Integer({
              value: this.trailerField
            })]
          }));
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {};
        if (!this.hashAlgorithm.isEqual(RSASSAPSSParams.defaultValues(HASH_ALGORITHM$4))) {
          res.hashAlgorithm = this.hashAlgorithm.toJSON();
        }
        if (!this.maskGenAlgorithm.isEqual(RSASSAPSSParams.defaultValues(MASK_GEN_ALGORITHM$1))) {
          res.maskGenAlgorithm = this.maskGenAlgorithm.toJSON();
        }
        if (this.saltLength !== RSASSAPSSParams.defaultValues(SALT_LENGTH)) {
          res.saltLength = this.saltLength;
        }
        if (this.trailerField !== RSASSAPSSParams.defaultValues(TRAILER_FIELD)) {
          res.trailerField = this.trailerField;
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case HASH_ALGORITHM$4:
            return new AlgorithmIdentifier({
              algorithmId: "1.3.14.3.2.26",
              algorithmParams: new Null()
            });
          case MASK_GEN_ALGORITHM$1:
            return new AlgorithmIdentifier({
              algorithmId: "1.2.840.113549.1.1.8",
              algorithmParams: new AlgorithmIdentifier({
                algorithmId: "1.3.14.3.2.26",
                algorithmParams: new Null()
              }).toSchema()
            });
          case SALT_LENGTH:
            return 20;
          case TRAILER_FIELD:
            return 1;
          default:
            return _superPropGet(RSASSAPSSParams, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            optional: true,
            value: [AlgorithmIdentifier.schema(names.hashAlgorithm || {})]
          }), new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            optional: true,
            value: [AlgorithmIdentifier.schema(names.maskGenAlgorithm || {})]
          }), new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 2
            },
            optional: true,
            value: [new Integer({
              name: names.saltLength || EMPTY_STRING
            })]
          }), new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 3
            },
            optional: true,
            value: [new Integer({
              name: names.trailerField || EMPTY_STRING
            })]
          })]
        });
      }
    }]);
  }(PkiObject);
  RSASSAPSSParams.CLASS_NAME = "RSASSAPSSParams";
  var SALT = "salt";
  var ITERATION_COUNT = "iterationCount";
  var KEY_LENGTH = "keyLength";
  var PRF = "prf";
  var CLEAR_PROPS$13 = [SALT, ITERATION_COUNT, KEY_LENGTH, PRF];
  var PBKDF2Params = function (_PkiObject40) {
    function PBKDF2Params() {
      var _this99;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, PBKDF2Params);
      _this99 = _callSuper(this, PBKDF2Params);
      _this99.salt = getParametersValue(parameters, SALT, PBKDF2Params.defaultValues(SALT));
      _this99.iterationCount = getParametersValue(parameters, ITERATION_COUNT, PBKDF2Params.defaultValues(ITERATION_COUNT));
      if (KEY_LENGTH in parameters) {
        _this99.keyLength = getParametersValue(parameters, KEY_LENGTH, PBKDF2Params.defaultValues(KEY_LENGTH));
      }
      if (PRF in parameters) {
        _this99.prf = getParametersValue(parameters, PRF, PBKDF2Params.defaultValues(PRF));
      }
      if (parameters.schema) {
        _this99.fromSchema(parameters.schema);
      }
      return _this99;
    }
    _inherits(PBKDF2Params, _PkiObject40);
    return _createClass(PBKDF2Params, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$13);
        var asn1 = compareSchema(schema, schema, PBKDF2Params.schema({
          names: {
            saltPrimitive: SALT,
            saltConstructed: {
              names: {
                blockName: SALT
              }
            },
            iterationCount: ITERATION_COUNT,
            keyLength: KEY_LENGTH,
            prf: {
              names: {
                blockName: PRF,
                optional: true
              }
            }
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.salt = asn1.result.salt;
        this.iterationCount = asn1.result.iterationCount.valueBlock.valueDec;
        if (KEY_LENGTH in asn1.result) this.keyLength = asn1.result.keyLength.valueBlock.valueDec;
        if (PRF in asn1.result) this.prf = new AlgorithmIdentifier({
          schema: asn1.result.prf
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        outputArray.push(this.salt);
        outputArray.push(new Integer({
          value: this.iterationCount
        }));
        if (KEY_LENGTH in this) {
          if (PBKDF2Params.defaultValues(KEY_LENGTH) !== this.keyLength) outputArray.push(new Integer({
            value: this.keyLength
          }));
        }
        if (this.prf) {
          if (PBKDF2Params.defaultValues(PRF).isEqual(this.prf) === false) outputArray.push(this.prf.toSchema());
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          salt: this.salt.toJSON(),
          iterationCount: this.iterationCount
        };
        if (KEY_LENGTH in this) {
          if (PBKDF2Params.defaultValues(KEY_LENGTH) !== this.keyLength) res.keyLength = this.keyLength;
        }
        if (this.prf) {
          if (PBKDF2Params.defaultValues(PRF).isEqual(this.prf) === false) res.prf = this.prf.toJSON();
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case SALT:
            return {};
          case ITERATION_COUNT:
            return -1;
          case KEY_LENGTH:
            return 0;
          case PRF:
            return new AlgorithmIdentifier({
              algorithmId: "1.3.14.3.2.26",
              algorithmParams: new Null()
            });
          default:
            return _superPropGet(PBKDF2Params, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Choice({
            value: [new OctetString({
              name: names.saltPrimitive || EMPTY_STRING
            }), AlgorithmIdentifier.schema(names.saltConstructed || {})]
          }), new Integer({
            name: names.iterationCount || EMPTY_STRING
          }), new Integer({
            name: names.keyLength || EMPTY_STRING,
            optional: true
          }), AlgorithmIdentifier.schema(names.prf || {
            names: {
              optional: true
            }
          })]
        });
      }
    }]);
  }(PkiObject);
  PBKDF2Params.CLASS_NAME = "PBKDF2Params";
  var KEY_DERIVATION_FUNC = "keyDerivationFunc";
  var ENCRYPTION_SCHEME = "encryptionScheme";
  var CLEAR_PROPS$12 = [KEY_DERIVATION_FUNC, ENCRYPTION_SCHEME];
  var PBES2Params = function (_PkiObject41) {
    function PBES2Params() {
      var _this100;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, PBES2Params);
      _this100 = _callSuper(this, PBES2Params);
      _this100.keyDerivationFunc = getParametersValue(parameters, KEY_DERIVATION_FUNC, PBES2Params.defaultValues(KEY_DERIVATION_FUNC));
      _this100.encryptionScheme = getParametersValue(parameters, ENCRYPTION_SCHEME, PBES2Params.defaultValues(ENCRYPTION_SCHEME));
      if (parameters.schema) {
        _this100.fromSchema(parameters.schema);
      }
      return _this100;
    }
    _inherits(PBES2Params, _PkiObject41);
    return _createClass(PBES2Params, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$12);
        var asn1 = compareSchema(schema, schema, PBES2Params.schema({
          names: {
            keyDerivationFunc: {
              names: {
                blockName: KEY_DERIVATION_FUNC
              }
            },
            encryptionScheme: {
              names: {
                blockName: ENCRYPTION_SCHEME
              }
            }
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.keyDerivationFunc = new AlgorithmIdentifier({
          schema: asn1.result.keyDerivationFunc
        });
        this.encryptionScheme = new AlgorithmIdentifier({
          schema: asn1.result.encryptionScheme
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: [this.keyDerivationFunc.toSchema(), this.encryptionScheme.toSchema()]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          keyDerivationFunc: this.keyDerivationFunc.toJSON(),
          encryptionScheme: this.encryptionScheme.toJSON()
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case KEY_DERIVATION_FUNC:
            return new AlgorithmIdentifier();
          case ENCRYPTION_SCHEME:
            return new AlgorithmIdentifier();
          default:
            return _superPropGet(PBES2Params, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [AlgorithmIdentifier.schema(names.keyDerivationFunc || {}), AlgorithmIdentifier.schema(names.encryptionScheme || {})]
        });
      }
    }]);
  }(PkiObject);
  PBES2Params.CLASS_NAME = "PBES2Params";
  var AbstractCryptoEngine = function () {
    function AbstractCryptoEngine(parameters) {
      _classCallCheck(this, AbstractCryptoEngine);
      this.crypto = parameters.crypto;
      this.subtle = "webkitSubtle" in parameters.crypto ? parameters.crypto.webkitSubtle : parameters.crypto.subtle;
      this.name = getParametersValue(parameters, "name", EMPTY_STRING);
    }
    return _createClass(AbstractCryptoEngine, [{
      key: "encrypt",
      value: function () {
        var _encrypt = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2() {
          var _this$subtle;
          var _args2 = arguments;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", (_this$subtle = this.subtle).encrypt.apply(_this$subtle, _args2));
              case 1:
              case "end":
                return _context2.stop();
            }
          }, _callee2, this);
        }));
        function encrypt() {
          return _encrypt.apply(this, arguments);
        }
        return encrypt;
      }()
    }, {
      key: "decrypt",
      value: function () {
        var _decrypt = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3() {
          var _this$subtle2;
          var _args3 = arguments;
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", (_this$subtle2 = this.subtle).decrypt.apply(_this$subtle2, _args3));
              case 1:
              case "end":
                return _context3.stop();
            }
          }, _callee3, this);
        }));
        function decrypt() {
          return _decrypt.apply(this, arguments);
        }
        return decrypt;
      }()
    }, {
      key: "sign",
      value: function sign() {
        var _this$subtle3;
        return (_this$subtle3 = this.subtle).sign.apply(_this$subtle3, arguments);
      }
    }, {
      key: "verify",
      value: function () {
        var _verify = _asyncToGenerator(_regeneratorRuntime().mark(function _callee4() {
          var _this$subtle4;
          var _args4 = arguments;
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                return _context4.abrupt("return", (_this$subtle4 = this.subtle).verify.apply(_this$subtle4, _args4));
              case 1:
              case "end":
                return _context4.stop();
            }
          }, _callee4, this);
        }));
        function verify() {
          return _verify.apply(this, arguments);
        }
        return verify;
      }()
    }, {
      key: "digest",
      value: function () {
        var _digest = _asyncToGenerator(_regeneratorRuntime().mark(function _callee5() {
          var _this$subtle5;
          var _args5 = arguments;
          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) switch (_context5.prev = _context5.next) {
              case 0:
                return _context5.abrupt("return", (_this$subtle5 = this.subtle).digest.apply(_this$subtle5, _args5));
              case 1:
              case "end":
                return _context5.stop();
            }
          }, _callee5, this);
        }));
        function digest() {
          return _digest.apply(this, arguments);
        }
        return digest;
      }()
    }, {
      key: "generateKey",
      value: function () {
        var _generateKey = _asyncToGenerator(_regeneratorRuntime().mark(function _callee6() {
          var _this$subtle6;
          var _args6 = arguments;
          return _regeneratorRuntime().wrap(function _callee6$(_context6) {
            while (1) switch (_context6.prev = _context6.next) {
              case 0:
                return _context6.abrupt("return", (_this$subtle6 = this.subtle).generateKey.apply(_this$subtle6, _args6));
              case 1:
              case "end":
                return _context6.stop();
            }
          }, _callee6, this);
        }));
        function generateKey() {
          return _generateKey.apply(this, arguments);
        }
        return generateKey;
      }()
    }, {
      key: "deriveKey",
      value: function () {
        var _deriveKey = _asyncToGenerator(_regeneratorRuntime().mark(function _callee7() {
          var _this$subtle7;
          var _args7 = arguments;
          return _regeneratorRuntime().wrap(function _callee7$(_context7) {
            while (1) switch (_context7.prev = _context7.next) {
              case 0:
                return _context7.abrupt("return", (_this$subtle7 = this.subtle).deriveKey.apply(_this$subtle7, _args7));
              case 1:
              case "end":
                return _context7.stop();
            }
          }, _callee7, this);
        }));
        function deriveKey() {
          return _deriveKey.apply(this, arguments);
        }
        return deriveKey;
      }()
    }, {
      key: "deriveBits",
      value: function () {
        var _deriveBits = _asyncToGenerator(_regeneratorRuntime().mark(function _callee8() {
          var _this$subtle8;
          var _args8 = arguments;
          return _regeneratorRuntime().wrap(function _callee8$(_context8) {
            while (1) switch (_context8.prev = _context8.next) {
              case 0:
                return _context8.abrupt("return", (_this$subtle8 = this.subtle).deriveBits.apply(_this$subtle8, _args8));
              case 1:
              case "end":
                return _context8.stop();
            }
          }, _callee8, this);
        }));
        function deriveBits() {
          return _deriveBits.apply(this, arguments);
        }
        return deriveBits;
      }()
    }, {
      key: "wrapKey",
      value: function () {
        var _wrapKey = _asyncToGenerator(_regeneratorRuntime().mark(function _callee9() {
          var _this$subtle9;
          var _args9 = arguments;
          return _regeneratorRuntime().wrap(function _callee9$(_context9) {
            while (1) switch (_context9.prev = _context9.next) {
              case 0:
                return _context9.abrupt("return", (_this$subtle9 = this.subtle).wrapKey.apply(_this$subtle9, _args9));
              case 1:
              case "end":
                return _context9.stop();
            }
          }, _callee9, this);
        }));
        function wrapKey() {
          return _wrapKey.apply(this, arguments);
        }
        return wrapKey;
      }()
    }, {
      key: "unwrapKey",
      value: function () {
        var _unwrapKey = _asyncToGenerator(_regeneratorRuntime().mark(function _callee10() {
          var _this$subtle10;
          var _args10 = arguments;
          return _regeneratorRuntime().wrap(function _callee10$(_context10) {
            while (1) switch (_context10.prev = _context10.next) {
              case 0:
                return _context10.abrupt("return", (_this$subtle10 = this.subtle).unwrapKey.apply(_this$subtle10, _args10));
              case 1:
              case "end":
                return _context10.stop();
            }
          }, _callee10, this);
        }));
        function unwrapKey() {
          return _unwrapKey.apply(this, arguments);
        }
        return unwrapKey;
      }()
    }, {
      key: "exportKey",
      value: function exportKey() {
        var _this$subtle11;
        return (_this$subtle11 = this.subtle).exportKey.apply(_this$subtle11, arguments);
      }
    }, {
      key: "importKey",
      value: function importKey() {
        var _this$subtle12;
        return (_this$subtle12 = this.subtle).importKey.apply(_this$subtle12, arguments);
      }
    }, {
      key: "getRandomValues",
      value: function getRandomValues(array) {
        return this.crypto.getRandomValues(array);
      }
    }]);
  }();
  function makePKCS12B2Key(_x2, _x3, _x4, _x5, _x6) {
    return _makePKCS12B2Key.apply(this, arguments);
  }
  function _makePKCS12B2Key() {
    _makePKCS12B2Key = _asyncToGenerator(_regeneratorRuntime().mark(function _callee101(hashAlgorithm, keyLength, password, salt, iterationCount) {
      var u, v, md, originalPassword, decodedPassword, encodedPassword, passwordTransformed, passwordView, i, D, saltView, S, P, I, c, result, _loop, _i48;
      return _regeneratorRuntime().wrap(function _callee101$(_context102) {
        while (1) switch (_context102.prev = _context102.next) {
          case 0:
            _context102.t0 = hashAlgorithm.toUpperCase();
            _context102.next = _context102.t0 === "SHA-1" ? 3 : _context102.t0 === "SHA-256" ? 7 : _context102.t0 === "SHA-384" ? 11 : _context102.t0 === "SHA-512" ? 15 : 19;
            break;
          case 3:
            u = 20;
            v = 64;
            md = sha1;
            return _context102.abrupt("break", 20);
          case 7:
            u = 32;
            v = 64;
            md = sha256;
            return _context102.abrupt("break", 20);
          case 11:
            u = 48;
            v = 128;
            md = sha384;
            return _context102.abrupt("break", 20);
          case 15:
            u = 64;
            v = 128;
            md = sha512;
            return _context102.abrupt("break", 20);
          case 19:
            throw new Error("Unsupported hashing algorithm");
          case 20:
            originalPassword = new Uint8Array(password);
            decodedPassword = new TextDecoder().decode(password);
            encodedPassword = new TextEncoder().encode(decodedPassword);
            if (encodedPassword.some(function (byte, i) {
              return byte !== originalPassword[i];
            })) {
              decodedPassword = String.fromCharCode.apply(String, _toConsumableArray(originalPassword));
            }
            passwordTransformed = new Uint8Array(decodedPassword.length * 2 + 2);
            passwordView = new DataView(passwordTransformed.buffer);
            for (i = 0; i < decodedPassword.length; i++) {
              passwordView.setUint16(i * 2, decodedPassword.charCodeAt(i), false);
            }
            passwordView.setUint16(decodedPassword.length * 2, 0, false);
            D = new Uint8Array(v).fill(3);
            saltView = new Uint8Array(salt);
            S = new Uint8Array(v * Math.ceil(saltView.length / v)).map(function (_, i) {
              return saltView[i % saltView.length];
            });
            P = new Uint8Array(v * Math.ceil(passwordTransformed.length / v)).map(function (_, i) {
              return passwordTransformed[i % passwordTransformed.length];
            });
            I = new Uint8Array(S.length + P.length);
            I.set(S);
            I.set(P, S.length);
            c = Math.ceil((keyLength >> 3) / u);
            result = [];
            _loop = _regeneratorRuntime().mark(function _loop() {
              var A, j, B, k, iRound, _j12, chunk, x, l;
              return _regeneratorRuntime().wrap(function _loop$(_context101) {
                while (1) switch (_context101.prev = _context101.next) {
                  case 0:
                    A = new Uint8Array(D.length + I.length);
                    A.set(D);
                    A.set(I, D.length);
                    for (j = 0; j < iterationCount; j++) {
                      A = md(A);
                    }
                    B = new Uint8Array(v).map(function (_, i) {
                      return A[i % A.length];
                    });
                    k = Math.ceil(saltView.length / v) + Math.ceil(passwordTransformed.length / v);
                    iRound = [];
                    for (_j12 = 0; _j12 < k; _j12++) {
                      chunk = Array.from(I.slice(_j12 * v, (_j12 + 1) * v));
                      x = 0x1ff;
                      for (l = B.length - 1; l >= 0; l--) {
                        x >>= 8;
                        x += B[l] + (chunk[l] || 0);
                        chunk[l] = x & 0xff;
                      }
                      iRound.push.apply(iRound, chunk);
                    }
                    I = new Uint8Array(iRound);
                    result.push.apply(result, _toConsumableArray(A));
                  case 10:
                  case "end":
                    return _context101.stop();
                }
              }, _loop);
            });
            _i48 = 0;
          case 39:
            if (!(_i48 < c)) {
              _context102.next = 44;
              break;
            }
            return _context102.delegateYield(_loop(), "t1", 41);
          case 41:
            _i48++;
            _context102.next = 39;
            break;
          case 44:
            return _context102.abrupt("return", new Uint8Array(result.slice(0, keyLength >> 3)).buffer);
          case 45:
          case "end":
            return _context102.stop();
        }
      }, _callee101);
    }));
    return _makePKCS12B2Key.apply(this, arguments);
  }
  function prepareAlgorithm(data) {
    var res = typeof data === "string" ? {
      name: data
    } : data;
    if ("hash" in res) {
      return _objectSpread2(_objectSpread2({}, res), {}, {
        hash: prepareAlgorithm(res.hash)
      });
    }
    return res;
  }
  var CryptoEngine = function (_AbstractCryptoEngine) {
    function CryptoEngine() {
      _classCallCheck(this, CryptoEngine);
      return _callSuper(this, CryptoEngine, arguments);
    }
    _inherits(CryptoEngine, _AbstractCryptoEngine);
    return _createClass(CryptoEngine, [{
      key: "importKey",
      value: function () {
        var _importKey2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee11(format, keyData, algorithm, extractable, keyUsages) {
          var _a, _b, _c, _d, _e, _f, jwk, alg, asn1, publicKeyInfo, publicKeyJSON, _publicKeyJSON, _publicKeyJSON2, _publicKeyJSON3, privateKeyInfo, _asn, privateKeyJSON, _privateKeyJSON, _privateKeyJSON2, _privateKeyJSON3;
          return _regeneratorRuntime().wrap(function _callee11$(_context11) {
            while (1) switch (_context11.prev = _context11.next) {
              case 0:
                jwk = {};
                alg = prepareAlgorithm(algorithm);
                _context11.t0 = format.toLowerCase();
                _context11.next = _context11.t0 === "raw" ? 5 : _context11.t0 === "spki" ? 6 : _context11.t0 === "pkcs8" ? 97 : _context11.t0 === "jwk" ? 185 : 187;
                break;
              case 5:
                return _context11.abrupt("return", this.subtle.importKey("raw", keyData, algorithm, extractable, keyUsages));
              case 6:
                asn1 = _fromBER(BufferSourceConverter.toArrayBuffer(keyData));
                AsnError.assert(asn1, "keyData");
                publicKeyInfo = new PublicKeyInfo();
                _context11.prev = 9;
                publicKeyInfo.fromSchema(asn1.result);
                _context11.next = 16;
                break;
              case 13:
                _context11.prev = 13;
                _context11.t1 = _context11["catch"](9);
                throw new ArgumentError("Incorrect keyData");
              case 16:
                _context11.t2 = alg.name.toUpperCase();
                _context11.next = _context11.t2 === "RSA-PSS" ? 19 : _context11.t2 === "RSASSA-PKCS1-V1_5" ? 33 : _context11.t2 === "ECDSA" ? 57 : _context11.t2 === "ECDH" ? 58 : _context11.t2 === "RSA-OAEP" ? 64 : _context11.t2 === "RSAES-PKCS1-V1_5" ? 88 : 95;
                break;
              case 19:
                if (alg.hash) {
                  _context11.next = 21;
                  break;
                }
                throw new ParameterError("hash", "algorithm.hash", "Incorrect hash algorithm: Hash algorithm is missed");
              case 21:
                _context11.t3 = alg.hash.name.toUpperCase();
                _context11.next = _context11.t3 === "SHA-1" ? 24 : _context11.t3 === "SHA-256" ? 26 : _context11.t3 === "SHA-384" ? 28 : _context11.t3 === "SHA-512" ? 30 : 32;
                break;
              case 24:
                jwk.alg = "PS1";
                return _context11.abrupt("break", 33);
              case 26:
                jwk.alg = "PS256";
                return _context11.abrupt("break", 33);
              case 28:
                jwk.alg = "PS384";
                return _context11.abrupt("break", 33);
              case 30:
                jwk.alg = "PS512";
                return _context11.abrupt("break", 33);
              case 32:
                throw new Error("Incorrect hash algorithm: ".concat(alg.hash.name.toUpperCase()));
              case 33:
                keyUsages = ["verify"];
                jwk.kty = "RSA";
                jwk.ext = extractable;
                jwk.key_ops = keyUsages;
                if (!(publicKeyInfo.algorithm.algorithmId !== "1.2.840.113549.1.1.1")) {
                  _context11.next = 39;
                  break;
                }
                throw new Error("Incorrect public key algorithm: ".concat(publicKeyInfo.algorithm.algorithmId));
              case 39:
                if (jwk.alg) {
                  _context11.next = 54;
                  break;
                }
                if (alg.hash) {
                  _context11.next = 42;
                  break;
                }
                throw new ParameterError("hash", "algorithm.hash", "Incorrect hash algorithm: Hash algorithm is missed");
              case 42:
                _context11.t4 = alg.hash.name.toUpperCase();
                _context11.next = _context11.t4 === "SHA-1" ? 45 : _context11.t4 === "SHA-256" ? 47 : _context11.t4 === "SHA-384" ? 49 : _context11.t4 === "SHA-512" ? 51 : 53;
                break;
              case 45:
                jwk.alg = "RS1";
                return _context11.abrupt("break", 54);
              case 47:
                jwk.alg = "RS256";
                return _context11.abrupt("break", 54);
              case 49:
                jwk.alg = "RS384";
                return _context11.abrupt("break", 54);
              case 51:
                jwk.alg = "RS512";
                return _context11.abrupt("break", 54);
              case 53:
                throw new Error("Incorrect hash algorithm: ".concat(alg.hash.name.toUpperCase()));
              case 54:
                publicKeyJSON = publicKeyInfo.toJSON();
                Object.assign(jwk, publicKeyJSON);
                return _context11.abrupt("break", 96);
              case 57:
                keyUsages = ["verify"];
              case 58:
                jwk = {
                  kty: "EC",
                  ext: extractable,
                  key_ops: keyUsages
                };
                if (!(publicKeyInfo.algorithm.algorithmId !== "1.2.840.10045.2.1")) {
                  _context11.next = 61;
                  break;
                }
                throw new Error("Incorrect public key algorithm: ".concat(publicKeyInfo.algorithm.algorithmId));
              case 61:
                _publicKeyJSON = publicKeyInfo.toJSON();
                Object.assign(jwk, _publicKeyJSON);
                return _context11.abrupt("break", 96);
              case 64:
                jwk.kty = "RSA";
                jwk.ext = extractable;
                jwk.key_ops = keyUsages;
                if (!(this.name.toLowerCase() === "safari")) {
                  _context11.next = 71;
                  break;
                }
                jwk.alg = "RSA-OAEP";
                _context11.next = 85;
                break;
              case 71:
                if (alg.hash) {
                  _context11.next = 73;
                  break;
                }
                throw new ParameterError("hash", "algorithm.hash", "Incorrect hash algorithm: Hash algorithm is missed");
              case 73:
                _context11.t5 = alg.hash.name.toUpperCase();
                _context11.next = _context11.t5 === "SHA-1" ? 76 : _context11.t5 === "SHA-256" ? 78 : _context11.t5 === "SHA-384" ? 80 : _context11.t5 === "SHA-512" ? 82 : 84;
                break;
              case 76:
                jwk.alg = "RSA-OAEP";
                return _context11.abrupt("break", 85);
              case 78:
                jwk.alg = "RSA-OAEP-256";
                return _context11.abrupt("break", 85);
              case 80:
                jwk.alg = "RSA-OAEP-384";
                return _context11.abrupt("break", 85);
              case 82:
                jwk.alg = "RSA-OAEP-512";
                return _context11.abrupt("break", 85);
              case 84:
                throw new Error("Incorrect hash algorithm: ".concat(alg.hash.name.toUpperCase()));
              case 85:
                _publicKeyJSON2 = publicKeyInfo.toJSON();
                Object.assign(jwk, _publicKeyJSON2);
                return _context11.abrupt("break", 96);
              case 88:
                jwk.kty = "RSA";
                jwk.ext = extractable;
                jwk.key_ops = keyUsages;
                jwk.alg = "PS1";
                _publicKeyJSON3 = publicKeyInfo.toJSON();
                Object.assign(jwk, _publicKeyJSON3);
                return _context11.abrupt("break", 96);
              case 95:
                throw new Error("Incorrect algorithm name: ".concat(alg.name.toUpperCase()));
              case 96:
                return _context11.abrupt("break", 188);
              case 97:
                privateKeyInfo = new PrivateKeyInfo();
                _asn = _fromBER(BufferSourceConverter.toArrayBuffer(keyData));
                AsnError.assert(_asn, "keyData");
                _context11.prev = 100;
                privateKeyInfo.fromSchema(_asn.result);
                _context11.next = 107;
                break;
              case 104:
                _context11.prev = 104;
                _context11.t6 = _context11["catch"](100);
                throw new Error("Incorrect keyData");
              case 107:
                if (privateKeyInfo.parsedKey) {
                  _context11.next = 109;
                  break;
                }
                throw new Error("Incorrect keyData");
              case 109:
                _context11.t7 = alg.name.toUpperCase();
                _context11.next = _context11.t7 === "RSA-PSS" ? 112 : _context11.t7 === "RSASSA-PKCS1-V1_5" ? 124 : _context11.t7 === "ECDSA" ? 146 : _context11.t7 === "ECDH" ? 147 : _context11.t7 === "RSA-OAEP" ? 153 : _context11.t7 === "RSAES-PKCS1-V1_5" ? 175 : 183;
                break;
              case 112:
                _context11.t8 = (_a = alg.hash) === null || _a === void 0 ? void 0 : _a.name.toUpperCase();
                _context11.next = _context11.t8 === "SHA-1" ? 115 : _context11.t8 === "SHA-256" ? 117 : _context11.t8 === "SHA-384" ? 119 : _context11.t8 === "SHA-512" ? 121 : 123;
                break;
              case 115:
                jwk.alg = "PS1";
                return _context11.abrupt("break", 124);
              case 117:
                jwk.alg = "PS256";
                return _context11.abrupt("break", 124);
              case 119:
                jwk.alg = "PS384";
                return _context11.abrupt("break", 124);
              case 121:
                jwk.alg = "PS512";
                return _context11.abrupt("break", 124);
              case 123:
                throw new Error("Incorrect hash algorithm: ".concat((_b = alg.hash) === null || _b === void 0 ? void 0 : _b.name.toUpperCase()));
              case 124:
                keyUsages = ["sign"];
                jwk.kty = "RSA";
                jwk.ext = extractable;
                jwk.key_ops = keyUsages;
                if (!(privateKeyInfo.privateKeyAlgorithm.algorithmId !== "1.2.840.113549.1.1.1")) {
                  _context11.next = 130;
                  break;
                }
                throw new Error("Incorrect private key algorithm: ".concat(privateKeyInfo.privateKeyAlgorithm.algorithmId));
              case 130:
                if (!("alg" in jwk === false)) {
                  _context11.next = 143;
                  break;
                }
                _context11.t9 = (_c = alg.hash) === null || _c === void 0 ? void 0 : _c.name.toUpperCase();
                _context11.next = _context11.t9 === "SHA-1" ? 134 : _context11.t9 === "SHA-256" ? 136 : _context11.t9 === "SHA-384" ? 138 : _context11.t9 === "SHA-512" ? 140 : 142;
                break;
              case 134:
                jwk.alg = "RS1";
                return _context11.abrupt("break", 143);
              case 136:
                jwk.alg = "RS256";
                return _context11.abrupt("break", 143);
              case 138:
                jwk.alg = "RS384";
                return _context11.abrupt("break", 143);
              case 140:
                jwk.alg = "RS512";
                return _context11.abrupt("break", 143);
              case 142:
                throw new Error("Incorrect hash algorithm: ".concat((_d = alg.hash) === null || _d === void 0 ? void 0 : _d.name.toUpperCase()));
              case 143:
                privateKeyJSON = privateKeyInfo.toJSON();
                Object.assign(jwk, privateKeyJSON);
                return _context11.abrupt("break", 184);
              case 146:
                keyUsages = ["sign"];
              case 147:
                jwk = {
                  kty: "EC",
                  ext: extractable,
                  key_ops: keyUsages
                };
                if (!(privateKeyInfo.privateKeyAlgorithm.algorithmId !== "1.2.840.10045.2.1")) {
                  _context11.next = 150;
                  break;
                }
                throw new Error("Incorrect algorithm: ".concat(privateKeyInfo.privateKeyAlgorithm.algorithmId));
              case 150:
                _privateKeyJSON = privateKeyInfo.toJSON();
                Object.assign(jwk, _privateKeyJSON);
                return _context11.abrupt("break", 184);
              case 153:
                jwk.kty = "RSA";
                jwk.ext = extractable;
                jwk.key_ops = keyUsages;
                if (!(this.name.toLowerCase() === "safari")) {
                  _context11.next = 160;
                  break;
                }
                jwk.alg = "RSA-OAEP";
                _context11.next = 172;
                break;
              case 160:
                _context11.t10 = (_e = alg.hash) === null || _e === void 0 ? void 0 : _e.name.toUpperCase();
                _context11.next = _context11.t10 === "SHA-1" ? 163 : _context11.t10 === "SHA-256" ? 165 : _context11.t10 === "SHA-384" ? 167 : _context11.t10 === "SHA-512" ? 169 : 171;
                break;
              case 163:
                jwk.alg = "RSA-OAEP";
                return _context11.abrupt("break", 172);
              case 165:
                jwk.alg = "RSA-OAEP-256";
                return _context11.abrupt("break", 172);
              case 167:
                jwk.alg = "RSA-OAEP-384";
                return _context11.abrupt("break", 172);
              case 169:
                jwk.alg = "RSA-OAEP-512";
                return _context11.abrupt("break", 172);
              case 171:
                throw new Error("Incorrect hash algorithm: ".concat((_f = alg.hash) === null || _f === void 0 ? void 0 : _f.name.toUpperCase()));
              case 172:
                _privateKeyJSON2 = privateKeyInfo.toJSON();
                Object.assign(jwk, _privateKeyJSON2);
                return _context11.abrupt("break", 184);
              case 175:
                keyUsages = ["decrypt"];
                jwk.kty = "RSA";
                jwk.ext = extractable;
                jwk.key_ops = keyUsages;
                jwk.alg = "PS1";
                _privateKeyJSON3 = privateKeyInfo.toJSON();
                Object.assign(jwk, _privateKeyJSON3);
                return _context11.abrupt("break", 184);
              case 183:
                throw new Error("Incorrect algorithm name: ".concat(alg.name.toUpperCase()));
              case 184:
                return _context11.abrupt("break", 188);
              case 185:
                jwk = keyData;
                return _context11.abrupt("break", 188);
              case 187:
                throw new Error("Incorrect format: ".concat(format));
              case 188:
                if (!(this.name.toLowerCase() === "safari")) {
                  _context11.next = 196;
                  break;
                }
                _context11.prev = 189;
                return _context11.abrupt("return", this.subtle.importKey("jwk", stringToArrayBuffer(JSON.stringify(jwk)), algorithm, extractable, keyUsages));
              case 193:
                _context11.prev = 193;
                _context11.t11 = _context11["catch"](189);
                return _context11.abrupt("return", this.subtle.importKey("jwk", jwk, algorithm, extractable, keyUsages));
              case 196:
                return _context11.abrupt("return", this.subtle.importKey("jwk", jwk, algorithm, extractable, keyUsages));
              case 197:
              case "end":
                return _context11.stop();
            }
          }, _callee11, this, [[9, 13], [100, 104], [189, 193]]);
        }));
        function importKey(_x7, _x8, _x9, _x10, _x11) {
          return _importKey2.apply(this, arguments);
        }
        return importKey;
      }()
    }, {
      key: "exportKey",
      value: function () {
        var _exportKey = _asyncToGenerator(_regeneratorRuntime().mark(function _callee12(format, key) {
          var jwk, publicKeyInfo, privateKeyInfo;
          return _regeneratorRuntime().wrap(function _callee12$(_context12) {
            while (1) switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.subtle.exportKey("jwk", key);
              case 2:
                jwk = _context12.sent;
                if (this.name.toLowerCase() === "safari") {
                  if (jwk instanceof ArrayBuffer) {
                    jwk = JSON.parse(arrayBufferToString(jwk));
                  }
                }
                _context12.t0 = format.toLowerCase();
                _context12.next = _context12.t0 === "raw" ? 7 : _context12.t0 === "spki" ? 8 : _context12.t0 === "pkcs8" ? 17 : _context12.t0 === "jwk" ? 26 : 27;
                break;
              case 7:
                return _context12.abrupt("return", this.subtle.exportKey("raw", key));
              case 8:
                publicKeyInfo = new PublicKeyInfo();
                _context12.prev = 9;
                publicKeyInfo.fromJSON(jwk);
                _context12.next = 16;
                break;
              case 13:
                _context12.prev = 13;
                _context12.t1 = _context12["catch"](9);
                throw new Error("Incorrect key data");
              case 16:
                return _context12.abrupt("return", publicKeyInfo.toSchema().toBER(false));
              case 17:
                privateKeyInfo = new PrivateKeyInfo();
                _context12.prev = 18;
                privateKeyInfo.fromJSON(jwk);
                _context12.next = 25;
                break;
              case 22:
                _context12.prev = 22;
                _context12.t2 = _context12["catch"](18);
                throw new Error("Incorrect key data");
              case 25:
                return _context12.abrupt("return", privateKeyInfo.toSchema().toBER(false));
              case 26:
                return _context12.abrupt("return", jwk);
              case 27:
                throw new Error("Incorrect format: ".concat(format));
              case 28:
              case "end":
                return _context12.stop();
            }
          }, _callee12, this, [[9, 13], [18, 22]]);
        }));
        function exportKey(_x12, _x13) {
          return _exportKey.apply(this, arguments);
        }
        return exportKey;
      }()
    }, {
      key: "convert",
      value: function () {
        var _convert = _asyncToGenerator(_regeneratorRuntime().mark(function _callee13(inputFormat, outputFormat, keyData, algorithm, extractable, keyUsages) {
          var key;
          return _regeneratorRuntime().wrap(function _callee13$(_context13) {
            while (1) switch (_context13.prev = _context13.next) {
              case 0:
                if (!(inputFormat.toLowerCase() === outputFormat.toLowerCase())) {
                  _context13.next = 2;
                  break;
                }
                return _context13.abrupt("return", keyData);
              case 2:
                _context13.next = 4;
                return this.importKey(inputFormat, keyData, algorithm, extractable, keyUsages);
              case 4:
                key = _context13.sent;
                return _context13.abrupt("return", this.exportKey(outputFormat, key));
              case 6:
              case "end":
                return _context13.stop();
            }
          }, _callee13, this);
        }));
        function convert(_x14, _x15, _x16, _x17, _x18, _x19) {
          return _convert.apply(this, arguments);
        }
        return convert;
      }()
    }, {
      key: "getAlgorithmByOID",
      value: function getAlgorithmByOID(oid) {
        var safety = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var target = arguments.length > 2 ? arguments[2] : undefined;
        switch (oid) {
          case "1.2.840.113549.1.1.1":
            return {
              name: "RSAES-PKCS1-v1_5"
            };
          case "1.2.840.113549.1.1.5":
            return {
              name: "RSASSA-PKCS1-v1_5",
              hash: {
                name: "SHA-1"
              }
            };
          case "1.2.840.113549.1.1.11":
            return {
              name: "RSASSA-PKCS1-v1_5",
              hash: {
                name: "SHA-256"
              }
            };
          case "1.2.840.113549.1.1.12":
            return {
              name: "RSASSA-PKCS1-v1_5",
              hash: {
                name: "SHA-384"
              }
            };
          case "1.2.840.113549.1.1.13":
            return {
              name: "RSASSA-PKCS1-v1_5",
              hash: {
                name: "SHA-512"
              }
            };
          case "1.2.840.113549.1.1.10":
            return {
              name: "RSA-PSS"
            };
          case "1.2.840.113549.1.1.7":
            return {
              name: "RSA-OAEP"
            };
          case "1.2.840.10045.2.1":
          case "1.2.840.10045.4.1":
            return {
              name: "ECDSA",
              hash: {
                name: "SHA-1"
              }
            };
          case "1.2.840.10045.4.3.2":
            return {
              name: "ECDSA",
              hash: {
                name: "SHA-256"
              }
            };
          case "1.2.840.10045.4.3.3":
            return {
              name: "ECDSA",
              hash: {
                name: "SHA-384"
              }
            };
          case "1.2.840.10045.4.3.4":
            return {
              name: "ECDSA",
              hash: {
                name: "SHA-512"
              }
            };
          case "1.3.133.16.840.63.0.2":
            return {
              name: "ECDH",
              kdf: "SHA-1"
            };
          case "1.3.132.1.11.1":
            return {
              name: "ECDH",
              kdf: "SHA-256"
            };
          case "1.3.132.1.11.2":
            return {
              name: "ECDH",
              kdf: "SHA-384"
            };
          case "1.3.132.1.11.3":
            return {
              name: "ECDH",
              kdf: "SHA-512"
            };
          case "2.16.840.1.101.3.4.1.2":
            return {
              name: "AES-CBC",
              length: 128
            };
          case "2.16.840.1.101.3.4.1.22":
            return {
              name: "AES-CBC",
              length: 192
            };
          case "2.16.840.1.101.3.4.1.42":
            return {
              name: "AES-CBC",
              length: 256
            };
          case "2.16.840.1.101.3.4.1.6":
            return {
              name: "AES-GCM",
              length: 128
            };
          case "2.16.840.1.101.3.4.1.26":
            return {
              name: "AES-GCM",
              length: 192
            };
          case "2.16.840.1.101.3.4.1.46":
            return {
              name: "AES-GCM",
              length: 256
            };
          case "2.16.840.1.101.3.4.1.4":
            return {
              name: "AES-CFB",
              length: 128
            };
          case "2.16.840.1.101.3.4.1.24":
            return {
              name: "AES-CFB",
              length: 192
            };
          case "2.16.840.1.101.3.4.1.44":
            return {
              name: "AES-CFB",
              length: 256
            };
          case "2.16.840.1.101.3.4.1.5":
            return {
              name: "AES-KW",
              length: 128
            };
          case "2.16.840.1.101.3.4.1.25":
            return {
              name: "AES-KW",
              length: 192
            };
          case "2.16.840.1.101.3.4.1.45":
            return {
              name: "AES-KW",
              length: 256
            };
          case "1.2.840.113549.2.7":
            return {
              name: "HMAC",
              hash: {
                name: "SHA-1"
              }
            };
          case "1.2.840.113549.2.9":
            return {
              name: "HMAC",
              hash: {
                name: "SHA-256"
              }
            };
          case "1.2.840.113549.2.10":
            return {
              name: "HMAC",
              hash: {
                name: "SHA-384"
              }
            };
          case "1.2.840.113549.2.11":
            return {
              name: "HMAC",
              hash: {
                name: "SHA-512"
              }
            };
          case "1.2.840.113549.1.9.16.3.5":
            return {
              name: "DH"
            };
          case "1.3.14.3.2.26":
            return {
              name: "SHA-1"
            };
          case "2.16.840.1.101.3.4.2.1":
            return {
              name: "SHA-256"
            };
          case "2.16.840.1.101.3.4.2.2":
            return {
              name: "SHA-384"
            };
          case "2.16.840.1.101.3.4.2.3":
            return {
              name: "SHA-512"
            };
          case "1.2.840.113549.1.5.12":
            return {
              name: "PBKDF2"
            };
          case "1.2.840.10045.3.1.7":
            return {
              name: "P-256"
            };
          case "1.3.132.0.34":
            return {
              name: "P-384"
            };
          case "1.3.132.0.35":
            return {
              name: "P-521"
            };
        }
        if (safety) {
          throw new Error("Unsupported algorithm identifier ".concat(target ? "for ".concat(target, " ") : EMPTY_STRING, ": ").concat(oid));
        }
        return {};
      }
    }, {
      key: "getOIDByAlgorithm",
      value: function getOIDByAlgorithm(algorithm) {
        var safety = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var target = arguments.length > 2 ? arguments[2] : undefined;
        var result = EMPTY_STRING;
        switch (algorithm.name.toUpperCase()) {
          case "RSAES-PKCS1-V1_5":
            result = "1.2.840.113549.1.1.1";
            break;
          case "RSASSA-PKCS1-V1_5":
            switch (algorithm.hash.name.toUpperCase()) {
              case "SHA-1":
                result = "1.2.840.113549.1.1.5";
                break;
              case "SHA-256":
                result = "1.2.840.113549.1.1.11";
                break;
              case "SHA-384":
                result = "1.2.840.113549.1.1.12";
                break;
              case "SHA-512":
                result = "1.2.840.113549.1.1.13";
                break;
            }
            break;
          case "RSA-PSS":
            result = "1.2.840.113549.1.1.10";
            break;
          case "RSA-OAEP":
            result = "1.2.840.113549.1.1.7";
            break;
          case "ECDSA":
            switch (algorithm.hash.name.toUpperCase()) {
              case "SHA-1":
                result = "1.2.840.10045.4.1";
                break;
              case "SHA-256":
                result = "1.2.840.10045.4.3.2";
                break;
              case "SHA-384":
                result = "1.2.840.10045.4.3.3";
                break;
              case "SHA-512":
                result = "1.2.840.10045.4.3.4";
                break;
            }
            break;
          case "ECDH":
            switch (algorithm.kdf.toUpperCase()) {
              case "SHA-1":
                result = "1.3.133.16.840.63.0.2";
                break;
              case "SHA-256":
                result = "1.3.132.1.11.1";
                break;
              case "SHA-384":
                result = "1.3.132.1.11.2";
                break;
              case "SHA-512":
                result = "1.3.132.1.11.3";
                break;
            }
            break;
          case "AES-CTR":
            break;
          case "AES-CBC":
            switch (algorithm.length) {
              case 128:
                result = "2.16.840.1.101.3.4.1.2";
                break;
              case 192:
                result = "2.16.840.1.101.3.4.1.22";
                break;
              case 256:
                result = "2.16.840.1.101.3.4.1.42";
                break;
            }
            break;
          case "AES-CMAC":
            break;
          case "AES-GCM":
            switch (algorithm.length) {
              case 128:
                result = "2.16.840.1.101.3.4.1.6";
                break;
              case 192:
                result = "2.16.840.1.101.3.4.1.26";
                break;
              case 256:
                result = "2.16.840.1.101.3.4.1.46";
                break;
            }
            break;
          case "AES-CFB":
            switch (algorithm.length) {
              case 128:
                result = "2.16.840.1.101.3.4.1.4";
                break;
              case 192:
                result = "2.16.840.1.101.3.4.1.24";
                break;
              case 256:
                result = "2.16.840.1.101.3.4.1.44";
                break;
            }
            break;
          case "AES-KW":
            switch (algorithm.length) {
              case 128:
                result = "2.16.840.1.101.3.4.1.5";
                break;
              case 192:
                result = "2.16.840.1.101.3.4.1.25";
                break;
              case 256:
                result = "2.16.840.1.101.3.4.1.45";
                break;
            }
            break;
          case "HMAC":
            switch (algorithm.hash.name.toUpperCase()) {
              case "SHA-1":
                result = "1.2.840.113549.2.7";
                break;
              case "SHA-256":
                result = "1.2.840.113549.2.9";
                break;
              case "SHA-384":
                result = "1.2.840.113549.2.10";
                break;
              case "SHA-512":
                result = "1.2.840.113549.2.11";
                break;
            }
            break;
          case "DH":
            result = "1.2.840.113549.1.9.16.3.5";
            break;
          case "SHA-1":
            result = "1.3.14.3.2.26";
            break;
          case "SHA-256":
            result = "2.16.840.1.101.3.4.2.1";
            break;
          case "SHA-384":
            result = "2.16.840.1.101.3.4.2.2";
            break;
          case "SHA-512":
            result = "2.16.840.1.101.3.4.2.3";
            break;
          case "CONCAT":
            break;
          case "HKDF":
            break;
          case "PBKDF2":
            result = "1.2.840.113549.1.5.12";
            break;
          case "P-256":
            result = "1.2.840.10045.3.1.7";
            break;
          case "P-384":
            result = "1.3.132.0.34";
            break;
          case "P-521":
            result = "1.3.132.0.35";
            break;
        }
        if (!result && safety) {
          throw new Error("Unsupported algorithm ".concat(target ? "for ".concat(target, " ") : EMPTY_STRING, ": ").concat(algorithm.name));
        }
        return result;
      }
    }, {
      key: "getAlgorithmParameters",
      value: function getAlgorithmParameters(algorithmName, operation) {
        var result = {
          algorithm: {},
          usages: []
        };
        switch (algorithmName.toUpperCase()) {
          case "RSAES-PKCS1-V1_5":
          case "RSASSA-PKCS1-V1_5":
            switch (operation.toLowerCase()) {
              case "generatekey":
                result = {
                  algorithm: {
                    name: "RSASSA-PKCS1-v1_5",
                    modulusLength: 2048,
                    publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
                    hash: {
                      name: "SHA-256"
                    }
                  },
                  usages: ["sign", "verify"]
                };
                break;
              case "verify":
              case "sign":
              case "importkey":
                result = {
                  algorithm: {
                    name: "RSASSA-PKCS1-v1_5",
                    hash: {
                      name: "SHA-256"
                    }
                  },
                  usages: ["verify"]
                };
                break;
              case "exportkey":
              default:
                return {
                  algorithm: {
                    name: "RSASSA-PKCS1-v1_5"
                  },
                  usages: []
                };
            }
            break;
          case "RSA-PSS":
            switch (operation.toLowerCase()) {
              case "sign":
              case "verify":
                result = {
                  algorithm: {
                    name: "RSA-PSS",
                    hash: {
                      name: "SHA-1"
                    },
                    saltLength: 20
                  },
                  usages: ["sign", "verify"]
                };
                break;
              case "generatekey":
                result = {
                  algorithm: {
                    name: "RSA-PSS",
                    modulusLength: 2048,
                    publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
                    hash: {
                      name: "SHA-1"
                    }
                  },
                  usages: ["sign", "verify"]
                };
                break;
              case "importkey":
                result = {
                  algorithm: {
                    name: "RSA-PSS",
                    hash: {
                      name: "SHA-1"
                    }
                  },
                  usages: ["verify"]
                };
                break;
              case "exportkey":
              default:
                return {
                  algorithm: {
                    name: "RSA-PSS"
                  },
                  usages: []
                };
            }
            break;
          case "RSA-OAEP":
            switch (operation.toLowerCase()) {
              case "encrypt":
              case "decrypt":
                result = {
                  algorithm: {
                    name: "RSA-OAEP"
                  },
                  usages: ["encrypt", "decrypt"]
                };
                break;
              case "generatekey":
                result = {
                  algorithm: {
                    name: "RSA-OAEP",
                    modulusLength: 2048,
                    publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
                    hash: {
                      name: "SHA-256"
                    }
                  },
                  usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
                };
                break;
              case "importkey":
                result = {
                  algorithm: {
                    name: "RSA-OAEP",
                    hash: {
                      name: "SHA-256"
                    }
                  },
                  usages: ["encrypt"]
                };
                break;
              case "exportkey":
              default:
                return {
                  algorithm: {
                    name: "RSA-OAEP"
                  },
                  usages: []
                };
            }
            break;
          case "ECDSA":
            switch (operation.toLowerCase()) {
              case "generatekey":
                result = {
                  algorithm: {
                    name: "ECDSA",
                    namedCurve: "P-256"
                  },
                  usages: ["sign", "verify"]
                };
                break;
              case "importkey":
                result = {
                  algorithm: {
                    name: "ECDSA",
                    namedCurve: "P-256"
                  },
                  usages: ["verify"]
                };
                break;
              case "verify":
              case "sign":
                result = {
                  algorithm: {
                    name: "ECDSA",
                    hash: {
                      name: "SHA-256"
                    }
                  },
                  usages: ["sign"]
                };
                break;
              default:
                return {
                  algorithm: {
                    name: "ECDSA"
                  },
                  usages: []
                };
            }
            break;
          case "ECDH":
            switch (operation.toLowerCase()) {
              case "exportkey":
              case "importkey":
              case "generatekey":
                result = {
                  algorithm: {
                    name: "ECDH",
                    namedCurve: "P-256"
                  },
                  usages: ["deriveKey", "deriveBits"]
                };
                break;
              case "derivekey":
              case "derivebits":
                result = {
                  algorithm: {
                    name: "ECDH",
                    namedCurve: "P-256",
                    public: []
                  },
                  usages: ["encrypt", "decrypt"]
                };
                break;
              default:
                return {
                  algorithm: {
                    name: "ECDH"
                  },
                  usages: []
                };
            }
            break;
          case "AES-CTR":
            switch (operation.toLowerCase()) {
              case "importkey":
              case "exportkey":
              case "generatekey":
                result = {
                  algorithm: {
                    name: "AES-CTR",
                    length: 256
                  },
                  usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
                };
                break;
              case "decrypt":
              case "encrypt":
                result = {
                  algorithm: {
                    name: "AES-CTR",
                    counter: new Uint8Array(16),
                    length: 10
                  },
                  usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
                };
                break;
              default:
                return {
                  algorithm: {
                    name: "AES-CTR"
                  },
                  usages: []
                };
            }
            break;
          case "AES-CBC":
            switch (operation.toLowerCase()) {
              case "importkey":
              case "exportkey":
              case "generatekey":
                result = {
                  algorithm: {
                    name: "AES-CBC",
                    length: 256
                  },
                  usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
                };
                break;
              case "decrypt":
              case "encrypt":
                result = {
                  algorithm: {
                    name: "AES-CBC",
                    iv: this.getRandomValues(new Uint8Array(16))
                  },
                  usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
                };
                break;
              default:
                return {
                  algorithm: {
                    name: "AES-CBC"
                  },
                  usages: []
                };
            }
            break;
          case "AES-GCM":
            switch (operation.toLowerCase()) {
              case "importkey":
              case "exportkey":
              case "generatekey":
                result = {
                  algorithm: {
                    name: "AES-GCM",
                    length: 256
                  },
                  usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
                };
                break;
              case "decrypt":
              case "encrypt":
                result = {
                  algorithm: {
                    name: "AES-GCM",
                    iv: this.getRandomValues(new Uint8Array(16))
                  },
                  usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
                };
                break;
              default:
                return {
                  algorithm: {
                    name: "AES-GCM"
                  },
                  usages: []
                };
            }
            break;
          case "AES-KW":
            switch (operation.toLowerCase()) {
              case "importkey":
              case "exportkey":
              case "generatekey":
              case "wrapkey":
              case "unwrapkey":
                result = {
                  algorithm: {
                    name: "AES-KW",
                    length: 256
                  },
                  usages: ["wrapKey", "unwrapKey"]
                };
                break;
              default:
                return {
                  algorithm: {
                    name: "AES-KW"
                  },
                  usages: []
                };
            }
            break;
          case "HMAC":
            switch (operation.toLowerCase()) {
              case "sign":
              case "verify":
                result = {
                  algorithm: {
                    name: "HMAC"
                  },
                  usages: ["sign", "verify"]
                };
                break;
              case "importkey":
              case "exportkey":
              case "generatekey":
                result = {
                  algorithm: {
                    name: "HMAC",
                    length: 32,
                    hash: {
                      name: "SHA-256"
                    }
                  },
                  usages: ["sign", "verify"]
                };
                break;
              default:
                return {
                  algorithm: {
                    name: "HMAC"
                  },
                  usages: []
                };
            }
            break;
          case "HKDF":
            switch (operation.toLowerCase()) {
              case "derivekey":
                result = {
                  algorithm: {
                    name: "HKDF",
                    hash: "SHA-256",
                    salt: new Uint8Array([]),
                    info: new Uint8Array([])
                  },
                  usages: ["encrypt", "decrypt"]
                };
                break;
              default:
                return {
                  algorithm: {
                    name: "HKDF"
                  },
                  usages: []
                };
            }
            break;
          case "PBKDF2":
            switch (operation.toLowerCase()) {
              case "derivekey":
                result = {
                  algorithm: {
                    name: "PBKDF2",
                    hash: {
                      name: "SHA-256"
                    },
                    salt: new Uint8Array([]),
                    iterations: 10000
                  },
                  usages: ["encrypt", "decrypt"]
                };
                break;
              default:
                return {
                  algorithm: {
                    name: "PBKDF2"
                  },
                  usages: []
                };
            }
            break;
        }
        return result;
      }
    }, {
      key: "getHashAlgorithm",
      value: function getHashAlgorithm(signatureAlgorithm) {
        var result = EMPTY_STRING;
        switch (signatureAlgorithm.algorithmId) {
          case "1.2.840.10045.4.1":
          case "1.2.840.113549.1.1.5":
            result = "SHA-1";
            break;
          case "1.2.840.10045.4.3.2":
          case "1.2.840.113549.1.1.11":
            result = "SHA-256";
            break;
          case "1.2.840.10045.4.3.3":
          case "1.2.840.113549.1.1.12":
            result = "SHA-384";
            break;
          case "1.2.840.10045.4.3.4":
          case "1.2.840.113549.1.1.13":
            result = "SHA-512";
            break;
          case "1.2.840.113549.1.1.10":
            {
              try {
                var params = new RSASSAPSSParams({
                  schema: signatureAlgorithm.algorithmParams
                });
                if (params.hashAlgorithm) {
                  var algorithm = this.getAlgorithmByOID(params.hashAlgorithm.algorithmId);
                  if ("name" in algorithm) {
                    result = algorithm.name;
                  } else {
                    return EMPTY_STRING;
                  }
                } else result = "SHA-1";
              } catch (_unused4) {}
            }
            break;
        }
        return result;
      }
    }, {
      key: "encryptEncryptedContentInfo",
      value: function () {
        var _encryptEncryptedContentInfo = _asyncToGenerator(_regeneratorRuntime().mark(function _callee14(parameters) {
          var contentEncryptionOID, pbkdf2OID, hmacOID, ivBuffer, ivView, saltBuffer, saltView, contentView, pbkdf2Params, passwordView, pbkdfKey, derivedKey, encryptedData, pbes2Parameters;
          return _regeneratorRuntime().wrap(function _callee14$(_context14) {
            while (1) switch (_context14.prev = _context14.next) {
              case 0:
                ParameterError.assert(parameters, "password", "contentEncryptionAlgorithm", "hmacHashAlgorithm", "iterationCount", "contentToEncrypt", "contentToEncrypt", "contentType");
                contentEncryptionOID = this.getOIDByAlgorithm(parameters.contentEncryptionAlgorithm, true, "contentEncryptionAlgorithm");
                pbkdf2OID = this.getOIDByAlgorithm({
                  name: "PBKDF2"
                }, true, "PBKDF2");
                hmacOID = this.getOIDByAlgorithm({
                  name: "HMAC",
                  hash: {
                    name: parameters.hmacHashAlgorithm
                  }
                }, true, "hmacHashAlgorithm");
                ivBuffer = new ArrayBuffer(16);
                ivView = new Uint8Array(ivBuffer);
                this.getRandomValues(ivView);
                saltBuffer = new ArrayBuffer(64);
                saltView = new Uint8Array(saltBuffer);
                this.getRandomValues(saltView);
                contentView = new Uint8Array(parameters.contentToEncrypt);
                pbkdf2Params = new PBKDF2Params({
                  salt: new OctetString({
                    valueHex: saltBuffer
                  }),
                  iterationCount: parameters.iterationCount,
                  prf: new AlgorithmIdentifier({
                    algorithmId: hmacOID,
                    algorithmParams: new Null()
                  })
                });
                passwordView = new Uint8Array(parameters.password);
                _context14.next = 15;
                return this.importKey("raw", passwordView, "PBKDF2", false, ["deriveKey"]);
              case 15:
                pbkdfKey = _context14.sent;
                _context14.next = 18;
                return this.deriveKey({
                  name: "PBKDF2",
                  hash: {
                    name: parameters.hmacHashAlgorithm
                  },
                  salt: saltView,
                  iterations: parameters.iterationCount
                }, pbkdfKey, parameters.contentEncryptionAlgorithm, false, ["encrypt"]);
              case 18:
                derivedKey = _context14.sent;
                _context14.next = 21;
                return this.encrypt({
                  name: parameters.contentEncryptionAlgorithm.name,
                  iv: ivView
                }, derivedKey, contentView);
              case 21:
                encryptedData = _context14.sent;
                pbes2Parameters = new PBES2Params({
                  keyDerivationFunc: new AlgorithmIdentifier({
                    algorithmId: pbkdf2OID,
                    algorithmParams: pbkdf2Params.toSchema()
                  }),
                  encryptionScheme: new AlgorithmIdentifier({
                    algorithmId: contentEncryptionOID,
                    algorithmParams: new OctetString({
                      valueHex: ivBuffer
                    })
                  })
                });
                return _context14.abrupt("return", new EncryptedContentInfo({
                  contentType: parameters.contentType,
                  contentEncryptionAlgorithm: new AlgorithmIdentifier({
                    algorithmId: "1.2.840.113549.1.5.13",
                    algorithmParams: pbes2Parameters.toSchema()
                  }),
                  encryptedContent: new OctetString({
                    valueHex: encryptedData
                  })
                }));
              case 24:
              case "end":
                return _context14.stop();
            }
          }, _callee14, this);
        }));
        function encryptEncryptedContentInfo(_x20) {
          return _encryptEncryptedContentInfo.apply(this, arguments);
        }
        return encryptEncryptedContentInfo;
      }()
    }, {
      key: "decryptEncryptedContentInfo",
      value: function () {
        var _decryptEncryptedContentInfo = _asyncToGenerator(_regeneratorRuntime().mark(function _callee15(parameters) {
          var pbes2Parameters, pbkdf2Params, contentEncryptionAlgorithm, ivBuffer, ivView, saltBuffer, saltView, iterationCount, hmacHashAlgorithm, algorithm, pbkdfKey, result, dataBuffer;
          return _regeneratorRuntime().wrap(function _callee15$(_context15) {
            while (1) switch (_context15.prev = _context15.next) {
              case 0:
                ParameterError.assert(parameters, "password", "encryptedContentInfo");
                if (!(parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId !== "1.2.840.113549.1.5.13")) {
                  _context15.next = 3;
                  break;
                }
                throw new Error("Unknown \"contentEncryptionAlgorithm\": ".concat(parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId));
              case 3:
                _context15.prev = 3;
                pbes2Parameters = new PBES2Params({
                  schema: parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams
                });
                _context15.next = 10;
                break;
              case 7:
                _context15.prev = 7;
                _context15.t0 = _context15["catch"](3);
                throw new Error("Incorrectly encoded \"pbes2Parameters\"");
              case 10:
                _context15.prev = 10;
                pbkdf2Params = new PBKDF2Params({
                  schema: pbes2Parameters.keyDerivationFunc.algorithmParams
                });
                _context15.next = 17;
                break;
              case 14:
                _context15.prev = 14;
                _context15.t1 = _context15["catch"](10);
                throw new Error("Incorrectly encoded \"pbkdf2Params\"");
              case 17:
                contentEncryptionAlgorithm = this.getAlgorithmByOID(pbes2Parameters.encryptionScheme.algorithmId, true);
                ivBuffer = pbes2Parameters.encryptionScheme.algorithmParams.valueBlock.valueHex;
                ivView = new Uint8Array(ivBuffer);
                saltBuffer = pbkdf2Params.salt.valueBlock.valueHex;
                saltView = new Uint8Array(saltBuffer);
                iterationCount = pbkdf2Params.iterationCount;
                hmacHashAlgorithm = "SHA-1";
                if (pbkdf2Params.prf) {
                  algorithm = this.getAlgorithmByOID(pbkdf2Params.prf.algorithmId, true);
                  hmacHashAlgorithm = algorithm.hash.name;
                }
                _context15.next = 27;
                return this.importKey("raw", parameters.password, "PBKDF2", false, ["deriveKey"]);
              case 27:
                pbkdfKey = _context15.sent;
                _context15.next = 30;
                return this.deriveKey({
                  name: "PBKDF2",
                  hash: {
                    name: hmacHashAlgorithm
                  },
                  salt: saltView,
                  iterations: iterationCount
                }, pbkdfKey, contentEncryptionAlgorithm, false, ["decrypt"]);
              case 30:
                result = _context15.sent;
                dataBuffer = parameters.encryptedContentInfo.getEncryptedContent();
                return _context15.abrupt("return", this.decrypt({
                  name: contentEncryptionAlgorithm.name,
                  iv: ivView
                }, result, dataBuffer));
              case 33:
              case "end":
                return _context15.stop();
            }
          }, _callee15, this, [[3, 7], [10, 14]]);
        }));
        function decryptEncryptedContentInfo(_x21) {
          return _decryptEncryptedContentInfo.apply(this, arguments);
        }
        return decryptEncryptedContentInfo;
      }()
    }, {
      key: "stampDataWithPassword",
      value: function () {
        var _stampDataWithPassword = _asyncToGenerator(_regeneratorRuntime().mark(function _callee16(parameters) {
          var length, hmacAlgorithm, pkcsKey, hmacKey;
          return _regeneratorRuntime().wrap(function _callee16$(_context16) {
            while (1) switch (_context16.prev = _context16.next) {
              case 0:
                if (!(parameters instanceof Object === false)) {
                  _context16.next = 2;
                  break;
                }
                throw new Error("Parameters must have type \"Object\"");
              case 2:
                ParameterError.assert(parameters, "password", "hashAlgorithm", "iterationCount", "salt", "contentToStamp");
                _context16.t0 = parameters.hashAlgorithm.toLowerCase();
                _context16.next = _context16.t0 === "sha-1" ? 6 : _context16.t0 === "sha-256" ? 8 : _context16.t0 === "sha-384" ? 10 : _context16.t0 === "sha-512" ? 12 : 14;
                break;
              case 6:
                length = 160;
                return _context16.abrupt("break", 15);
              case 8:
                length = 256;
                return _context16.abrupt("break", 15);
              case 10:
                length = 384;
                return _context16.abrupt("break", 15);
              case 12:
                length = 512;
                return _context16.abrupt("break", 15);
              case 14:
                throw new Error("Incorrect \"parameters.hashAlgorithm\" parameter: ".concat(parameters.hashAlgorithm));
              case 15:
                hmacAlgorithm = {
                  name: "HMAC",
                  length: length,
                  hash: {
                    name: parameters.hashAlgorithm
                  }
                };
                _context16.next = 18;
                return makePKCS12B2Key(parameters.hashAlgorithm, length, parameters.password, parameters.salt, parameters.iterationCount);
              case 18:
                pkcsKey = _context16.sent;
                _context16.next = 21;
                return this.importKey("raw", new Uint8Array(pkcsKey), hmacAlgorithm, false, ["sign"]);
              case 21:
                hmacKey = _context16.sent;
                return _context16.abrupt("return", this.sign(hmacAlgorithm, hmacKey, new Uint8Array(parameters.contentToStamp)));
              case 23:
              case "end":
                return _context16.stop();
            }
          }, _callee16, this);
        }));
        function stampDataWithPassword(_x22) {
          return _stampDataWithPassword.apply(this, arguments);
        }
        return stampDataWithPassword;
      }()
    }, {
      key: "verifyDataStampedWithPassword",
      value: function () {
        var _verifyDataStampedWithPassword = _asyncToGenerator(_regeneratorRuntime().mark(function _callee17(parameters) {
          var length, hmacAlgorithm, pkcsKey, hmacKey;
          return _regeneratorRuntime().wrap(function _callee17$(_context17) {
            while (1) switch (_context17.prev = _context17.next) {
              case 0:
                ParameterError.assert(parameters, "password", "hashAlgorithm", "salt", "iterationCount", "contentToVerify", "signatureToVerify");
                length = 0;
                _context17.t0 = parameters.hashAlgorithm.toLowerCase();
                _context17.next = _context17.t0 === "sha-1" ? 5 : _context17.t0 === "sha-256" ? 7 : _context17.t0 === "sha-384" ? 9 : _context17.t0 === "sha-512" ? 11 : 13;
                break;
              case 5:
                length = 160;
                return _context17.abrupt("break", 14);
              case 7:
                length = 256;
                return _context17.abrupt("break", 14);
              case 9:
                length = 384;
                return _context17.abrupt("break", 14);
              case 11:
                length = 512;
                return _context17.abrupt("break", 14);
              case 13:
                throw new Error("Incorrect \"parameters.hashAlgorithm\" parameter: ".concat(parameters.hashAlgorithm));
              case 14:
                hmacAlgorithm = {
                  name: "HMAC",
                  length: length,
                  hash: {
                    name: parameters.hashAlgorithm
                  }
                };
                _context17.next = 17;
                return makePKCS12B2Key(parameters.hashAlgorithm, length, parameters.password, parameters.salt, parameters.iterationCount);
              case 17:
                pkcsKey = _context17.sent;
                _context17.next = 20;
                return this.importKey("raw", new Uint8Array(pkcsKey), hmacAlgorithm, false, ["verify"]);
              case 20:
                hmacKey = _context17.sent;
                return _context17.abrupt("return", this.verify(hmacAlgorithm, hmacKey, new Uint8Array(parameters.signatureToVerify), new Uint8Array(parameters.contentToVerify)));
              case 22:
              case "end":
                return _context17.stop();
            }
          }, _callee17, this);
        }));
        function verifyDataStampedWithPassword(_x23) {
          return _verifyDataStampedWithPassword.apply(this, arguments);
        }
        return verifyDataStampedWithPassword;
      }()
    }, {
      key: "getSignatureParameters",
      value: function () {
        var _getSignatureParameters = _asyncToGenerator(_regeneratorRuntime().mark(function _callee18(privateKey) {
          var hashAlgorithm,
            signatureAlgorithm,
            parameters,
            algorithm,
            paramsObject,
            hashAlgorithmOID,
            pssParameters,
            _args18 = arguments;
          return _regeneratorRuntime().wrap(function _callee18$(_context18) {
            while (1) switch (_context18.prev = _context18.next) {
              case 0:
                hashAlgorithm = _args18.length > 1 && _args18[1] !== undefined ? _args18[1] : "SHA-1";
                this.getOIDByAlgorithm({
                  name: hashAlgorithm
                }, true, "hashAlgorithm");
                signatureAlgorithm = new AlgorithmIdentifier();
                parameters = this.getAlgorithmParameters(privateKey.algorithm.name, "sign");
                if (Object.keys(parameters.algorithm).length) {
                  _context18.next = 6;
                  break;
                }
                throw new Error("Parameter 'algorithm' is empty");
              case 6:
                algorithm = parameters.algorithm;
                if ("hash" in privateKey.algorithm && privateKey.algorithm.hash && privateKey.algorithm.hash.name) {
                  algorithm.hash.name = privateKey.algorithm.hash.name;
                } else {
                  algorithm.hash.name = hashAlgorithm;
                }
                _context18.t0 = privateKey.algorithm.name.toUpperCase();
                _context18.next = _context18.t0 === "RSASSA-PKCS1-V1_5" ? 11 : _context18.t0 === "ECDSA" ? 11 : _context18.t0 === "RSA-PSS" ? 13 : 29;
                break;
              case 11:
                signatureAlgorithm.algorithmId = this.getOIDByAlgorithm(algorithm, true);
                return _context18.abrupt("break", 30);
              case 13:
                _context18.t1 = algorithm.hash.name.toUpperCase();
                _context18.next = _context18.t1 === "SHA-256" ? 16 : _context18.t1 === "SHA-384" ? 18 : _context18.t1 === "SHA-512" ? 20 : 22;
                break;
              case 16:
                algorithm.saltLength = 32;
                return _context18.abrupt("break", 22);
              case 18:
                algorithm.saltLength = 48;
                return _context18.abrupt("break", 22);
              case 20:
                algorithm.saltLength = 64;
                return _context18.abrupt("break", 22);
              case 22:
                paramsObject = {};
                if (algorithm.hash.name.toUpperCase() !== "SHA-1") {
                  hashAlgorithmOID = this.getOIDByAlgorithm({
                    name: algorithm.hash.name
                  }, true, "hashAlgorithm");
                  paramsObject.hashAlgorithm = new AlgorithmIdentifier({
                    algorithmId: hashAlgorithmOID,
                    algorithmParams: new Null()
                  });
                  paramsObject.maskGenAlgorithm = new AlgorithmIdentifier({
                    algorithmId: "1.2.840.113549.1.1.8",
                    algorithmParams: paramsObject.hashAlgorithm.toSchema()
                  });
                }
                if (algorithm.saltLength !== 20) paramsObject.saltLength = algorithm.saltLength;
                pssParameters = new RSASSAPSSParams(paramsObject);
                signatureAlgorithm.algorithmId = "1.2.840.113549.1.1.10";
                signatureAlgorithm.algorithmParams = pssParameters.toSchema();
                return _context18.abrupt("break", 30);
              case 29:
                throw new Error("Unsupported signature algorithm: ".concat(privateKey.algorithm.name));
              case 30:
                return _context18.abrupt("return", {
                  signatureAlgorithm: signatureAlgorithm,
                  parameters: parameters
                });
              case 31:
              case "end":
                return _context18.stop();
            }
          }, _callee18, this);
        }));
        function getSignatureParameters(_x24) {
          return _getSignatureParameters.apply(this, arguments);
        }
        return getSignatureParameters;
      }()
    }, {
      key: "signWithPrivateKey",
      value: function () {
        var _signWithPrivateKey = _asyncToGenerator(_regeneratorRuntime().mark(function _callee19(data, privateKey, parameters) {
          var signature;
          return _regeneratorRuntime().wrap(function _callee19$(_context19) {
            while (1) switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return this.sign(parameters.algorithm, privateKey, data);
              case 2:
                signature = _context19.sent;
                if (!(parameters.algorithm.name === "ECDSA")) {
                  _context19.next = 5;
                  break;
                }
                return _context19.abrupt("return", createCMSECDSASignature(signature));
              case 5:
                return _context19.abrupt("return", signature);
              case 6:
              case "end":
                return _context19.stop();
            }
          }, _callee19, this);
        }));
        function signWithPrivateKey(_x25, _x26, _x27) {
          return _signWithPrivateKey.apply(this, arguments);
        }
        return signWithPrivateKey;
      }()
    }, {
      key: "fillPublicKeyParameters",
      value: function fillPublicKeyParameters(publicKeyInfo, signatureAlgorithm) {
        var parameters = {};
        var shaAlgorithm = this.getHashAlgorithm(signatureAlgorithm);
        if (shaAlgorithm === EMPTY_STRING) throw new Error("Unsupported signature algorithm: ".concat(signatureAlgorithm.algorithmId));
        var algorithmId;
        if (signatureAlgorithm.algorithmId === "1.2.840.113549.1.1.10") algorithmId = signatureAlgorithm.algorithmId;else algorithmId = publicKeyInfo.algorithm.algorithmId;
        var algorithmObject = this.getAlgorithmByOID(algorithmId, true);
        parameters.algorithm = this.getAlgorithmParameters(algorithmObject.name, "importKey");
        if ("hash" in parameters.algorithm.algorithm) parameters.algorithm.algorithm.hash.name = shaAlgorithm;
        if (algorithmObject.name === "ECDSA") {
          var publicKeyAlgorithm = publicKeyInfo.algorithm;
          if (!publicKeyAlgorithm.algorithmParams) {
            throw new Error("Algorithm parameters for ECDSA public key are missed");
          }
          var publicKeyAlgorithmParams = publicKeyAlgorithm.algorithmParams;
          if ("idBlock" in publicKeyAlgorithm.algorithmParams) {
            if (!(publicKeyAlgorithmParams.idBlock.tagClass === 1 && publicKeyAlgorithmParams.idBlock.tagNumber === 6)) {
              throw new Error("Incorrect type for ECDSA public key parameters");
            }
          }
          var curveObject = this.getAlgorithmByOID(publicKeyAlgorithmParams.valueBlock.toString(), true);
          parameters.algorithm.algorithm.namedCurve = curveObject.name;
        }
        return parameters;
      }
    }, {
      key: "getPublicKey",
      value: function () {
        var _getPublicKey = _asyncToGenerator(_regeneratorRuntime().mark(function _callee20(publicKeyInfo, signatureAlgorithm, parameters) {
          var publicKeyInfoBuffer;
          return _regeneratorRuntime().wrap(function _callee20$(_context20) {
            while (1) switch (_context20.prev = _context20.next) {
              case 0:
                if (!parameters) {
                  parameters = this.fillPublicKeyParameters(publicKeyInfo, signatureAlgorithm);
                }
                publicKeyInfoBuffer = publicKeyInfo.toSchema().toBER(false);
                return _context20.abrupt("return", this.importKey("spki", publicKeyInfoBuffer, parameters.algorithm.algorithm, true, parameters.algorithm.usages));
              case 3:
              case "end":
                return _context20.stop();
            }
          }, _callee20, this);
        }));
        function getPublicKey(_x28, _x29, _x30) {
          return _getPublicKey.apply(this, arguments);
        }
        return getPublicKey;
      }()
    }, {
      key: "verifyWithPublicKey",
      value: function () {
        var _verifyWithPublicKey = _asyncToGenerator(_regeneratorRuntime().mark(function _callee21(data, signature, publicKeyInfo, signatureAlgorithm, shaAlgorithm) {
          var publicKey, parameters, algorithmId, algorithmObject, algorithmParamsChecked, curveObject, algorithm, signatureValue, namedCurve, asn1, pssParameters, hashAlgo, hashAlgorithm;
          return _regeneratorRuntime().wrap(function _callee21$(_context21) {
            while (1) switch (_context21.prev = _context21.next) {
              case 0:
                if (shaAlgorithm) {
                  _context21.next = 9;
                  break;
                }
                shaAlgorithm = this.getHashAlgorithm(signatureAlgorithm);
                if (shaAlgorithm) {
                  _context21.next = 4;
                  break;
                }
                throw new Error("Unsupported signature algorithm: ".concat(signatureAlgorithm.algorithmId));
              case 4:
                _context21.next = 6;
                return this.getPublicKey(publicKeyInfo, signatureAlgorithm);
              case 6:
                publicKey = _context21.sent;
                _context21.next = 24;
                break;
              case 9:
                parameters = {};
                if (signatureAlgorithm.algorithmId === "1.2.840.113549.1.1.10") algorithmId = signatureAlgorithm.algorithmId;else algorithmId = publicKeyInfo.algorithm.algorithmId;
                algorithmObject = this.getAlgorithmByOID(algorithmId, true);
                parameters.algorithm = this.getAlgorithmParameters(algorithmObject.name, "importKey");
                if ("hash" in parameters.algorithm.algorithm) parameters.algorithm.algorithm.hash.name = shaAlgorithm;
                if (!(algorithmObject.name === "ECDSA")) {
                  _context21.next = 21;
                  break;
                }
                algorithmParamsChecked = false;
                if ("algorithmParams" in publicKeyInfo.algorithm === true) {
                  if ("idBlock" in publicKeyInfo.algorithm.algorithmParams) {
                    if (publicKeyInfo.algorithm.algorithmParams.idBlock.tagClass === 1 && publicKeyInfo.algorithm.algorithmParams.idBlock.tagNumber === 6) algorithmParamsChecked = true;
                  }
                }
                if (!(algorithmParamsChecked === false)) {
                  _context21.next = 19;
                  break;
                }
                throw new Error("Incorrect type for ECDSA public key parameters");
              case 19:
                curveObject = this.getAlgorithmByOID(publicKeyInfo.algorithm.algorithmParams.valueBlock.toString(), true);
                parameters.algorithm.algorithm.namedCurve = curveObject.name;
              case 21:
                _context21.next = 23;
                return this.getPublicKey(publicKeyInfo, null, parameters);
              case 23:
                publicKey = _context21.sent;
              case 24:
                algorithm = this.getAlgorithmParameters(publicKey.algorithm.name, "verify");
                if ("hash" in algorithm.algorithm) algorithm.algorithm.hash.name = shaAlgorithm;
                signatureValue = signature.valueBlock.valueHexView;
                if (!(publicKey.algorithm.name === "ECDSA")) {
                  _context21.next = 34;
                  break;
                }
                namedCurve = ECNamedCurves.find(publicKey.algorithm.namedCurve);
                if (namedCurve) {
                  _context21.next = 31;
                  break;
                }
                throw new Error("Unsupported named curve in use");
              case 31:
                asn1 = _fromBER(signatureValue);
                AsnError.assert(asn1, "Signature value");
                signatureValue = createECDSASignatureFromCMS(asn1.result, namedCurve.size);
              case 34:
                if (publicKey.algorithm.name === "RSA-PSS") {
                  pssParameters = new RSASSAPSSParams({
                    schema: signatureAlgorithm.algorithmParams
                  });
                  if ("saltLength" in pssParameters) algorithm.algorithm.saltLength = pssParameters.saltLength;else algorithm.algorithm.saltLength = 20;
                  hashAlgo = "SHA-1";
                  if ("hashAlgorithm" in pssParameters) {
                    hashAlgorithm = this.getAlgorithmByOID(pssParameters.hashAlgorithm.algorithmId, true);
                    hashAlgo = hashAlgorithm.name;
                  }
                  algorithm.algorithm.hash.name = hashAlgo;
                }
                return _context21.abrupt("return", this.verify(algorithm.algorithm, publicKey, signatureValue, data));
              case 36:
              case "end":
                return _context21.stop();
            }
          }, _callee21, this);
        }));
        function verifyWithPublicKey(_x31, _x32, _x33, _x34, _x35) {
          return _verifyWithPublicKey.apply(this, arguments);
        }
        return verifyWithPublicKey;
      }()
    }]);
  }(AbstractCryptoEngine);
  var engine = {
    name: "none",
    crypto: null
  };
  function isCryptoEngine(engine) {
    return engine && _typeof(engine) === "object" && "crypto" in engine ? true : false;
  }
  function _setEngine(name) {
    var crypto = null;
    if ((arguments.length <= 1 ? 0 : arguments.length - 1) < 2) {
      if (arguments.length <= 1 ? 0 : arguments.length - 1) {
        crypto = arguments.length <= 1 ? undefined : arguments[1];
      } else {
        crypto = typeof self !== "undefined" && self.crypto ? new CryptoEngine({
          name: "browser",
          crypto: self.crypto
        }) : null;
      }
    } else {
      var cryptoArg = arguments.length <= 1 ? undefined : arguments[1];
      var subtleArg = arguments.length <= 2 ? undefined : arguments[2];
      if (isCryptoEngine(subtleArg)) {
        crypto = subtleArg;
      } else if (isCryptoEngine(cryptoArg)) {
        crypto = cryptoArg;
      } else if ("subtle" in cryptoArg && "getRandomValues" in cryptoArg) {
        crypto = new CryptoEngine({
          crypto: cryptoArg
        });
      }
    }
    if (typeof process !== "undefined" && "pid" in process && typeof global !== "undefined" && typeof window === "undefined") {
      if (typeof global[process.pid] === "undefined") {
        global[process.pid] = {};
      } else {
        if (_typeof(global[process.pid]) !== "object") {
          throw new Error("Name global.".concat(process.pid, " already exists and it is not an object"));
        }
      }
      if (typeof global[process.pid].pkijs === "undefined") {
        global[process.pid].pkijs = {};
      } else {
        if (_typeof(global[process.pid].pkijs) !== "object") {
          throw new Error("Name global.".concat(process.pid, ".pkijs already exists and it is not an object"));
        }
      }
      global[process.pid].pkijs.engine = {
        name: name,
        crypto: crypto
      };
    } else {
      engine = {
        name: name,
        crypto: crypto
      };
    }
  }
  function getEngine() {
    if (typeof process !== "undefined" && "pid" in process && typeof global !== "undefined" && typeof window === "undefined") {
      var _engine;
      try {
        _engine = global[process.pid].pkijs.engine;
      } catch (ex) {
        throw new Error("Please call 'setEngine' before call to 'getEngine'");
      }
      return _engine;
    }
    return engine;
  }
  function getCrypto() {
    var safety = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var _engine = getEngine();
    if (!_engine.crypto && safety) {
      throw new Error("Unable to create WebCrypto object");
    }
    return _engine.crypto;
  }
  function createCMSECDSASignature(signatureBuffer) {
    if (signatureBuffer.byteLength % 2 !== 0) return EMPTY_BUFFER;
    var length = signatureBuffer.byteLength / 2;
    var rBuffer = new ArrayBuffer(length);
    var rView = new Uint8Array(rBuffer);
    rView.set(new Uint8Array(signatureBuffer, 0, length));
    var rInteger = new Integer({
      valueHex: rBuffer
    });
    var sBuffer = new ArrayBuffer(length);
    var sView = new Uint8Array(sBuffer);
    sView.set(new Uint8Array(signatureBuffer, length, length));
    var sInteger = new Integer({
      valueHex: sBuffer
    });
    return new Sequence({
      value: [rInteger.convertToDER(), sInteger.convertToDER()]
    }).toBER(false);
  }
  function createECDSASignatureFromCMS(cmsSignature, pointSize) {
    if (!(cmsSignature instanceof Sequence && cmsSignature.valueBlock.value.length === 2 && cmsSignature.valueBlock.value[0] instanceof Integer && cmsSignature.valueBlock.value[1] instanceof Integer)) return EMPTY_BUFFER;
    var rValueView = cmsSignature.valueBlock.value[0].convertFromDER().valueBlock.valueHexView;
    var sValueView = cmsSignature.valueBlock.value[1].convertFromDER().valueBlock.valueHexView;
    var res = new Uint8Array(pointSize * 2);
    res.set(rValueView, pointSize - rValueView.byteLength);
    res.set(sValueView, 2 * pointSize - sValueView.byteLength);
    return res.buffer;
  }
  function kdfWithCounter(_x36, _x37, _x38, _x39, _x40) {
    return _kdfWithCounter.apply(this, arguments);
  }
  function _kdfWithCounter() {
    _kdfWithCounter = _asyncToGenerator(_regeneratorRuntime().mark(function _callee102(hashFunction, zBuffer, Counter, SharedInfo, crypto) {
      var counterBuffer, counterView, combinedBuffer, result;
      return _regeneratorRuntime().wrap(function _callee102$(_context103) {
        while (1) switch (_context103.prev = _context103.next) {
          case 0:
            _context103.t0 = hashFunction.toUpperCase();
            _context103.next = _context103.t0 === "SHA-1" ? 3 : _context103.t0 === "SHA-256" ? 3 : _context103.t0 === "SHA-384" ? 3 : _context103.t0 === "SHA-512" ? 3 : 4;
            break;
          case 3:
            return _context103.abrupt("break", 5);
          case 4:
            throw new ArgumentError("Unknown hash function: ".concat(hashFunction));
          case 5:
            ArgumentError.assert(zBuffer, "zBuffer", "ArrayBuffer");
            if (!(zBuffer.byteLength === 0)) {
              _context103.next = 8;
              break;
            }
            throw new ArgumentError("'zBuffer' has zero length, error");
          case 8:
            ArgumentError.assert(SharedInfo, "SharedInfo", "ArrayBuffer");
            if (!(Counter > 255)) {
              _context103.next = 11;
              break;
            }
            throw new ArgumentError("Please set 'Counter' argument to value less or equal to 255");
          case 11:
            counterBuffer = new ArrayBuffer(4);
            counterView = new Uint8Array(counterBuffer);
            counterView[0] = 0x00;
            counterView[1] = 0x00;
            counterView[2] = 0x00;
            counterView[3] = Counter;
            combinedBuffer = EMPTY_BUFFER;
            combinedBuffer = utilConcatBuf(combinedBuffer, zBuffer);
            combinedBuffer = utilConcatBuf(combinedBuffer, counterBuffer);
            combinedBuffer = utilConcatBuf(combinedBuffer, SharedInfo);
            _context103.next = 23;
            return crypto.digest({
              name: hashFunction
            }, combinedBuffer);
          case 23:
            result = _context103.sent;
            return _context103.abrupt("return", {
              counter: Counter,
              result: result
            });
          case 25:
          case "end":
            return _context103.stop();
        }
      }, _callee102);
    }));
    return _kdfWithCounter.apply(this, arguments);
  }
  function kdf(_x41, _x42, _x43, _x44) {
    return _kdf.apply(this, arguments);
  }
  function _kdf() {
    _kdf = _asyncToGenerator(_regeneratorRuntime().mark(function _callee103(hashFunction, Zbuffer, keydatalen, SharedInfo) {
      var crypto,
        hashLength,
        maxCounter,
        quotient,
        incomingResult,
        i,
        combinedBuffer,
        currentCounter,
        found,
        _iterator49,
        _step49,
        _result13,
        newBuffer,
        newView,
        combinedView,
        _i49,
        _args104 = arguments;
      return _regeneratorRuntime().wrap(function _callee103$(_context104) {
        while (1) switch (_context104.prev = _context104.next) {
          case 0:
            crypto = _args104.length > 4 && _args104[4] !== undefined ? _args104[4] : getCrypto(true);
            hashLength = 0;
            maxCounter = 1;
            _context104.t0 = hashFunction.toUpperCase();
            _context104.next = _context104.t0 === "SHA-1" ? 6 : _context104.t0 === "SHA-256" ? 8 : _context104.t0 === "SHA-384" ? 10 : _context104.t0 === "SHA-512" ? 12 : 14;
            break;
          case 6:
            hashLength = 160;
            return _context104.abrupt("break", 15);
          case 8:
            hashLength = 256;
            return _context104.abrupt("break", 15);
          case 10:
            hashLength = 384;
            return _context104.abrupt("break", 15);
          case 12:
            hashLength = 512;
            return _context104.abrupt("break", 15);
          case 14:
            throw new ArgumentError("Unknown hash function: ".concat(hashFunction));
          case 15:
            ArgumentError.assert(Zbuffer, "Zbuffer", "ArrayBuffer");
            if (!(Zbuffer.byteLength === 0)) {
              _context104.next = 18;
              break;
            }
            throw new ArgumentError("'Zbuffer' has zero length, error");
          case 18:
            ArgumentError.assert(SharedInfo, "SharedInfo", "ArrayBuffer");
            quotient = keydatalen / hashLength;
            if (Math.floor(quotient) > 0) {
              maxCounter = Math.floor(quotient);
              if (quotient - maxCounter > 0) maxCounter++;
            }
            incomingResult = [];
            i = 1;
          case 23:
            if (!(i <= maxCounter)) {
              _context104.next = 32;
              break;
            }
            _context104.t1 = incomingResult;
            _context104.next = 27;
            return kdfWithCounter(hashFunction, Zbuffer, i, SharedInfo, crypto);
          case 27:
            _context104.t2 = _context104.sent;
            _context104.t1.push.call(_context104.t1, _context104.t2);
          case 29:
            i++;
            _context104.next = 23;
            break;
          case 32:
            combinedBuffer = EMPTY_BUFFER;
            currentCounter = 1;
            found = true;
          case 35:
            if (!found) {
              _context104.next = 59;
              break;
            }
            found = false;
            _iterator49 = _createForOfIteratorHelper(incomingResult);
            _context104.prev = 38;
            _iterator49.s();
          case 40:
            if ((_step49 = _iterator49.n()).done) {
              _context104.next = 48;
              break;
            }
            _result13 = _step49.value;
            if (!(_result13.counter === currentCounter)) {
              _context104.next = 46;
              break;
            }
            combinedBuffer = utilConcatBuf(combinedBuffer, _result13.result);
            found = true;
            return _context104.abrupt("break", 48);
          case 46:
            _context104.next = 40;
            break;
          case 48:
            _context104.next = 53;
            break;
          case 50:
            _context104.prev = 50;
            _context104.t3 = _context104["catch"](38);
            _iterator49.e(_context104.t3);
          case 53:
            _context104.prev = 53;
            _iterator49.f();
            return _context104.finish(53);
          case 56:
            currentCounter++;
            _context104.next = 35;
            break;
          case 59:
            keydatalen >>= 3;
            if (!(combinedBuffer.byteLength > keydatalen)) {
              _context104.next = 66;
              break;
            }
            newBuffer = new ArrayBuffer(keydatalen);
            newView = new Uint8Array(newBuffer);
            combinedView = new Uint8Array(combinedBuffer);
            for (_i49 = 0; _i49 < keydatalen; _i49++) newView[_i49] = combinedView[_i49];
            return _context104.abrupt("return", newBuffer);
          case 66:
            return _context104.abrupt("return", combinedBuffer);
          case 67:
          case "end":
            return _context104.stop();
        }
      }, _callee103, null, [[38, 50, 53, 56]]);
    }));
    return _kdf.apply(this, arguments);
  }
  var VERSION$i = "version";
  var LOG_ID = "logID";
  var EXTENSIONS$6 = "extensions";
  var TIMESTAMP = "timestamp";
  var HASH_ALGORITHM$3 = "hashAlgorithm";
  var SIGNATURE_ALGORITHM$8 = "signatureAlgorithm";
  var SIGNATURE$7 = "signature";
  var NONE = "none";
  var MD5 = "md5";
  var SHA1$1 = "sha1";
  var SHA224 = "sha224";
  var SHA256$1 = "sha256";
  var SHA384$1 = "sha384";
  var SHA512$1 = "sha512";
  var ANONYMOUS = "anonymous";
  var RSA = "rsa";
  var DSA = "dsa";
  var ECDSA$1 = "ecdsa";
  var SignedCertificateTimestamp = function (_PkiObject42) {
    function SignedCertificateTimestamp() {
      var _this101;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, SignedCertificateTimestamp);
      _this101 = _callSuper(this, SignedCertificateTimestamp);
      _this101.version = getParametersValue(parameters, VERSION$i, SignedCertificateTimestamp.defaultValues(VERSION$i));
      _this101.logID = getParametersValue(parameters, LOG_ID, SignedCertificateTimestamp.defaultValues(LOG_ID));
      _this101.timestamp = getParametersValue(parameters, TIMESTAMP, SignedCertificateTimestamp.defaultValues(TIMESTAMP));
      _this101.extensions = getParametersValue(parameters, EXTENSIONS$6, SignedCertificateTimestamp.defaultValues(EXTENSIONS$6));
      _this101.hashAlgorithm = getParametersValue(parameters, HASH_ALGORITHM$3, SignedCertificateTimestamp.defaultValues(HASH_ALGORITHM$3));
      _this101.signatureAlgorithm = getParametersValue(parameters, SIGNATURE_ALGORITHM$8, SignedCertificateTimestamp.defaultValues(SIGNATURE_ALGORITHM$8));
      _this101.signature = getParametersValue(parameters, SIGNATURE$7, SignedCertificateTimestamp.defaultValues(SIGNATURE$7));
      if ("stream" in parameters && parameters.stream) {
        _this101.fromStream(parameters.stream);
      }
      if (parameters.schema) {
        _this101.fromSchema(parameters.schema);
      }
      return _this101;
    }
    _inherits(SignedCertificateTimestamp, _PkiObject42);
    return _createClass(SignedCertificateTimestamp, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        if (schema instanceof RawData === false) throw new Error("Object's schema was not verified against input data for SignedCertificateTimestamp");
        var seqStream = new SeqStream({
          stream: new ByteStream({
            buffer: schema.data
          })
        });
        this.fromStream(seqStream);
      }
    }, {
      key: "fromStream",
      value: function fromStream(stream) {
        var blockLength = stream.getUint16();
        this.version = stream.getBlock(1)[0];
        if (this.version === 0) {
          this.logID = new Uint8Array(stream.getBlock(32)).buffer.slice(0);
          this.timestamp = new Date(utilFromBase(new Uint8Array(stream.getBlock(8)), 8));
          var extensionsLength = stream.getUint16();
          this.extensions = new Uint8Array(stream.getBlock(extensionsLength)).buffer.slice(0);
          switch (stream.getBlock(1)[0]) {
            case 0:
              this.hashAlgorithm = NONE;
              break;
            case 1:
              this.hashAlgorithm = MD5;
              break;
            case 2:
              this.hashAlgorithm = SHA1$1;
              break;
            case 3:
              this.hashAlgorithm = SHA224;
              break;
            case 4:
              this.hashAlgorithm = SHA256$1;
              break;
            case 5:
              this.hashAlgorithm = SHA384$1;
              break;
            case 6:
              this.hashAlgorithm = SHA512$1;
              break;
            default:
              throw new Error("Object's stream was not correct for SignedCertificateTimestamp");
          }
          switch (stream.getBlock(1)[0]) {
            case 0:
              this.signatureAlgorithm = ANONYMOUS;
              break;
            case 1:
              this.signatureAlgorithm = RSA;
              break;
            case 2:
              this.signatureAlgorithm = DSA;
              break;
            case 3:
              this.signatureAlgorithm = ECDSA$1;
              break;
            default:
              throw new Error("Object's stream was not correct for SignedCertificateTimestamp");
          }
          var signatureLength = stream.getUint16();
          var signatureData = new Uint8Array(stream.getBlock(signatureLength)).buffer.slice(0);
          var asn1 = _fromBER(signatureData);
          AsnError.assert(asn1, "SignedCertificateTimestamp");
          this.signature = asn1.result;
          if (blockLength !== 47 + extensionsLength + signatureLength) {
            throw new Error("Object's stream was not correct for SignedCertificateTimestamp");
          }
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var stream = this.toStream();
        return new RawData({
          data: stream.stream.buffer
        });
      }
    }, {
      key: "toStream",
      value: function toStream() {
        var stream = new SeqStream();
        stream.appendUint16(47 + this.extensions.byteLength + this.signature.valueBeforeDecodeView.byteLength);
        stream.appendChar(this.version);
        stream.appendView(new Uint8Array(this.logID));
        var timeBuffer = new ArrayBuffer(8);
        var timeView = new Uint8Array(timeBuffer);
        var baseArray = utilToBase(this.timestamp.valueOf(), 8);
        timeView.set(new Uint8Array(baseArray), 8 - baseArray.byteLength);
        stream.appendView(timeView);
        stream.appendUint16(this.extensions.byteLength);
        if (this.extensions.byteLength) stream.appendView(new Uint8Array(this.extensions));
        var _hashAlgorithm;
        switch (this.hashAlgorithm.toLowerCase()) {
          case NONE:
            _hashAlgorithm = 0;
            break;
          case MD5:
            _hashAlgorithm = 1;
            break;
          case SHA1$1:
            _hashAlgorithm = 2;
            break;
          case SHA224:
            _hashAlgorithm = 3;
            break;
          case SHA256$1:
            _hashAlgorithm = 4;
            break;
          case SHA384$1:
            _hashAlgorithm = 5;
            break;
          case SHA512$1:
            _hashAlgorithm = 6;
            break;
          default:
            throw new Error("Incorrect data for hashAlgorithm: ".concat(this.hashAlgorithm));
        }
        stream.appendChar(_hashAlgorithm);
        var _signatureAlgorithm;
        switch (this.signatureAlgorithm.toLowerCase()) {
          case ANONYMOUS:
            _signatureAlgorithm = 0;
            break;
          case RSA:
            _signatureAlgorithm = 1;
            break;
          case DSA:
            _signatureAlgorithm = 2;
            break;
          case ECDSA$1:
            _signatureAlgorithm = 3;
            break;
          default:
            throw new Error("Incorrect data for signatureAlgorithm: ".concat(this.signatureAlgorithm));
        }
        stream.appendChar(_signatureAlgorithm);
        var _signature = this.signature.toBER(false);
        stream.appendUint16(_signature.byteLength);
        stream.appendView(new Uint8Array(_signature));
        return stream;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          version: this.version,
          logID: bufferToHexCodes(this.logID),
          timestamp: this.timestamp,
          extensions: bufferToHexCodes(this.extensions),
          hashAlgorithm: this.hashAlgorithm,
          signatureAlgorithm: this.signatureAlgorithm,
          signature: this.signature.toJSON()
        };
      }
    }, {
      key: "verify",
      value: function () {
        var _verify2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee22(logs, data) {
          var dataType,
            crypto,
            logId,
            publicKeyBase64,
            stream,
            _iterator18,
            _step18,
            log,
            pki,
            publicKeyInfo,
            timeBuffer,
            timeView,
            baseArray,
            _args22 = arguments;
          return _regeneratorRuntime().wrap(function _callee22$(_context22) {
            while (1) switch (_context22.prev = _context22.next) {
              case 0:
                dataType = _args22.length > 2 && _args22[2] !== undefined ? _args22[2] : 0;
                crypto = _args22.length > 3 && _args22[3] !== undefined ? _args22[3] : getCrypto(true);
                logId = toBase64(arrayBufferToString(this.logID));
                publicKeyBase64 = null;
                stream = new SeqStream();
                _iterator18 = _createForOfIteratorHelper(logs);
                _context22.prev = 6;
                _iterator18.s();
              case 8:
                if ((_step18 = _iterator18.n()).done) {
                  _context22.next = 15;
                  break;
                }
                log = _step18.value;
                if (!(log.log_id === logId)) {
                  _context22.next = 13;
                  break;
                }
                publicKeyBase64 = log.key;
                return _context22.abrupt("break", 15);
              case 13:
                _context22.next = 8;
                break;
              case 15:
                _context22.next = 20;
                break;
              case 17:
                _context22.prev = 17;
                _context22.t0 = _context22["catch"](6);
                _iterator18.e(_context22.t0);
              case 20:
                _context22.prev = 20;
                _iterator18.f();
                return _context22.finish(20);
              case 23:
                if (publicKeyBase64) {
                  _context22.next = 25;
                  break;
                }
                throw new Error("Public key not found for CT with logId: ".concat(logId));
              case 25:
                pki = stringToArrayBuffer(fromBase64(publicKeyBase64));
                publicKeyInfo = PublicKeyInfo.fromBER(pki);
                stream.appendChar(0x00);
                stream.appendChar(0x00);
                timeBuffer = new ArrayBuffer(8);
                timeView = new Uint8Array(timeBuffer);
                baseArray = utilToBase(this.timestamp.valueOf(), 8);
                timeView.set(new Uint8Array(baseArray), 8 - baseArray.byteLength);
                stream.appendView(timeView);
                stream.appendUint16(dataType);
                if (dataType === 0) stream.appendUint24(data.byteLength);
                stream.appendView(new Uint8Array(data));
                stream.appendUint16(this.extensions.byteLength);
                if (this.extensions.byteLength !== 0) stream.appendView(new Uint8Array(this.extensions));
                return _context22.abrupt("return", crypto.verifyWithPublicKey(stream.buffer.slice(0, stream.length), new OctetString({
                  valueHex: this.signature.toBER(false)
                }), publicKeyInfo, {
                  algorithmId: EMPTY_STRING
                }, "SHA-256"));
              case 40:
              case "end":
                return _context22.stop();
            }
          }, _callee22, this, [[6, 17, 20, 23]]);
        }));
        function verify(_x45, _x46) {
          return _verify2.apply(this, arguments);
        }
        return verify;
      }()
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case VERSION$i:
            return 0;
          case LOG_ID:
          case EXTENSIONS$6:
            return EMPTY_BUFFER;
          case TIMESTAMP:
            return new Date(0);
          case HASH_ALGORITHM$3:
          case SIGNATURE_ALGORITHM$8:
            return EMPTY_STRING;
          case SIGNATURE$7:
            return new Any();
          default:
            return _superPropGet(SignedCertificateTimestamp, "defaultValues", this, 2)([memberName]);
        }
      }
    }]);
  }(PkiObject);
  SignedCertificateTimestamp.CLASS_NAME = "SignedCertificateTimestamp";
  var TIMESTAMPS = "timestamps";
  var SignedCertificateTimestampList = function (_PkiObject43) {
    function SignedCertificateTimestampList() {
      var _this102;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, SignedCertificateTimestampList);
      _this102 = _callSuper(this, SignedCertificateTimestampList);
      _this102.timestamps = getParametersValue(parameters, TIMESTAMPS, SignedCertificateTimestampList.defaultValues(TIMESTAMPS));
      if (parameters.schema) {
        _this102.fromSchema(parameters.schema);
      }
      return _this102;
    }
    _inherits(SignedCertificateTimestampList, _PkiObject43);
    return _createClass(SignedCertificateTimestampList, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        if (schema instanceof OctetString === false) {
          throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");
        }
        var seqStream = new SeqStream({
          stream: new ByteStream({
            buffer: schema.valueBlock.valueHex
          })
        });
        var dataLength = seqStream.getUint16();
        if (dataLength !== seqStream.length) {
          throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");
        }
        while (seqStream.length) {
          this.timestamps.push(new SignedCertificateTimestamp({
            stream: seqStream
          }));
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var stream = new SeqStream();
        var overallLength = 0;
        var timestampsData = [];
        var _iterator19 = _createForOfIteratorHelper(this.timestamps),
          _step19;
        try {
          for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
            var _timestamp = _step19.value;
            var timestampStream = _timestamp.toStream();
            timestampsData.push(timestampStream);
            overallLength += timestampStream.stream.buffer.byteLength;
          }
        } catch (err) {
          _iterator19.e(err);
        } finally {
          _iterator19.f();
        }
        stream.appendUint16(overallLength);
        for (var _i29 = 0, _timestampsData = timestampsData; _i29 < _timestampsData.length; _i29++) {
          var timestamp = _timestampsData[_i29];
          stream.appendView(timestamp.stream.view);
        }
        return new OctetString({
          valueHex: stream.stream.buffer.slice(0)
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          timestamps: Array.from(this.timestamps, function (o) {
            return o.toJSON();
          })
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case TIMESTAMPS:
            return [];
          default:
            return _superPropGet(SignedCertificateTimestampList, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case TIMESTAMPS:
            return memberValue.length === 0;
          default:
            return _superPropGet(SignedCertificateTimestampList, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var _a;
        var names = getParametersValue(parameters, "names", {});
        (_a = names.optional) !== null && _a !== void 0 ? _a : names.optional = false;
        return new OctetString({
          name: names.blockName || "SignedCertificateTimestampList",
          optional: names.optional
        });
      }
    }]);
  }(PkiObject);
  SignedCertificateTimestampList.CLASS_NAME = "SignedCertificateTimestampList";
  var ATTRIBUTES$4 = "attributes";
  var CLEAR_PROPS$11 = [ATTRIBUTES$4];
  var SubjectDirectoryAttributes = function (_PkiObject44) {
    function SubjectDirectoryAttributes() {
      var _this103;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, SubjectDirectoryAttributes);
      _this103 = _callSuper(this, SubjectDirectoryAttributes);
      _this103.attributes = getParametersValue(parameters, ATTRIBUTES$4, SubjectDirectoryAttributes.defaultValues(ATTRIBUTES$4));
      if (parameters.schema) {
        _this103.fromSchema(parameters.schema);
      }
      return _this103;
    }
    _inherits(SubjectDirectoryAttributes, _PkiObject44);
    return _createClass(SubjectDirectoryAttributes, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$11);
        var asn1 = compareSchema(schema, schema, SubjectDirectoryAttributes.schema({
          names: {
            attributes: ATTRIBUTES$4
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.attributes = Array.from(asn1.result.attributes, function (element) {
          return new Attribute({
            schema: element
          });
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: Array.from(this.attributes, function (o) {
            return o.toSchema();
          })
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          attributes: Array.from(this.attributes, function (o) {
            return o.toJSON();
          })
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case ATTRIBUTES$4:
            return [];
          default:
            return _superPropGet(SubjectDirectoryAttributes, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Repeated({
            name: names.attributes || EMPTY_STRING,
            value: Attribute.schema()
          })]
        });
      }
    }]);
  }(PkiObject);
  SubjectDirectoryAttributes.CLASS_NAME = "SubjectDirectoryAttributes";
  var ExtensionValueFactory = function () {
    function ExtensionValueFactory() {
      _classCallCheck(this, ExtensionValueFactory);
    }
    return _createClass(ExtensionValueFactory, null, [{
      key: "getItems",
      value: function getItems() {
        if (!this.types) {
          this.types = {};
          ExtensionValueFactory.register(id_SubjectAltName, "SubjectAltName", AltName);
          ExtensionValueFactory.register(id_IssuerAltName, "IssuerAltName", AltName);
          ExtensionValueFactory.register(id_AuthorityKeyIdentifier, "AuthorityKeyIdentifier", AuthorityKeyIdentifier);
          ExtensionValueFactory.register(id_BasicConstraints, "BasicConstraints", BasicConstraints);
          ExtensionValueFactory.register(id_MicrosoftCaVersion, "MicrosoftCaVersion", CAVersion);
          ExtensionValueFactory.register(id_CertificatePolicies, "CertificatePolicies", CertificatePolicies);
          ExtensionValueFactory.register(id_MicrosoftAppPolicies, "CertificatePoliciesMicrosoft", CertificatePolicies);
          ExtensionValueFactory.register(id_MicrosoftCertTemplateV2, "MicrosoftCertTemplateV2", CertificateTemplate);
          ExtensionValueFactory.register(id_CRLDistributionPoints, "CRLDistributionPoints", CRLDistributionPoints);
          ExtensionValueFactory.register(id_FreshestCRL, "FreshestCRL", CRLDistributionPoints);
          ExtensionValueFactory.register(id_ExtKeyUsage, "ExtKeyUsage", ExtKeyUsage);
          ExtensionValueFactory.register(id_CertificateIssuer, "CertificateIssuer", GeneralNames);
          ExtensionValueFactory.register(id_AuthorityInfoAccess, "AuthorityInfoAccess", InfoAccess);
          ExtensionValueFactory.register(id_SubjectInfoAccess, "SubjectInfoAccess", InfoAccess);
          ExtensionValueFactory.register(id_IssuingDistributionPoint, "IssuingDistributionPoint", IssuingDistributionPoint);
          ExtensionValueFactory.register(id_NameConstraints, "NameConstraints", NameConstraints);
          ExtensionValueFactory.register(id_PolicyConstraints, "PolicyConstraints", PolicyConstraints);
          ExtensionValueFactory.register(id_PolicyMappings, "PolicyMappings", PolicyMappings);
          ExtensionValueFactory.register(id_PrivateKeyUsagePeriod, "PrivateKeyUsagePeriod", PrivateKeyUsagePeriod);
          ExtensionValueFactory.register(id_QCStatements, "QCStatements", QCStatements);
          ExtensionValueFactory.register(id_SignedCertificateTimestampList, "SignedCertificateTimestampList", SignedCertificateTimestampList);
          ExtensionValueFactory.register(id_SubjectDirectoryAttributes, "SubjectDirectoryAttributes", SubjectDirectoryAttributes);
        }
        return this.types;
      }
    }, {
      key: "fromBER",
      value: function fromBER(id, raw) {
        var asn1 = _fromBER(raw);
        if (asn1.offset === -1) {
          return null;
        }
        var item = this.find(id);
        if (item) {
          try {
            return new item.type({
              schema: asn1.result
            });
          } catch (ex) {
            var res = new item.type();
            res.parsingError = "Incorrectly formatted value of extension ".concat(item.name, " (").concat(id, ")");
            return res;
          }
        }
        return asn1.result;
      }
    }, {
      key: "find",
      value: function find(id) {
        var types = this.getItems();
        return types[id] || null;
      }
    }, {
      key: "register",
      value: function register(id, name, type) {
        this.getItems()[id] = {
          name: name,
          type: type
        };
      }
    }]);
  }();
  var EXTN_ID = "extnID";
  var CRITICAL = "critical";
  var EXTN_VALUE = "extnValue";
  var PARSED_VALUE$5 = "parsedValue";
  var CLEAR_PROPS$10 = [EXTN_ID, CRITICAL, EXTN_VALUE];
  var Extension = function (_PkiObject45) {
    function Extension() {
      var _this104;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Extension);
      _this104 = _callSuper(this, Extension);
      _this104.extnID = getParametersValue(parameters, EXTN_ID, Extension.defaultValues(EXTN_ID));
      _this104.critical = getParametersValue(parameters, CRITICAL, Extension.defaultValues(CRITICAL));
      if (EXTN_VALUE in parameters) {
        _this104.extnValue = new OctetString({
          valueHex: parameters.extnValue
        });
      } else {
        _this104.extnValue = Extension.defaultValues(EXTN_VALUE);
      }
      if (PARSED_VALUE$5 in parameters) {
        _this104.parsedValue = getParametersValue(parameters, PARSED_VALUE$5, Extension.defaultValues(PARSED_VALUE$5));
      }
      if (parameters.schema) {
        _this104.fromSchema(parameters.schema);
      }
      return _this104;
    }
    _inherits(Extension, _PkiObject45);
    return _createClass(Extension, [{
      key: "parsedValue",
      get: function get() {
        if (this._parsedValue === undefined) {
          var parsedValue = ExtensionValueFactory.fromBER(this.extnID, this.extnValue.valueBlock.valueHexView);
          this._parsedValue = parsedValue;
        }
        return this._parsedValue || undefined;
      },
      set: function set(value) {
        this._parsedValue = value;
      }
    }, {
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$10);
        var asn1 = compareSchema(schema, schema, Extension.schema({
          names: {
            extnID: EXTN_ID,
            critical: CRITICAL,
            extnValue: EXTN_VALUE
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.extnID = asn1.result.extnID.valueBlock.toString();
        if (CRITICAL in asn1.result) {
          this.critical = asn1.result.critical.valueBlock.value;
        }
        this.extnValue = asn1.result.extnValue;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        outputArray.push(new ObjectIdentifier({
          value: this.extnID
        }));
        if (this.critical !== Extension.defaultValues(CRITICAL)) {
          outputArray.push(new Boolean$1({
            value: this.critical
          }));
        }
        outputArray.push(this.extnValue);
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var object = {
          extnID: this.extnID,
          extnValue: this.extnValue.toJSON()
        };
        if (this.critical !== Extension.defaultValues(CRITICAL)) {
          object.critical = this.critical;
        }
        if (this.parsedValue && this.parsedValue.toJSON) {
          object.parsedValue = this.parsedValue.toJSON();
        }
        return object;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case EXTN_ID:
            return EMPTY_STRING;
          case CRITICAL:
            return false;
          case EXTN_VALUE:
            return new OctetString();
          case PARSED_VALUE$5:
            return {};
          default:
            return _superPropGet(Extension, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new ObjectIdentifier({
            name: names.extnID || EMPTY_STRING
          }), new Boolean$1({
            name: names.critical || EMPTY_STRING,
            optional: true
          }), new OctetString({
            name: names.extnValue || EMPTY_STRING
          })]
        });
      }
    }]);
  }(PkiObject);
  Extension.CLASS_NAME = "Extension";
  var EXTENSIONS$5 = "extensions";
  var CLEAR_PROPS$$ = [EXTENSIONS$5];
  var Extensions = function (_PkiObject46) {
    function Extensions() {
      var _this105;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Extensions);
      _this105 = _callSuper(this, Extensions);
      _this105.extensions = getParametersValue(parameters, EXTENSIONS$5, Extensions.defaultValues(EXTENSIONS$5));
      if (parameters.schema) {
        _this105.fromSchema(parameters.schema);
      }
      return _this105;
    }
    _inherits(Extensions, _PkiObject46);
    return _createClass(Extensions, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$$);
        var asn1 = compareSchema(schema, schema, Extensions.schema({
          names: {
            extensions: EXTENSIONS$5
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.extensions = Array.from(asn1.result.extensions, function (element) {
          return new Extension({
            schema: element
          });
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: Array.from(this.extensions, function (o) {
            return o.toSchema();
          })
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          extensions: this.extensions.map(function (o) {
            return o.toJSON();
          })
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case EXTENSIONS$5:
            return [];
          default:
            return _superPropGet(Extensions, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var optional = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          optional: optional,
          name: names.blockName || EMPTY_STRING,
          value: [new Repeated({
            name: names.extensions || EMPTY_STRING,
            value: Extension.schema(names.extension || {})
          })]
        });
      }
    }]);
  }(PkiObject);
  Extensions.CLASS_NAME = "Extensions";
  var ISSUER$5 = "issuer";
  var SERIAL_NUMBER$6 = "serialNumber";
  var ISSUER_UID = "issuerUID";
  var CLEAR_PROPS$_ = [ISSUER$5, SERIAL_NUMBER$6, ISSUER_UID];
  var IssuerSerial = function (_PkiObject47) {
    function IssuerSerial() {
      var _this106;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, IssuerSerial);
      _this106 = _callSuper(this, IssuerSerial);
      _this106.issuer = getParametersValue(parameters, ISSUER$5, IssuerSerial.defaultValues(ISSUER$5));
      _this106.serialNumber = getParametersValue(parameters, SERIAL_NUMBER$6, IssuerSerial.defaultValues(SERIAL_NUMBER$6));
      if (ISSUER_UID in parameters) {
        _this106.issuerUID = getParametersValue(parameters, ISSUER_UID, IssuerSerial.defaultValues(ISSUER_UID));
      }
      if (parameters.schema) {
        _this106.fromSchema(parameters.schema);
      }
      return _this106;
    }
    _inherits(IssuerSerial, _PkiObject47);
    return _createClass(IssuerSerial, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$_);
        var asn1 = compareSchema(schema, schema, IssuerSerial.schema({
          names: {
            issuer: {
              names: {
                blockName: ISSUER$5
              }
            },
            serialNumber: SERIAL_NUMBER$6,
            issuerUID: ISSUER_UID
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.issuer = new GeneralNames({
          schema: asn1.result.issuer
        });
        this.serialNumber = asn1.result.serialNumber;
        if (ISSUER_UID in asn1.result) this.issuerUID = asn1.result.issuerUID;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var result = new Sequence({
          value: [this.issuer.toSchema(), this.serialNumber]
        });
        if (this.issuerUID) {
          result.valueBlock.value.push(this.issuerUID);
        }
        return result;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var result = {
          issuer: this.issuer.toJSON(),
          serialNumber: this.serialNumber.toJSON()
        };
        if (this.issuerUID) {
          result.issuerUID = this.issuerUID.toJSON();
        }
        return result;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case ISSUER$5:
            return new GeneralNames();
          case SERIAL_NUMBER$6:
            return new Integer();
          case ISSUER_UID:
            return new BitString();
          default:
            return _superPropGet(IssuerSerial, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [GeneralNames.schema(names.issuer || {}), new Integer({
            name: names.serialNumber || EMPTY_STRING
          }), new BitString({
            optional: true,
            name: names.issuerUID || EMPTY_STRING
          })]
        });
      }
    }]);
  }(PkiObject);
  IssuerSerial.CLASS_NAME = "IssuerSerial";
  var VERSION$h = "version";
  var BASE_CERTIFICATE_ID$2 = "baseCertificateID";
  var SUBJECT_NAME = "subjectName";
  var ISSUER$4 = "issuer";
  var SIGNATURE$6 = "signature";
  var SERIAL_NUMBER$5 = "serialNumber";
  var ATTR_CERT_VALIDITY_PERIOD$1 = "attrCertValidityPeriod";
  var ATTRIBUTES$3 = "attributes";
  var ISSUER_UNIQUE_ID$2 = "issuerUniqueID";
  var EXTENSIONS$4 = "extensions";
  var CLEAR_PROPS$Z = [VERSION$h, BASE_CERTIFICATE_ID$2, SUBJECT_NAME, ISSUER$4, SIGNATURE$6, SERIAL_NUMBER$5, ATTR_CERT_VALIDITY_PERIOD$1, ATTRIBUTES$3, ISSUER_UNIQUE_ID$2, EXTENSIONS$4];
  var AttributeCertificateInfoV1 = function (_PkiObject48) {
    function AttributeCertificateInfoV1() {
      var _this107;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, AttributeCertificateInfoV1);
      _this107 = _callSuper(this, AttributeCertificateInfoV1);
      _this107.version = getParametersValue(parameters, VERSION$h, AttributeCertificateInfoV1.defaultValues(VERSION$h));
      if (BASE_CERTIFICATE_ID$2 in parameters) {
        _this107.baseCertificateID = getParametersValue(parameters, BASE_CERTIFICATE_ID$2, AttributeCertificateInfoV1.defaultValues(BASE_CERTIFICATE_ID$2));
      }
      if (SUBJECT_NAME in parameters) {
        _this107.subjectName = getParametersValue(parameters, SUBJECT_NAME, AttributeCertificateInfoV1.defaultValues(SUBJECT_NAME));
      }
      _this107.issuer = getParametersValue(parameters, ISSUER$4, AttributeCertificateInfoV1.defaultValues(ISSUER$4));
      _this107.signature = getParametersValue(parameters, SIGNATURE$6, AttributeCertificateInfoV1.defaultValues(SIGNATURE$6));
      _this107.serialNumber = getParametersValue(parameters, SERIAL_NUMBER$5, AttributeCertificateInfoV1.defaultValues(SERIAL_NUMBER$5));
      _this107.attrCertValidityPeriod = getParametersValue(parameters, ATTR_CERT_VALIDITY_PERIOD$1, AttributeCertificateInfoV1.defaultValues(ATTR_CERT_VALIDITY_PERIOD$1));
      _this107.attributes = getParametersValue(parameters, ATTRIBUTES$3, AttributeCertificateInfoV1.defaultValues(ATTRIBUTES$3));
      if (ISSUER_UNIQUE_ID$2 in parameters) _this107.issuerUniqueID = getParametersValue(parameters, ISSUER_UNIQUE_ID$2, AttributeCertificateInfoV1.defaultValues(ISSUER_UNIQUE_ID$2));
      if (EXTENSIONS$4 in parameters) {
        _this107.extensions = getParametersValue(parameters, EXTENSIONS$4, AttributeCertificateInfoV1.defaultValues(EXTENSIONS$4));
      }
      if (parameters.schema) {
        _this107.fromSchema(parameters.schema);
      }
      return _this107;
    }
    _inherits(AttributeCertificateInfoV1, _PkiObject48);
    return _createClass(AttributeCertificateInfoV1, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$Z);
        var asn1 = compareSchema(schema, schema, AttributeCertificateInfoV1.schema({
          names: {
            version: VERSION$h,
            baseCertificateID: BASE_CERTIFICATE_ID$2,
            subjectName: SUBJECT_NAME,
            issuer: ISSUER$4,
            signature: {
              names: {
                blockName: SIGNATURE$6
              }
            },
            serialNumber: SERIAL_NUMBER$5,
            attrCertValidityPeriod: {
              names: {
                blockName: ATTR_CERT_VALIDITY_PERIOD$1
              }
            },
            attributes: ATTRIBUTES$3,
            issuerUniqueID: ISSUER_UNIQUE_ID$2,
            extensions: {
              names: {
                blockName: EXTENSIONS$4
              }
            }
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result.version.valueBlock.valueDec;
        if (BASE_CERTIFICATE_ID$2 in asn1.result) {
          this.baseCertificateID = new IssuerSerial({
            schema: new Sequence({
              value: asn1.result.baseCertificateID.valueBlock.value
            })
          });
        }
        if (SUBJECT_NAME in asn1.result) {
          this.subjectName = new GeneralNames({
            schema: new Sequence({
              value: asn1.result.subjectName.valueBlock.value
            })
          });
        }
        this.issuer = asn1.result.issuer;
        this.signature = new AlgorithmIdentifier({
          schema: asn1.result.signature
        });
        this.serialNumber = asn1.result.serialNumber;
        this.attrCertValidityPeriod = new AttCertValidityPeriod({
          schema: asn1.result.attrCertValidityPeriod
        });
        this.attributes = Array.from(asn1.result.attributes.valueBlock.value, function (element) {
          return new Attribute({
            schema: element
          });
        });
        if (ISSUER_UNIQUE_ID$2 in asn1.result) {
          this.issuerUniqueID = asn1.result.issuerUniqueID;
        }
        if (EXTENSIONS$4 in asn1.result) {
          this.extensions = new Extensions({
            schema: asn1.result.extensions
          });
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var result = new Sequence({
          value: [new Integer({
            value: this.version
          })]
        });
        if (this.baseCertificateID) {
          result.valueBlock.value.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: this.baseCertificateID.toSchema().valueBlock.value
          }));
        }
        if (this.subjectName) {
          result.valueBlock.value.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: this.subjectName.toSchema().valueBlock.value
          }));
        }
        result.valueBlock.value.push(this.issuer.toSchema());
        result.valueBlock.value.push(this.signature.toSchema());
        result.valueBlock.value.push(this.serialNumber);
        result.valueBlock.value.push(this.attrCertValidityPeriod.toSchema());
        result.valueBlock.value.push(new Sequence({
          value: Array.from(this.attributes, function (o) {
            return o.toSchema();
          })
        }));
        if (this.issuerUniqueID) {
          result.valueBlock.value.push(this.issuerUniqueID);
        }
        if (this.extensions) {
          result.valueBlock.value.push(this.extensions.toSchema());
        }
        return result;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var result = {
          version: this.version
        };
        if (this.baseCertificateID) {
          result.baseCertificateID = this.baseCertificateID.toJSON();
        }
        if (this.subjectName) {
          result.subjectName = this.subjectName.toJSON();
        }
        result.issuer = this.issuer.toJSON();
        result.signature = this.signature.toJSON();
        result.serialNumber = this.serialNumber.toJSON();
        result.attrCertValidityPeriod = this.attrCertValidityPeriod.toJSON();
        result.attributes = Array.from(this.attributes, function (o) {
          return o.toJSON();
        });
        if (this.issuerUniqueID) {
          result.issuerUniqueID = this.issuerUniqueID.toJSON();
        }
        if (this.extensions) {
          result.extensions = this.extensions.toJSON();
        }
        return result;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case VERSION$h:
            return 0;
          case BASE_CERTIFICATE_ID$2:
            return new IssuerSerial();
          case SUBJECT_NAME:
            return new GeneralNames();
          case ISSUER$4:
            return new GeneralNames();
          case SIGNATURE$6:
            return new AlgorithmIdentifier();
          case SERIAL_NUMBER$5:
            return new Integer();
          case ATTR_CERT_VALIDITY_PERIOD$1:
            return new AttCertValidityPeriod();
          case ATTRIBUTES$3:
            return [];
          case ISSUER_UNIQUE_ID$2:
            return new BitString();
          case EXTENSIONS$4:
            return new Extensions();
          default:
            return _superPropGet(AttributeCertificateInfoV1, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Integer({
            name: names.version || EMPTY_STRING
          }), new Choice({
            value: [new Constructed({
              name: names.baseCertificateID || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: IssuerSerial.schema().valueBlock.value
            }), new Constructed({
              name: names.subjectName || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: GeneralNames.schema().valueBlock.value
            })]
          }), GeneralNames.schema({
            names: {
              blockName: names.issuer || EMPTY_STRING
            }
          }), AlgorithmIdentifier.schema(names.signature || {}), new Integer({
            name: names.serialNumber || EMPTY_STRING
          }), AttCertValidityPeriod.schema(names.attrCertValidityPeriod || {}), new Sequence({
            name: names.attributes || EMPTY_STRING,
            value: [new Repeated({
              value: Attribute.schema()
            })]
          }), new BitString({
            optional: true,
            name: names.issuerUniqueID || EMPTY_STRING
          }), Extensions.schema(names.extensions || {}, true)]
        });
      }
    }]);
  }(PkiObject);
  AttributeCertificateInfoV1.CLASS_NAME = "AttributeCertificateInfoV1";
  var ACINFO$1 = "acinfo";
  var SIGNATURE_ALGORITHM$7 = "signatureAlgorithm";
  var SIGNATURE_VALUE$4 = "signatureValue";
  var CLEAR_PROPS$Y = [ACINFO$1, SIGNATURE_VALUE$4, SIGNATURE_ALGORITHM$7];
  var AttributeCertificateV1 = function (_PkiObject49) {
    function AttributeCertificateV1() {
      var _this108;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, AttributeCertificateV1);
      _this108 = _callSuper(this, AttributeCertificateV1);
      _this108.acinfo = getParametersValue(parameters, ACINFO$1, AttributeCertificateV1.defaultValues(ACINFO$1));
      _this108.signatureAlgorithm = getParametersValue(parameters, SIGNATURE_ALGORITHM$7, AttributeCertificateV1.defaultValues(SIGNATURE_ALGORITHM$7));
      _this108.signatureValue = getParametersValue(parameters, SIGNATURE_VALUE$4, AttributeCertificateV1.defaultValues(SIGNATURE_VALUE$4));
      if (parameters.schema) {
        _this108.fromSchema(parameters.schema);
      }
      return _this108;
    }
    _inherits(AttributeCertificateV1, _PkiObject49);
    return _createClass(AttributeCertificateV1, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$Y);
        var asn1 = compareSchema(schema, schema, AttributeCertificateV1.schema({
          names: {
            acinfo: {
              names: {
                blockName: ACINFO$1
              }
            },
            signatureAlgorithm: {
              names: {
                blockName: SIGNATURE_ALGORITHM$7
              }
            },
            signatureValue: SIGNATURE_VALUE$4
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.acinfo = new AttributeCertificateInfoV1({
          schema: asn1.result.acinfo
        });
        this.signatureAlgorithm = new AlgorithmIdentifier({
          schema: asn1.result.signatureAlgorithm
        });
        this.signatureValue = asn1.result.signatureValue;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: [this.acinfo.toSchema(), this.signatureAlgorithm.toSchema(), this.signatureValue]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          acinfo: this.acinfo.toJSON(),
          signatureAlgorithm: this.signatureAlgorithm.toJSON(),
          signatureValue: this.signatureValue.toJSON()
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case ACINFO$1:
            return new AttributeCertificateInfoV1();
          case SIGNATURE_ALGORITHM$7:
            return new AlgorithmIdentifier();
          case SIGNATURE_VALUE$4:
            return new BitString();
          default:
            return _superPropGet(AttributeCertificateV1, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [AttributeCertificateInfoV1.schema(names.acinfo || {}), AlgorithmIdentifier.schema(names.signatureAlgorithm || {}), new BitString({
            name: names.signatureValue || EMPTY_STRING
          })]
        });
      }
    }]);
  }(PkiObject);
  AttributeCertificateV1.CLASS_NAME = "AttributeCertificateV1";
  var DIGESTED_OBJECT_TYPE = "digestedObjectType";
  var OTHER_OBJECT_TYPE_ID = "otherObjectTypeID";
  var DIGEST_ALGORITHM$2 = "digestAlgorithm";
  var OBJECT_DIGEST = "objectDigest";
  var CLEAR_PROPS$X = [DIGESTED_OBJECT_TYPE, OTHER_OBJECT_TYPE_ID, DIGEST_ALGORITHM$2, OBJECT_DIGEST];
  var ObjectDigestInfo = function (_PkiObject50) {
    function ObjectDigestInfo() {
      var _this109;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, ObjectDigestInfo);
      _this109 = _callSuper(this, ObjectDigestInfo);
      _this109.digestedObjectType = getParametersValue(parameters, DIGESTED_OBJECT_TYPE, ObjectDigestInfo.defaultValues(DIGESTED_OBJECT_TYPE));
      if (OTHER_OBJECT_TYPE_ID in parameters) {
        _this109.otherObjectTypeID = getParametersValue(parameters, OTHER_OBJECT_TYPE_ID, ObjectDigestInfo.defaultValues(OTHER_OBJECT_TYPE_ID));
      }
      _this109.digestAlgorithm = getParametersValue(parameters, DIGEST_ALGORITHM$2, ObjectDigestInfo.defaultValues(DIGEST_ALGORITHM$2));
      _this109.objectDigest = getParametersValue(parameters, OBJECT_DIGEST, ObjectDigestInfo.defaultValues(OBJECT_DIGEST));
      if (parameters.schema) {
        _this109.fromSchema(parameters.schema);
      }
      return _this109;
    }
    _inherits(ObjectDigestInfo, _PkiObject50);
    return _createClass(ObjectDigestInfo, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$X);
        var asn1 = compareSchema(schema, schema, ObjectDigestInfo.schema({
          names: {
            digestedObjectType: DIGESTED_OBJECT_TYPE,
            otherObjectTypeID: OTHER_OBJECT_TYPE_ID,
            digestAlgorithm: {
              names: {
                blockName: DIGEST_ALGORITHM$2
              }
            },
            objectDigest: OBJECT_DIGEST
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.digestedObjectType = asn1.result.digestedObjectType;
        if (OTHER_OBJECT_TYPE_ID in asn1.result) {
          this.otherObjectTypeID = asn1.result.otherObjectTypeID;
        }
        this.digestAlgorithm = new AlgorithmIdentifier({
          schema: asn1.result.digestAlgorithm
        });
        this.objectDigest = asn1.result.objectDigest;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var result = new Sequence({
          value: [this.digestedObjectType]
        });
        if (this.otherObjectTypeID) {
          result.valueBlock.value.push(this.otherObjectTypeID);
        }
        result.valueBlock.value.push(this.digestAlgorithm.toSchema());
        result.valueBlock.value.push(this.objectDigest);
        return result;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var result = {
          digestedObjectType: this.digestedObjectType.toJSON(),
          digestAlgorithm: this.digestAlgorithm.toJSON(),
          objectDigest: this.objectDigest.toJSON()
        };
        if (this.otherObjectTypeID) {
          result.otherObjectTypeID = this.otherObjectTypeID.toJSON();
        }
        return result;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case DIGESTED_OBJECT_TYPE:
            return new Enumerated();
          case OTHER_OBJECT_TYPE_ID:
            return new ObjectIdentifier();
          case DIGEST_ALGORITHM$2:
            return new AlgorithmIdentifier();
          case OBJECT_DIGEST:
            return new BitString();
          default:
            return _superPropGet(ObjectDigestInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Enumerated({
            name: names.digestedObjectType || EMPTY_STRING
          }), new ObjectIdentifier({
            optional: true,
            name: names.otherObjectTypeID || EMPTY_STRING
          }), AlgorithmIdentifier.schema(names.digestAlgorithm || {}), new BitString({
            name: names.objectDigest || EMPTY_STRING
          })]
        });
      }
    }]);
  }(PkiObject);
  ObjectDigestInfo.CLASS_NAME = "ObjectDigestInfo";
  var ISSUER_NAME = "issuerName";
  var BASE_CERTIFICATE_ID$1 = "baseCertificateID";
  var OBJECT_DIGEST_INFO$1 = "objectDigestInfo";
  var CLEAR_PROPS$W = [ISSUER_NAME, BASE_CERTIFICATE_ID$1, OBJECT_DIGEST_INFO$1];
  var V2Form = function (_PkiObject51) {
    function V2Form() {
      var _this110;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, V2Form);
      _this110 = _callSuper(this, V2Form);
      if (ISSUER_NAME in parameters) {
        _this110.issuerName = getParametersValue(parameters, ISSUER_NAME, V2Form.defaultValues(ISSUER_NAME));
      }
      if (BASE_CERTIFICATE_ID$1 in parameters) {
        _this110.baseCertificateID = getParametersValue(parameters, BASE_CERTIFICATE_ID$1, V2Form.defaultValues(BASE_CERTIFICATE_ID$1));
      }
      if (OBJECT_DIGEST_INFO$1 in parameters) {
        _this110.objectDigestInfo = getParametersValue(parameters, OBJECT_DIGEST_INFO$1, V2Form.defaultValues(OBJECT_DIGEST_INFO$1));
      }
      if (parameters.schema) {
        _this110.fromSchema(parameters.schema);
      }
      return _this110;
    }
    _inherits(V2Form, _PkiObject51);
    return _createClass(V2Form, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$W);
        var asn1 = compareSchema(schema, schema, V2Form.schema({
          names: {
            issuerName: ISSUER_NAME,
            baseCertificateID: BASE_CERTIFICATE_ID$1,
            objectDigestInfo: OBJECT_DIGEST_INFO$1
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (ISSUER_NAME in asn1.result) this.issuerName = new GeneralNames({
          schema: asn1.result.issuerName
        });
        if (BASE_CERTIFICATE_ID$1 in asn1.result) {
          this.baseCertificateID = new IssuerSerial({
            schema: new Sequence({
              value: asn1.result.baseCertificateID.valueBlock.value
            })
          });
        }
        if (OBJECT_DIGEST_INFO$1 in asn1.result) {
          this.objectDigestInfo = new ObjectDigestInfo({
            schema: new Sequence({
              value: asn1.result.objectDigestInfo.valueBlock.value
            })
          });
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var result = new Sequence();
        if (this.issuerName) result.valueBlock.value.push(this.issuerName.toSchema());
        if (this.baseCertificateID) {
          result.valueBlock.value.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: this.baseCertificateID.toSchema().valueBlock.value
          }));
        }
        if (this.objectDigestInfo) {
          result.valueBlock.value.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: this.objectDigestInfo.toSchema().valueBlock.value
          }));
        }
        return result;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var result = {};
        if (this.issuerName) {
          result.issuerName = this.issuerName.toJSON();
        }
        if (this.baseCertificateID) {
          result.baseCertificateID = this.baseCertificateID.toJSON();
        }
        if (this.objectDigestInfo) {
          result.objectDigestInfo = this.objectDigestInfo.toJSON();
        }
        return result;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case ISSUER_NAME:
            return new GeneralNames();
          case BASE_CERTIFICATE_ID$1:
            return new IssuerSerial();
          case OBJECT_DIGEST_INFO$1:
            return new ObjectDigestInfo();
          default:
            return _superPropGet(V2Form, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [GeneralNames.schema({
            names: {
              blockName: names.issuerName
            }
          }, true), new Constructed({
            optional: true,
            name: names.baseCertificateID || EMPTY_STRING,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: IssuerSerial.schema().valueBlock.value
          }), new Constructed({
            optional: true,
            name: names.objectDigestInfo || EMPTY_STRING,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: ObjectDigestInfo.schema().valueBlock.value
          })]
        });
      }
    }]);
  }(PkiObject);
  V2Form.CLASS_NAME = "V2Form";
  var BASE_CERTIFICATE_ID = "baseCertificateID";
  var ENTITY_NAME = "entityName";
  var OBJECT_DIGEST_INFO = "objectDigestInfo";
  var CLEAR_PROPS$V = [BASE_CERTIFICATE_ID, ENTITY_NAME, OBJECT_DIGEST_INFO];
  var Holder = function (_PkiObject52) {
    function Holder() {
      var _this111;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Holder);
      _this111 = _callSuper(this, Holder);
      if (BASE_CERTIFICATE_ID in parameters) {
        _this111.baseCertificateID = getParametersValue(parameters, BASE_CERTIFICATE_ID, Holder.defaultValues(BASE_CERTIFICATE_ID));
      }
      if (ENTITY_NAME in parameters) {
        _this111.entityName = getParametersValue(parameters, ENTITY_NAME, Holder.defaultValues(ENTITY_NAME));
      }
      if (OBJECT_DIGEST_INFO in parameters) {
        _this111.objectDigestInfo = getParametersValue(parameters, OBJECT_DIGEST_INFO, Holder.defaultValues(OBJECT_DIGEST_INFO));
      }
      if (parameters.schema) {
        _this111.fromSchema(parameters.schema);
      }
      return _this111;
    }
    _inherits(Holder, _PkiObject52);
    return _createClass(Holder, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$V);
        var asn1 = compareSchema(schema, schema, Holder.schema({
          names: {
            baseCertificateID: BASE_CERTIFICATE_ID,
            entityName: ENTITY_NAME,
            objectDigestInfo: OBJECT_DIGEST_INFO
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (BASE_CERTIFICATE_ID in asn1.result) {
          this.baseCertificateID = new IssuerSerial({
            schema: new Sequence({
              value: asn1.result.baseCertificateID.valueBlock.value
            })
          });
        }
        if (ENTITY_NAME in asn1.result) {
          this.entityName = new GeneralNames({
            schema: new Sequence({
              value: asn1.result.entityName.valueBlock.value
            })
          });
        }
        if (OBJECT_DIGEST_INFO in asn1.result) {
          this.objectDigestInfo = new ObjectDigestInfo({
            schema: new Sequence({
              value: asn1.result.objectDigestInfo.valueBlock.value
            })
          });
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var result = new Sequence();
        if (this.baseCertificateID) {
          result.valueBlock.value.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: this.baseCertificateID.toSchema().valueBlock.value
          }));
        }
        if (this.entityName) {
          result.valueBlock.value.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: this.entityName.toSchema().valueBlock.value
          }));
        }
        if (this.objectDigestInfo) {
          result.valueBlock.value.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 2
            },
            value: this.objectDigestInfo.toSchema().valueBlock.value
          }));
        }
        return result;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var result = {};
        if (this.baseCertificateID) {
          result.baseCertificateID = this.baseCertificateID.toJSON();
        }
        if (this.entityName) {
          result.entityName = this.entityName.toJSON();
        }
        if (this.objectDigestInfo) {
          result.objectDigestInfo = this.objectDigestInfo.toJSON();
        }
        return result;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case BASE_CERTIFICATE_ID:
            return new IssuerSerial();
          case ENTITY_NAME:
            return new GeneralNames();
          case OBJECT_DIGEST_INFO:
            return new ObjectDigestInfo();
          default:
            return _superPropGet(Holder, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Constructed({
            optional: true,
            name: names.baseCertificateID || EMPTY_STRING,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: IssuerSerial.schema().valueBlock.value
          }), new Constructed({
            optional: true,
            name: names.entityName || EMPTY_STRING,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: GeneralNames.schema().valueBlock.value
          }), new Constructed({
            optional: true,
            name: names.objectDigestInfo || EMPTY_STRING,
            idBlock: {
              tagClass: 3,
              tagNumber: 2
            },
            value: ObjectDigestInfo.schema().valueBlock.value
          })]
        });
      }
    }]);
  }(PkiObject);
  Holder.CLASS_NAME = "Holder";
  var VERSION$g = "version";
  var HOLDER = "holder";
  var ISSUER$3 = "issuer";
  var SIGNATURE$5 = "signature";
  var SERIAL_NUMBER$4 = "serialNumber";
  var ATTR_CERT_VALIDITY_PERIOD = "attrCertValidityPeriod";
  var ATTRIBUTES$2 = "attributes";
  var ISSUER_UNIQUE_ID$1 = "issuerUniqueID";
  var EXTENSIONS$3 = "extensions";
  var CLEAR_PROPS$U = [VERSION$g, HOLDER, ISSUER$3, SIGNATURE$5, SERIAL_NUMBER$4, ATTR_CERT_VALIDITY_PERIOD, ATTRIBUTES$2, ISSUER_UNIQUE_ID$1, EXTENSIONS$3];
  var AttributeCertificateInfoV2 = function (_PkiObject53) {
    function AttributeCertificateInfoV2() {
      var _this112;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, AttributeCertificateInfoV2);
      _this112 = _callSuper(this, AttributeCertificateInfoV2);
      _this112.version = getParametersValue(parameters, VERSION$g, AttributeCertificateInfoV2.defaultValues(VERSION$g));
      _this112.holder = getParametersValue(parameters, HOLDER, AttributeCertificateInfoV2.defaultValues(HOLDER));
      _this112.issuer = getParametersValue(parameters, ISSUER$3, AttributeCertificateInfoV2.defaultValues(ISSUER$3));
      _this112.signature = getParametersValue(parameters, SIGNATURE$5, AttributeCertificateInfoV2.defaultValues(SIGNATURE$5));
      _this112.serialNumber = getParametersValue(parameters, SERIAL_NUMBER$4, AttributeCertificateInfoV2.defaultValues(SERIAL_NUMBER$4));
      _this112.attrCertValidityPeriod = getParametersValue(parameters, ATTR_CERT_VALIDITY_PERIOD, AttributeCertificateInfoV2.defaultValues(ATTR_CERT_VALIDITY_PERIOD));
      _this112.attributes = getParametersValue(parameters, ATTRIBUTES$2, AttributeCertificateInfoV2.defaultValues(ATTRIBUTES$2));
      if (ISSUER_UNIQUE_ID$1 in parameters) {
        _this112.issuerUniqueID = getParametersValue(parameters, ISSUER_UNIQUE_ID$1, AttributeCertificateInfoV2.defaultValues(ISSUER_UNIQUE_ID$1));
      }
      if (EXTENSIONS$3 in parameters) {
        _this112.extensions = getParametersValue(parameters, EXTENSIONS$3, AttributeCertificateInfoV2.defaultValues(EXTENSIONS$3));
      }
      if (parameters.schema) {
        _this112.fromSchema(parameters.schema);
      }
      return _this112;
    }
    _inherits(AttributeCertificateInfoV2, _PkiObject53);
    return _createClass(AttributeCertificateInfoV2, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$U);
        var asn1 = compareSchema(schema, schema, AttributeCertificateInfoV2.schema({
          names: {
            version: VERSION$g,
            holder: {
              names: {
                blockName: HOLDER
              }
            },
            issuer: ISSUER$3,
            signature: {
              names: {
                blockName: SIGNATURE$5
              }
            },
            serialNumber: SERIAL_NUMBER$4,
            attrCertValidityPeriod: {
              names: {
                blockName: ATTR_CERT_VALIDITY_PERIOD
              }
            },
            attributes: ATTRIBUTES$2,
            issuerUniqueID: ISSUER_UNIQUE_ID$1,
            extensions: {
              names: {
                blockName: EXTENSIONS$3
              }
            }
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result.version.valueBlock.valueDec;
        this.holder = new Holder({
          schema: asn1.result.holder
        });
        switch (asn1.result.issuer.idBlock.tagClass) {
          case 3:
            this.issuer = new V2Form({
              schema: new Sequence({
                value: asn1.result.issuer.valueBlock.value
              })
            });
            break;
          case 1:
          default:
            throw new Error("Incorrect value for 'issuer' in AttributeCertificateInfoV2");
        }
        this.signature = new AlgorithmIdentifier({
          schema: asn1.result.signature
        });
        this.serialNumber = asn1.result.serialNumber;
        this.attrCertValidityPeriod = new AttCertValidityPeriod({
          schema: asn1.result.attrCertValidityPeriod
        });
        this.attributes = Array.from(asn1.result.attributes.valueBlock.value, function (element) {
          return new Attribute({
            schema: element
          });
        });
        if (ISSUER_UNIQUE_ID$1 in asn1.result) {
          this.issuerUniqueID = asn1.result.issuerUniqueID;
        }
        if (EXTENSIONS$3 in asn1.result) {
          this.extensions = new Extensions({
            schema: asn1.result.extensions
          });
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var result = new Sequence({
          value: [new Integer({
            value: this.version
          }), this.holder.toSchema(), new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: this.issuer.toSchema().valueBlock.value
          }), this.signature.toSchema(), this.serialNumber, this.attrCertValidityPeriod.toSchema(), new Sequence({
            value: Array.from(this.attributes, function (o) {
              return o.toSchema();
            })
          })]
        });
        if (this.issuerUniqueID) {
          result.valueBlock.value.push(this.issuerUniqueID);
        }
        if (this.extensions) {
          result.valueBlock.value.push(this.extensions.toSchema());
        }
        return result;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var result = {
          version: this.version,
          holder: this.holder.toJSON(),
          issuer: this.issuer.toJSON(),
          signature: this.signature.toJSON(),
          serialNumber: this.serialNumber.toJSON(),
          attrCertValidityPeriod: this.attrCertValidityPeriod.toJSON(),
          attributes: Array.from(this.attributes, function (o) {
            return o.toJSON();
          })
        };
        if (this.issuerUniqueID) {
          result.issuerUniqueID = this.issuerUniqueID.toJSON();
        }
        if (this.extensions) {
          result.extensions = this.extensions.toJSON();
        }
        return result;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case VERSION$g:
            return 1;
          case HOLDER:
            return new Holder();
          case ISSUER$3:
            return {};
          case SIGNATURE$5:
            return new AlgorithmIdentifier();
          case SERIAL_NUMBER$4:
            return new Integer();
          case ATTR_CERT_VALIDITY_PERIOD:
            return new AttCertValidityPeriod();
          case ATTRIBUTES$2:
            return [];
          case ISSUER_UNIQUE_ID$1:
            return new BitString();
          case EXTENSIONS$3:
            return new Extensions();
          default:
            return _superPropGet(AttributeCertificateInfoV2, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Integer({
            name: names.version || EMPTY_STRING
          }), Holder.schema(names.holder || {}), new Choice({
            value: [GeneralNames.schema({
              names: {
                blockName: names.issuer || EMPTY_STRING
              }
            }), new Constructed({
              name: names.issuer || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: V2Form.schema().valueBlock.value
            })]
          }), AlgorithmIdentifier.schema(names.signature || {}), new Integer({
            name: names.serialNumber || EMPTY_STRING
          }), AttCertValidityPeriod.schema(names.attrCertValidityPeriod || {}), new Sequence({
            name: names.attributes || EMPTY_STRING,
            value: [new Repeated({
              value: Attribute.schema()
            })]
          }), new BitString({
            optional: true,
            name: names.issuerUniqueID || EMPTY_STRING
          }), Extensions.schema(names.extensions || {}, true)]
        });
      }
    }]);
  }(PkiObject);
  AttributeCertificateInfoV2.CLASS_NAME = "AttributeCertificateInfoV2";
  var ACINFO = "acinfo";
  var SIGNATURE_ALGORITHM$6 = "signatureAlgorithm";
  var SIGNATURE_VALUE$3 = "signatureValue";
  var CLEAR_PROPS$T = [ACINFO, SIGNATURE_ALGORITHM$6, SIGNATURE_VALUE$3];
  var AttributeCertificateV2 = function (_PkiObject54) {
    function AttributeCertificateV2() {
      var _this113;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, AttributeCertificateV2);
      _this113 = _callSuper(this, AttributeCertificateV2);
      _this113.acinfo = getParametersValue(parameters, ACINFO, AttributeCertificateV2.defaultValues(ACINFO));
      _this113.signatureAlgorithm = getParametersValue(parameters, SIGNATURE_ALGORITHM$6, AttributeCertificateV2.defaultValues(SIGNATURE_ALGORITHM$6));
      _this113.signatureValue = getParametersValue(parameters, SIGNATURE_VALUE$3, AttributeCertificateV2.defaultValues(SIGNATURE_VALUE$3));
      if (parameters.schema) {
        _this113.fromSchema(parameters.schema);
      }
      return _this113;
    }
    _inherits(AttributeCertificateV2, _PkiObject54);
    return _createClass(AttributeCertificateV2, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$T);
        var asn1 = compareSchema(schema, schema, AttributeCertificateV2.schema({
          names: {
            acinfo: {
              names: {
                blockName: ACINFO
              }
            },
            signatureAlgorithm: {
              names: {
                blockName: SIGNATURE_ALGORITHM$6
              }
            },
            signatureValue: SIGNATURE_VALUE$3
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.acinfo = new AttributeCertificateInfoV2({
          schema: asn1.result.acinfo
        });
        this.signatureAlgorithm = new AlgorithmIdentifier({
          schema: asn1.result.signatureAlgorithm
        });
        this.signatureValue = asn1.result.signatureValue;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: [this.acinfo.toSchema(), this.signatureAlgorithm.toSchema(), this.signatureValue]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          acinfo: this.acinfo.toJSON(),
          signatureAlgorithm: this.signatureAlgorithm.toJSON(),
          signatureValue: this.signatureValue.toJSON()
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case ACINFO:
            return new AttributeCertificateInfoV2();
          case SIGNATURE_ALGORITHM$6:
            return new AlgorithmIdentifier();
          case SIGNATURE_VALUE$3:
            return new BitString();
          default:
            return _superPropGet(AttributeCertificateV2, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [AttributeCertificateInfoV2.schema(names.acinfo || {}), AlgorithmIdentifier.schema(names.signatureAlgorithm || {}), new BitString({
            name: names.signatureValue || EMPTY_STRING
          })]
        });
      }
    }]);
  }(PkiObject);
  AttributeCertificateV2.CLASS_NAME = "AttributeCertificateV2";
  var CONTENT_TYPE = "contentType";
  var CONTENT = "content";
  var CLEAR_PROPS$S = [CONTENT_TYPE, CONTENT];
  var ContentInfo = function (_PkiObject55) {
    function ContentInfo() {
      var _this114;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, ContentInfo);
      _this114 = _callSuper(this, ContentInfo);
      _this114.contentType = getParametersValue(parameters, CONTENT_TYPE, ContentInfo.defaultValues(CONTENT_TYPE));
      _this114.content = getParametersValue(parameters, CONTENT, ContentInfo.defaultValues(CONTENT));
      if (parameters.schema) {
        _this114.fromSchema(parameters.schema);
      }
      return _this114;
    }
    _inherits(ContentInfo, _PkiObject55);
    return _createClass(ContentInfo, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$S);
        var asn1 = compareSchema(schema, schema, ContentInfo.schema());
        AsnError.assertSchema(asn1, this.className);
        this.contentType = asn1.result.contentType.valueBlock.toString();
        this.content = asn1.result.content;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: [new ObjectIdentifier({
            value: this.contentType
          }), new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [this.content]
          })]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var object = {
          contentType: this.contentType
        };
        if (!(this.content instanceof Any)) {
          object.content = this.content.toJSON();
        }
        return object;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case CONTENT_TYPE:
            return EMPTY_STRING;
          case CONTENT:
            return new Any();
          default:
            return _superPropGet(ContentInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case CONTENT_TYPE:
            return typeof memberValue === "string" && memberValue === this.defaultValues(CONTENT_TYPE);
          case CONTENT:
            return memberValue instanceof Any;
          default:
            return _superPropGet(ContentInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        if ("optional" in names === false) {
          names.optional = false;
        }
        return new Sequence({
          name: names.blockName || "ContentInfo",
          optional: names.optional,
          value: [new ObjectIdentifier({
            name: names.contentType || CONTENT_TYPE
          }), new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [new Any({
              name: names.content || CONTENT
            })]
          })]
        });
      }
    }]);
  }(PkiObject);
  ContentInfo.CLASS_NAME = "ContentInfo";
  ContentInfo.DATA = id_ContentType_Data;
  ContentInfo.SIGNED_DATA = id_ContentType_SignedData;
  ContentInfo.ENVELOPED_DATA = id_ContentType_EnvelopedData;
  ContentInfo.ENCRYPTED_DATA = id_ContentType_EncryptedData;
  var TYPE$1 = "type";
  var VALUE$4 = "value";
  var UTC_TIME_NAME = "utcTimeName";
  var GENERAL_TIME_NAME = "generalTimeName";
  var CLEAR_PROPS$R = [UTC_TIME_NAME, GENERAL_TIME_NAME];
  var TimeType;
  (function (TimeType) {
    TimeType[TimeType["UTCTime"] = 0] = "UTCTime";
    TimeType[TimeType["GeneralizedTime"] = 1] = "GeneralizedTime";
    TimeType[TimeType["empty"] = 2] = "empty";
  })(TimeType || (TimeType = {}));
  var Time = function (_PkiObject56) {
    function Time() {
      var _this115;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Time);
      _this115 = _callSuper(this, Time);
      _this115.type = getParametersValue(parameters, TYPE$1, Time.defaultValues(TYPE$1));
      _this115.value = getParametersValue(parameters, VALUE$4, Time.defaultValues(VALUE$4));
      if (parameters.schema) {
        _this115.fromSchema(parameters.schema);
      }
      return _this115;
    }
    _inherits(Time, _PkiObject56);
    return _createClass(Time, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$R);
        var asn1 = compareSchema(schema, schema, Time.schema({
          names: {
            utcTimeName: UTC_TIME_NAME,
            generalTimeName: GENERAL_TIME_NAME
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (UTC_TIME_NAME in asn1.result) {
          this.type = 0;
          this.value = asn1.result.utcTimeName.toDate();
        }
        if (GENERAL_TIME_NAME in asn1.result) {
          this.type = 1;
          this.value = asn1.result.generalTimeName.toDate();
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        if (this.type === 0) {
          return new UTCTime({
            valueDate: this.value
          });
        } else if (this.type === 1) {
          return new GeneralizedTime({
            valueDate: this.value
          });
        }
        return {};
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          type: this.type,
          value: this.value
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case TYPE$1:
            return 0;
          case VALUE$4:
            return new Date(0, 0, 0);
          default:
            return _superPropGet(Time, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var optional = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var names = getParametersValue(parameters, "names", {});
        return new Choice({
          optional: optional,
          value: [new UTCTime({
            name: names.utcTimeName || EMPTY_STRING
          }), new GeneralizedTime({
            name: names.generalTimeName || EMPTY_STRING
          })]
        });
      }
    }]);
  }(PkiObject);
  Time.CLASS_NAME = "Time";
  var TBS$4 = "tbs";
  var VERSION$f = "version";
  var SERIAL_NUMBER$3 = "serialNumber";
  var SIGNATURE$4 = "signature";
  var ISSUER$2 = "issuer";
  var NOT_BEFORE = "notBefore";
  var NOT_AFTER = "notAfter";
  var SUBJECT$1 = "subject";
  var SUBJECT_PUBLIC_KEY_INFO = "subjectPublicKeyInfo";
  var ISSUER_UNIQUE_ID = "issuerUniqueID";
  var SUBJECT_UNIQUE_ID = "subjectUniqueID";
  var EXTENSIONS$2 = "extensions";
  var SIGNATURE_ALGORITHM$5 = "signatureAlgorithm";
  var SIGNATURE_VALUE$2 = "signatureValue";
  var TBS_CERTIFICATE = "tbsCertificate";
  var TBS_CERTIFICATE_VERSION = "".concat(TBS_CERTIFICATE, ".").concat(VERSION$f);
  var TBS_CERTIFICATE_SERIAL_NUMBER = "".concat(TBS_CERTIFICATE, ".").concat(SERIAL_NUMBER$3);
  var TBS_CERTIFICATE_SIGNATURE = "".concat(TBS_CERTIFICATE, ".").concat(SIGNATURE$4);
  var TBS_CERTIFICATE_ISSUER = "".concat(TBS_CERTIFICATE, ".").concat(ISSUER$2);
  var TBS_CERTIFICATE_NOT_BEFORE = "".concat(TBS_CERTIFICATE, ".").concat(NOT_BEFORE);
  var TBS_CERTIFICATE_NOT_AFTER = "".concat(TBS_CERTIFICATE, ".").concat(NOT_AFTER);
  var TBS_CERTIFICATE_SUBJECT = "".concat(TBS_CERTIFICATE, ".").concat(SUBJECT$1);
  var TBS_CERTIFICATE_SUBJECT_PUBLIC_KEY = "".concat(TBS_CERTIFICATE, ".").concat(SUBJECT_PUBLIC_KEY_INFO);
  var TBS_CERTIFICATE_ISSUER_UNIQUE_ID = "".concat(TBS_CERTIFICATE, ".").concat(ISSUER_UNIQUE_ID);
  var TBS_CERTIFICATE_SUBJECT_UNIQUE_ID = "".concat(TBS_CERTIFICATE, ".").concat(SUBJECT_UNIQUE_ID);
  var TBS_CERTIFICATE_EXTENSIONS = "".concat(TBS_CERTIFICATE, ".").concat(EXTENSIONS$2);
  var CLEAR_PROPS$Q = [TBS_CERTIFICATE, TBS_CERTIFICATE_VERSION, TBS_CERTIFICATE_SERIAL_NUMBER, TBS_CERTIFICATE_SIGNATURE, TBS_CERTIFICATE_ISSUER, TBS_CERTIFICATE_NOT_BEFORE, TBS_CERTIFICATE_NOT_AFTER, TBS_CERTIFICATE_SUBJECT, TBS_CERTIFICATE_SUBJECT_PUBLIC_KEY, TBS_CERTIFICATE_ISSUER_UNIQUE_ID, TBS_CERTIFICATE_SUBJECT_UNIQUE_ID, TBS_CERTIFICATE_EXTENSIONS, SIGNATURE_ALGORITHM$5, SIGNATURE_VALUE$2];
  function tbsCertificate() {
    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var names = getParametersValue(parameters, "names", {});
    return new Sequence({
      name: names.blockName || TBS_CERTIFICATE,
      value: [new Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: [new Integer({
          name: names.tbsCertificateVersion || TBS_CERTIFICATE_VERSION
        })]
      }), new Integer({
        name: names.tbsCertificateSerialNumber || TBS_CERTIFICATE_SERIAL_NUMBER
      }), AlgorithmIdentifier.schema(names.signature || {
        names: {
          blockName: TBS_CERTIFICATE_SIGNATURE
        }
      }), RelativeDistinguishedNames.schema(names.issuer || {
        names: {
          blockName: TBS_CERTIFICATE_ISSUER
        }
      }), new Sequence({
        name: names.tbsCertificateValidity || "tbsCertificate.validity",
        value: [Time.schema(names.notBefore || {
          names: {
            utcTimeName: TBS_CERTIFICATE_NOT_BEFORE,
            generalTimeName: TBS_CERTIFICATE_NOT_BEFORE
          }
        }), Time.schema(names.notAfter || {
          names: {
            utcTimeName: TBS_CERTIFICATE_NOT_AFTER,
            generalTimeName: TBS_CERTIFICATE_NOT_AFTER
          }
        })]
      }), RelativeDistinguishedNames.schema(names.subject || {
        names: {
          blockName: TBS_CERTIFICATE_SUBJECT
        }
      }), PublicKeyInfo.schema(names.subjectPublicKeyInfo || {
        names: {
          blockName: TBS_CERTIFICATE_SUBJECT_PUBLIC_KEY
        }
      }), new Primitive({
        name: names.tbsCertificateIssuerUniqueID || TBS_CERTIFICATE_ISSUER_UNIQUE_ID,
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 1
        }
      }), new Primitive({
        name: names.tbsCertificateSubjectUniqueID || TBS_CERTIFICATE_SUBJECT_UNIQUE_ID,
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 2
        }
      }), new Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 3
        },
        value: [Extensions.schema(names.extensions || {
          names: {
            blockName: TBS_CERTIFICATE_EXTENSIONS
          }
        })]
      })]
    });
  }
  var Certificate = function (_PkiObject57) {
    function Certificate() {
      var _this116;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Certificate);
      _this116 = _callSuper(this, Certificate);
      _this116.tbsView = new Uint8Array(getParametersValue(parameters, TBS$4, Certificate.defaultValues(TBS$4)));
      _this116.version = getParametersValue(parameters, VERSION$f, Certificate.defaultValues(VERSION$f));
      _this116.serialNumber = getParametersValue(parameters, SERIAL_NUMBER$3, Certificate.defaultValues(SERIAL_NUMBER$3));
      _this116.signature = getParametersValue(parameters, SIGNATURE$4, Certificate.defaultValues(SIGNATURE$4));
      _this116.issuer = getParametersValue(parameters, ISSUER$2, Certificate.defaultValues(ISSUER$2));
      _this116.notBefore = getParametersValue(parameters, NOT_BEFORE, Certificate.defaultValues(NOT_BEFORE));
      _this116.notAfter = getParametersValue(parameters, NOT_AFTER, Certificate.defaultValues(NOT_AFTER));
      _this116.subject = getParametersValue(parameters, SUBJECT$1, Certificate.defaultValues(SUBJECT$1));
      _this116.subjectPublicKeyInfo = getParametersValue(parameters, SUBJECT_PUBLIC_KEY_INFO, Certificate.defaultValues(SUBJECT_PUBLIC_KEY_INFO));
      if (ISSUER_UNIQUE_ID in parameters) {
        _this116.issuerUniqueID = getParametersValue(parameters, ISSUER_UNIQUE_ID, Certificate.defaultValues(ISSUER_UNIQUE_ID));
      }
      if (SUBJECT_UNIQUE_ID in parameters) {
        _this116.subjectUniqueID = getParametersValue(parameters, SUBJECT_UNIQUE_ID, Certificate.defaultValues(SUBJECT_UNIQUE_ID));
      }
      if (EXTENSIONS$2 in parameters) {
        _this116.extensions = getParametersValue(parameters, EXTENSIONS$2, Certificate.defaultValues(EXTENSIONS$2));
      }
      _this116.signatureAlgorithm = getParametersValue(parameters, SIGNATURE_ALGORITHM$5, Certificate.defaultValues(SIGNATURE_ALGORITHM$5));
      _this116.signatureValue = getParametersValue(parameters, SIGNATURE_VALUE$2, Certificate.defaultValues(SIGNATURE_VALUE$2));
      if (parameters.schema) {
        _this116.fromSchema(parameters.schema);
      }
      return _this116;
    }
    _inherits(Certificate, _PkiObject57);
    return _createClass(Certificate, [{
      key: "tbs",
      get: function get() {
        return BufferSourceConverter.toArrayBuffer(this.tbsView);
      },
      set: function set(value) {
        this.tbsView = new Uint8Array(value);
      }
    }, {
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$Q);
        var asn1 = compareSchema(schema, schema, Certificate.schema({
          names: {
            tbsCertificate: {
              names: {
                extensions: {
                  names: {
                    extensions: TBS_CERTIFICATE_EXTENSIONS
                  }
                }
              }
            }
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.tbsView = asn1.result.tbsCertificate.valueBeforeDecodeView;
        if (TBS_CERTIFICATE_VERSION in asn1.result) this.version = asn1.result[TBS_CERTIFICATE_VERSION].valueBlock.valueDec;
        this.serialNumber = asn1.result[TBS_CERTIFICATE_SERIAL_NUMBER];
        this.signature = new AlgorithmIdentifier({
          schema: asn1.result[TBS_CERTIFICATE_SIGNATURE]
        });
        this.issuer = new RelativeDistinguishedNames({
          schema: asn1.result[TBS_CERTIFICATE_ISSUER]
        });
        this.notBefore = new Time({
          schema: asn1.result[TBS_CERTIFICATE_NOT_BEFORE]
        });
        this.notAfter = new Time({
          schema: asn1.result[TBS_CERTIFICATE_NOT_AFTER]
        });
        this.subject = new RelativeDistinguishedNames({
          schema: asn1.result[TBS_CERTIFICATE_SUBJECT]
        });
        this.subjectPublicKeyInfo = new PublicKeyInfo({
          schema: asn1.result[TBS_CERTIFICATE_SUBJECT_PUBLIC_KEY]
        });
        if (TBS_CERTIFICATE_ISSUER_UNIQUE_ID in asn1.result) this.issuerUniqueID = asn1.result[TBS_CERTIFICATE_ISSUER_UNIQUE_ID].valueBlock.valueHex;
        if (TBS_CERTIFICATE_SUBJECT_UNIQUE_ID in asn1.result) this.subjectUniqueID = asn1.result[TBS_CERTIFICATE_SUBJECT_UNIQUE_ID].valueBlock.valueHex;
        if (TBS_CERTIFICATE_EXTENSIONS in asn1.result) this.extensions = Array.from(asn1.result[TBS_CERTIFICATE_EXTENSIONS], function (element) {
          return new Extension({
            schema: element
          });
        });
        this.signatureAlgorithm = new AlgorithmIdentifier({
          schema: asn1.result.signatureAlgorithm
        });
        this.signatureValue = asn1.result.signatureValue;
      }
    }, {
      key: "encodeTBS",
      value: function encodeTBS() {
        var outputArray = [];
        if (VERSION$f in this && this.version !== Certificate.defaultValues(VERSION$f)) {
          outputArray.push(new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [new Integer({
              value: this.version
            })]
          }));
        }
        outputArray.push(this.serialNumber);
        outputArray.push(this.signature.toSchema());
        outputArray.push(this.issuer.toSchema());
        outputArray.push(new Sequence({
          value: [this.notBefore.toSchema(), this.notAfter.toSchema()]
        }));
        outputArray.push(this.subject.toSchema());
        outputArray.push(this.subjectPublicKeyInfo.toSchema());
        if (this.issuerUniqueID) {
          outputArray.push(new Primitive({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            valueHex: this.issuerUniqueID
          }));
        }
        if (this.subjectUniqueID) {
          outputArray.push(new Primitive({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 2
            },
            valueHex: this.subjectUniqueID
          }));
        }
        if (this.extensions) {
          outputArray.push(new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 3
            },
            value: [new Sequence({
              value: Array.from(this.extensions, function (o) {
                return o.toSchema();
              })
            })]
          }));
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var encodeFlag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var tbsSchema;
        if (encodeFlag === false) {
          if (!this.tbsView.byteLength) {
            return Certificate.schema().value[0];
          }
          var asn1 = _fromBER(this.tbsView);
          AsnError.assert(asn1, "TBS Certificate");
          tbsSchema = asn1.result;
        } else {
          tbsSchema = this.encodeTBS();
        }
        return new Sequence({
          value: [tbsSchema, this.signatureAlgorithm.toSchema(), this.signatureValue]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          tbs: Convert.ToHex(this.tbsView),
          version: this.version,
          serialNumber: this.serialNumber.toJSON(),
          signature: this.signature.toJSON(),
          issuer: this.issuer.toJSON(),
          notBefore: this.notBefore.toJSON(),
          notAfter: this.notAfter.toJSON(),
          subject: this.subject.toJSON(),
          subjectPublicKeyInfo: this.subjectPublicKeyInfo.toJSON(),
          signatureAlgorithm: this.signatureAlgorithm.toJSON(),
          signatureValue: this.signatureValue.toJSON()
        };
        if (VERSION$f in this && this.version !== Certificate.defaultValues(VERSION$f)) {
          res.version = this.version;
        }
        if (this.issuerUniqueID) {
          res.issuerUniqueID = Convert.ToHex(this.issuerUniqueID);
        }
        if (this.subjectUniqueID) {
          res.subjectUniqueID = Convert.ToHex(this.subjectUniqueID);
        }
        if (this.extensions) {
          res.extensions = Array.from(this.extensions, function (o) {
            return o.toJSON();
          });
        }
        return res;
      }
    }, {
      key: "getPublicKey",
      value: function () {
        var _getPublicKey2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee23(parameters) {
          var crypto,
            _args23 = arguments;
          return _regeneratorRuntime().wrap(function _callee23$(_context23) {
            while (1) switch (_context23.prev = _context23.next) {
              case 0:
                crypto = _args23.length > 1 && _args23[1] !== undefined ? _args23[1] : getCrypto(true);
                return _context23.abrupt("return", crypto.getPublicKey(this.subjectPublicKeyInfo, this.signatureAlgorithm, parameters));
              case 2:
              case "end":
                return _context23.stop();
            }
          }, _callee23, this);
        }));
        function getPublicKey(_x47) {
          return _getPublicKey2.apply(this, arguments);
        }
        return getPublicKey;
      }()
    }, {
      key: "getKeyHash",
      value: function () {
        var _getKeyHash = _asyncToGenerator(_regeneratorRuntime().mark(function _callee24() {
          var hashAlgorithm,
            crypto,
            _args24 = arguments;
          return _regeneratorRuntime().wrap(function _callee24$(_context24) {
            while (1) switch (_context24.prev = _context24.next) {
              case 0:
                hashAlgorithm = _args24.length > 0 && _args24[0] !== undefined ? _args24[0] : "SHA-1";
                crypto = _args24.length > 1 && _args24[1] !== undefined ? _args24[1] : getCrypto(true);
                return _context24.abrupt("return", crypto.digest({
                  name: hashAlgorithm
                }, this.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView));
              case 3:
              case "end":
                return _context24.stop();
            }
          }, _callee24, this);
        }));
        function getKeyHash() {
          return _getKeyHash.apply(this, arguments);
        }
        return getKeyHash;
      }()
    }, {
      key: "sign",
      value: function () {
        var _sign = _asyncToGenerator(_regeneratorRuntime().mark(function _callee25(privateKey) {
          var hashAlgorithm,
            crypto,
            signatureParameters,
            parameters,
            signature,
            _args25 = arguments;
          return _regeneratorRuntime().wrap(function _callee25$(_context25) {
            while (1) switch (_context25.prev = _context25.next) {
              case 0:
                hashAlgorithm = _args25.length > 1 && _args25[1] !== undefined ? _args25[1] : "SHA-1";
                crypto = _args25.length > 2 && _args25[2] !== undefined ? _args25[2] : getCrypto(true);
                if (privateKey) {
                  _context25.next = 4;
                  break;
                }
                throw new Error("Need to provide a private key for signing");
              case 4:
                _context25.next = 6;
                return crypto.getSignatureParameters(privateKey, hashAlgorithm);
              case 6:
                signatureParameters = _context25.sent;
                parameters = signatureParameters.parameters;
                this.signature = signatureParameters.signatureAlgorithm;
                this.signatureAlgorithm = signatureParameters.signatureAlgorithm;
                this.tbsView = new Uint8Array(this.encodeTBS().toBER());
                _context25.next = 13;
                return crypto.signWithPrivateKey(this.tbsView, privateKey, parameters);
              case 13:
                signature = _context25.sent;
                this.signatureValue = new BitString({
                  valueHex: signature
                });
              case 15:
              case "end":
                return _context25.stop();
            }
          }, _callee25, this);
        }));
        function sign(_x48) {
          return _sign.apply(this, arguments);
        }
        return sign;
      }()
    }, {
      key: "verify",
      value: function () {
        var _verify3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee26(issuerCertificate) {
          var crypto,
            subjectPublicKeyInfo,
            _args26 = arguments;
          return _regeneratorRuntime().wrap(function _callee26$(_context26) {
            while (1) switch (_context26.prev = _context26.next) {
              case 0:
                crypto = _args26.length > 1 && _args26[1] !== undefined ? _args26[1] : getCrypto(true);
                if (issuerCertificate) {
                  subjectPublicKeyInfo = issuerCertificate.subjectPublicKeyInfo;
                } else if (this.issuer.isEqual(this.subject)) {
                  subjectPublicKeyInfo = this.subjectPublicKeyInfo;
                }
                if (subjectPublicKeyInfo instanceof PublicKeyInfo) {
                  _context26.next = 4;
                  break;
                }
                throw new Error("Please provide issuer certificate as a parameter");
              case 4:
                return _context26.abrupt("return", crypto.verifyWithPublicKey(this.tbsView, this.signatureValue, subjectPublicKeyInfo, this.signatureAlgorithm));
              case 5:
              case "end":
                return _context26.stop();
            }
          }, _callee26, this);
        }));
        function verify(_x49) {
          return _verify3.apply(this, arguments);
        }
        return verify;
      }()
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case TBS$4:
            return EMPTY_BUFFER;
          case VERSION$f:
            return 0;
          case SERIAL_NUMBER$3:
            return new Integer();
          case SIGNATURE$4:
            return new AlgorithmIdentifier();
          case ISSUER$2:
            return new RelativeDistinguishedNames();
          case NOT_BEFORE:
            return new Time();
          case NOT_AFTER:
            return new Time();
          case SUBJECT$1:
            return new RelativeDistinguishedNames();
          case SUBJECT_PUBLIC_KEY_INFO:
            return new PublicKeyInfo();
          case ISSUER_UNIQUE_ID:
            return EMPTY_BUFFER;
          case SUBJECT_UNIQUE_ID:
            return EMPTY_BUFFER;
          case EXTENSIONS$2:
            return [];
          case SIGNATURE_ALGORITHM$5:
            return new AlgorithmIdentifier();
          case SIGNATURE_VALUE$2:
            return new BitString();
          default:
            return _superPropGet(Certificate, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [tbsCertificate(names.tbsCertificate), AlgorithmIdentifier.schema(names.signatureAlgorithm || {
            names: {
              blockName: SIGNATURE_ALGORITHM$5
            }
          }), new BitString({
            name: names.signatureValue || SIGNATURE_VALUE$2
          })]
        });
      }
    }]);
  }(PkiObject);
  Certificate.CLASS_NAME = "Certificate";
  function checkCA(cert) {
    var signerCert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    if (signerCert && cert.issuer.isEqual(signerCert.issuer) && cert.serialNumber.isEqual(signerCert.serialNumber)) {
      return null;
    }
    var isCA = false;
    if (cert.extensions) {
      var _iterator20 = _createForOfIteratorHelper(cert.extensions),
        _step20;
      try {
        for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
          var extension = _step20.value;
          if (extension.extnID === id_BasicConstraints && extension.parsedValue instanceof BasicConstraints) {
            if (extension.parsedValue.cA) {
              isCA = true;
              break;
            }
          }
        }
      } catch (err) {
        _iterator20.e(err);
      } finally {
        _iterator20.f();
      }
    }
    if (isCA) {
      return cert;
    }
    return null;
  }
  var CERT_ID$1 = "certId";
  var CERT_VALUE = "certValue";
  var PARSED_VALUE$4 = "parsedValue";
  var CLEAR_PROPS$P = [CERT_ID$1, CERT_VALUE];
  var CertBag = function (_PkiObject58) {
    function CertBag() {
      var _this117;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, CertBag);
      _this117 = _callSuper(this, CertBag);
      _this117.certId = getParametersValue(parameters, CERT_ID$1, CertBag.defaultValues(CERT_ID$1));
      _this117.certValue = getParametersValue(parameters, CERT_VALUE, CertBag.defaultValues(CERT_VALUE));
      if (PARSED_VALUE$4 in parameters) {
        _this117.parsedValue = getParametersValue(parameters, PARSED_VALUE$4, CertBag.defaultValues(PARSED_VALUE$4));
      }
      if (parameters.schema) {
        _this117.fromSchema(parameters.schema);
      }
      return _this117;
    }
    _inherits(CertBag, _PkiObject58);
    return _createClass(CertBag, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$P);
        var asn1 = compareSchema(schema, schema, CertBag.schema({
          names: {
            id: CERT_ID$1,
            value: CERT_VALUE
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.certId = asn1.result.certId.valueBlock.toString();
        this.certValue = asn1.result.certValue;
        var certValueHex = this.certValue.valueBlock.valueHexView;
        switch (this.certId) {
          case id_CertBag_X509Certificate:
            {
              try {
                this.parsedValue = Certificate.fromBER(certValueHex);
              } catch (ex) {
                AttributeCertificateV2.fromBER(certValueHex);
              }
            }
            break;
          case id_CertBag_AttributeCertificate:
            {
              this.parsedValue = AttributeCertificateV2.fromBER(certValueHex);
            }
            break;
          case id_CertBag_SDSICertificate:
          default:
            throw new Error("Incorrect CERT_ID value in CertBag: ".concat(this.certId));
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        if (PARSED_VALUE$4 in this) {
          if ("acinfo" in this.parsedValue) {
            this.certId = id_CertBag_AttributeCertificate;
          } else {
            this.certId = id_CertBag_X509Certificate;
          }
          this.certValue = new OctetString({
            valueHex: this.parsedValue.toSchema().toBER(false)
          });
        }
        return new Sequence({
          value: [new ObjectIdentifier({
            value: this.certId
          }), new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: ["toSchema" in this.certValue ? this.certValue.toSchema() : this.certValue]
          })]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          certId: this.certId,
          certValue: this.certValue.toJSON()
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case CERT_ID$1:
            return EMPTY_STRING;
          case CERT_VALUE:
            return new Any();
          case PARSED_VALUE$4:
            return {};
          default:
            return _superPropGet(CertBag, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case CERT_ID$1:
            return memberValue === EMPTY_STRING;
          case CERT_VALUE:
            return memberValue instanceof Any;
          case PARSED_VALUE$4:
            return memberValue instanceof Object && Object.keys(memberValue).length === 0;
          default:
            return _superPropGet(CertBag, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new ObjectIdentifier({
            name: names.id || "id"
          }), new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [new Any({
              name: names.value || "value"
            })]
          })]
        });
      }
    }]);
  }(PkiObject);
  CertBag.CLASS_NAME = "CertBag";
  var USER_CERTIFICATE = "userCertificate";
  var REVOCATION_DATE = "revocationDate";
  var CRL_ENTRY_EXTENSIONS = "crlEntryExtensions";
  var CLEAR_PROPS$O = [USER_CERTIFICATE, REVOCATION_DATE, CRL_ENTRY_EXTENSIONS];
  var RevokedCertificate = function (_PkiObject59) {
    function RevokedCertificate() {
      var _this118;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, RevokedCertificate);
      _this118 = _callSuper(this, RevokedCertificate);
      _this118.userCertificate = getParametersValue(parameters, USER_CERTIFICATE, RevokedCertificate.defaultValues(USER_CERTIFICATE));
      _this118.revocationDate = getParametersValue(parameters, REVOCATION_DATE, RevokedCertificate.defaultValues(REVOCATION_DATE));
      if (CRL_ENTRY_EXTENSIONS in parameters) {
        _this118.crlEntryExtensions = getParametersValue(parameters, CRL_ENTRY_EXTENSIONS, RevokedCertificate.defaultValues(CRL_ENTRY_EXTENSIONS));
      }
      if (parameters.schema) {
        _this118.fromSchema(parameters.schema);
      }
      return _this118;
    }
    _inherits(RevokedCertificate, _PkiObject59);
    return _createClass(RevokedCertificate, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$O);
        var asn1 = compareSchema(schema, schema, RevokedCertificate.schema());
        AsnError.assertSchema(asn1, this.className);
        this.userCertificate = asn1.result.userCertificate;
        this.revocationDate = new Time({
          schema: asn1.result.revocationDate
        });
        if (CRL_ENTRY_EXTENSIONS in asn1.result) {
          this.crlEntryExtensions = new Extensions({
            schema: asn1.result.crlEntryExtensions
          });
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [this.userCertificate, this.revocationDate.toSchema()];
        if (this.crlEntryExtensions) {
          outputArray.push(this.crlEntryExtensions.toSchema());
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          userCertificate: this.userCertificate.toJSON(),
          revocationDate: this.revocationDate.toJSON()
        };
        if (this.crlEntryExtensions) {
          res.crlEntryExtensions = this.crlEntryExtensions.toJSON();
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case USER_CERTIFICATE:
            return new Integer();
          case REVOCATION_DATE:
            return new Time();
          case CRL_ENTRY_EXTENSIONS:
            return new Extensions();
          default:
            return _superPropGet(RevokedCertificate, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Integer({
            name: names.userCertificate || USER_CERTIFICATE
          }), Time.schema({
            names: {
              utcTimeName: names.revocationDate || REVOCATION_DATE,
              generalTimeName: names.revocationDate || REVOCATION_DATE
            }
          }), Extensions.schema({
            names: {
              blockName: names.crlEntryExtensions || CRL_ENTRY_EXTENSIONS
            }
          }, true)]
        });
      }
    }]);
  }(PkiObject);
  RevokedCertificate.CLASS_NAME = "RevokedCertificate";
  var TBS$3 = "tbs";
  var VERSION$e = "version";
  var SIGNATURE$3 = "signature";
  var ISSUER$1 = "issuer";
  var THIS_UPDATE$1 = "thisUpdate";
  var NEXT_UPDATE$1 = "nextUpdate";
  var REVOKED_CERTIFICATES = "revokedCertificates";
  var CRL_EXTENSIONS = "crlExtensions";
  var SIGNATURE_ALGORITHM$4 = "signatureAlgorithm";
  var SIGNATURE_VALUE$1 = "signatureValue";
  var TBS_CERT_LIST = "tbsCertList";
  var TBS_CERT_LIST_VERSION = "".concat(TBS_CERT_LIST, ".version");
  var TBS_CERT_LIST_SIGNATURE = "".concat(TBS_CERT_LIST, ".signature");
  var TBS_CERT_LIST_ISSUER = "".concat(TBS_CERT_LIST, ".issuer");
  var TBS_CERT_LIST_THIS_UPDATE = "".concat(TBS_CERT_LIST, ".thisUpdate");
  var TBS_CERT_LIST_NEXT_UPDATE = "".concat(TBS_CERT_LIST, ".nextUpdate");
  var TBS_CERT_LIST_REVOKED_CERTIFICATES = "".concat(TBS_CERT_LIST, ".revokedCertificates");
  var TBS_CERT_LIST_EXTENSIONS = "".concat(TBS_CERT_LIST, ".extensions");
  var CLEAR_PROPS$N = [TBS_CERT_LIST, TBS_CERT_LIST_VERSION, TBS_CERT_LIST_SIGNATURE, TBS_CERT_LIST_ISSUER, TBS_CERT_LIST_THIS_UPDATE, TBS_CERT_LIST_NEXT_UPDATE, TBS_CERT_LIST_REVOKED_CERTIFICATES, TBS_CERT_LIST_EXTENSIONS, SIGNATURE_ALGORITHM$4, SIGNATURE_VALUE$1];
  function tbsCertList() {
    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var names = getParametersValue(parameters, "names", {});
    return new Sequence({
      name: names.blockName || TBS_CERT_LIST,
      value: [new Integer({
        optional: true,
        name: names.tbsCertListVersion || TBS_CERT_LIST_VERSION,
        value: 2
      }), AlgorithmIdentifier.schema(names.signature || {
        names: {
          blockName: TBS_CERT_LIST_SIGNATURE
        }
      }), RelativeDistinguishedNames.schema(names.issuer || {
        names: {
          blockName: TBS_CERT_LIST_ISSUER
        }
      }), Time.schema(names.tbsCertListThisUpdate || {
        names: {
          utcTimeName: TBS_CERT_LIST_THIS_UPDATE,
          generalTimeName: TBS_CERT_LIST_THIS_UPDATE
        }
      }), Time.schema(names.tbsCertListNextUpdate || {
        names: {
          utcTimeName: TBS_CERT_LIST_NEXT_UPDATE,
          generalTimeName: TBS_CERT_LIST_NEXT_UPDATE
        }
      }, true), new Sequence({
        optional: true,
        value: [new Repeated({
          name: names.tbsCertListRevokedCertificates || TBS_CERT_LIST_REVOKED_CERTIFICATES,
          value: new Sequence({
            value: [new Integer(), Time.schema(), Extensions.schema({}, true)]
          })
        })]
      }), new Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: [Extensions.schema(names.crlExtensions || {
          names: {
            blockName: TBS_CERT_LIST_EXTENSIONS
          }
        })]
      })]
    });
  }
  var WELL_KNOWN_EXTENSIONS = [id_AuthorityKeyIdentifier, id_IssuerAltName, id_CRLNumber, id_BaseCRLNumber, id_IssuingDistributionPoint, id_FreshestCRL, id_AuthorityInfoAccess, id_CRLReason, id_InvalidityDate, id_CertificateIssuer];
  var CertificateRevocationList = function (_PkiObject60) {
    function CertificateRevocationList() {
      var _this119;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, CertificateRevocationList);
      _this119 = _callSuper(this, CertificateRevocationList);
      _this119.tbsView = new Uint8Array(getParametersValue(parameters, TBS$3, CertificateRevocationList.defaultValues(TBS$3)));
      _this119.version = getParametersValue(parameters, VERSION$e, CertificateRevocationList.defaultValues(VERSION$e));
      _this119.signature = getParametersValue(parameters, SIGNATURE$3, CertificateRevocationList.defaultValues(SIGNATURE$3));
      _this119.issuer = getParametersValue(parameters, ISSUER$1, CertificateRevocationList.defaultValues(ISSUER$1));
      _this119.thisUpdate = getParametersValue(parameters, THIS_UPDATE$1, CertificateRevocationList.defaultValues(THIS_UPDATE$1));
      if (NEXT_UPDATE$1 in parameters) {
        _this119.nextUpdate = getParametersValue(parameters, NEXT_UPDATE$1, CertificateRevocationList.defaultValues(NEXT_UPDATE$1));
      }
      if (REVOKED_CERTIFICATES in parameters) {
        _this119.revokedCertificates = getParametersValue(parameters, REVOKED_CERTIFICATES, CertificateRevocationList.defaultValues(REVOKED_CERTIFICATES));
      }
      if (CRL_EXTENSIONS in parameters) {
        _this119.crlExtensions = getParametersValue(parameters, CRL_EXTENSIONS, CertificateRevocationList.defaultValues(CRL_EXTENSIONS));
      }
      _this119.signatureAlgorithm = getParametersValue(parameters, SIGNATURE_ALGORITHM$4, CertificateRevocationList.defaultValues(SIGNATURE_ALGORITHM$4));
      _this119.signatureValue = getParametersValue(parameters, SIGNATURE_VALUE$1, CertificateRevocationList.defaultValues(SIGNATURE_VALUE$1));
      if (parameters.schema) {
        _this119.fromSchema(parameters.schema);
      }
      return _this119;
    }
    _inherits(CertificateRevocationList, _PkiObject60);
    return _createClass(CertificateRevocationList, [{
      key: "tbs",
      get: function get() {
        return BufferSourceConverter.toArrayBuffer(this.tbsView);
      },
      set: function set(value) {
        this.tbsView = new Uint8Array(value);
      }
    }, {
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$N);
        var asn1 = compareSchema(schema, schema, CertificateRevocationList.schema());
        AsnError.assertSchema(asn1, this.className);
        this.tbsView = asn1.result.tbsCertList.valueBeforeDecodeView;
        if (TBS_CERT_LIST_VERSION in asn1.result) {
          this.version = asn1.result[TBS_CERT_LIST_VERSION].valueBlock.valueDec;
        }
        this.signature = new AlgorithmIdentifier({
          schema: asn1.result[TBS_CERT_LIST_SIGNATURE]
        });
        this.issuer = new RelativeDistinguishedNames({
          schema: asn1.result[TBS_CERT_LIST_ISSUER]
        });
        this.thisUpdate = new Time({
          schema: asn1.result[TBS_CERT_LIST_THIS_UPDATE]
        });
        if (TBS_CERT_LIST_NEXT_UPDATE in asn1.result) {
          this.nextUpdate = new Time({
            schema: asn1.result[TBS_CERT_LIST_NEXT_UPDATE]
          });
        }
        if (TBS_CERT_LIST_REVOKED_CERTIFICATES in asn1.result) {
          this.revokedCertificates = Array.from(asn1.result[TBS_CERT_LIST_REVOKED_CERTIFICATES], function (element) {
            return new RevokedCertificate({
              schema: element
            });
          });
        }
        if (TBS_CERT_LIST_EXTENSIONS in asn1.result) {
          this.crlExtensions = new Extensions({
            schema: asn1.result[TBS_CERT_LIST_EXTENSIONS]
          });
        }
        this.signatureAlgorithm = new AlgorithmIdentifier({
          schema: asn1.result.signatureAlgorithm
        });
        this.signatureValue = asn1.result.signatureValue;
      }
    }, {
      key: "encodeTBS",
      value: function encodeTBS() {
        var outputArray = [];
        if (this.version !== CertificateRevocationList.defaultValues(VERSION$e)) {
          outputArray.push(new Integer({
            value: this.version
          }));
        }
        outputArray.push(this.signature.toSchema());
        outputArray.push(this.issuer.toSchema());
        outputArray.push(this.thisUpdate.toSchema());
        if (this.nextUpdate) {
          outputArray.push(this.nextUpdate.toSchema());
        }
        if (this.revokedCertificates) {
          outputArray.push(new Sequence({
            value: Array.from(this.revokedCertificates, function (o) {
              return o.toSchema();
            })
          }));
        }
        if (this.crlExtensions) {
          outputArray.push(new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [this.crlExtensions.toSchema()]
          }));
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var encodeFlag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var tbsSchema;
        if (!encodeFlag) {
          if (!this.tbsView.byteLength) {
            return CertificateRevocationList.schema();
          }
          var asn1 = _fromBER(this.tbsView);
          AsnError.assert(asn1, "TBS Certificate Revocation List");
          tbsSchema = asn1.result;
        } else {
          tbsSchema = this.encodeTBS();
        }
        return new Sequence({
          value: [tbsSchema, this.signatureAlgorithm.toSchema(), this.signatureValue]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          tbs: Convert.ToHex(this.tbsView),
          version: this.version,
          signature: this.signature.toJSON(),
          issuer: this.issuer.toJSON(),
          thisUpdate: this.thisUpdate.toJSON(),
          signatureAlgorithm: this.signatureAlgorithm.toJSON(),
          signatureValue: this.signatureValue.toJSON()
        };
        if (this.version !== CertificateRevocationList.defaultValues(VERSION$e)) res.version = this.version;
        if (this.nextUpdate) {
          res.nextUpdate = this.nextUpdate.toJSON();
        }
        if (this.revokedCertificates) {
          res.revokedCertificates = Array.from(this.revokedCertificates, function (o) {
            return o.toJSON();
          });
        }
        if (this.crlExtensions) {
          res.crlExtensions = this.crlExtensions.toJSON();
        }
        return res;
      }
    }, {
      key: "isCertificateRevoked",
      value: function isCertificateRevoked(certificate) {
        if (!this.issuer.isEqual(certificate.issuer)) {
          return false;
        }
        if (!this.revokedCertificates) {
          return false;
        }
        var _iterator21 = _createForOfIteratorHelper(this.revokedCertificates),
          _step21;
        try {
          for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
            var revokedCertificate = _step21.value;
            if (revokedCertificate.userCertificate.isEqual(certificate.serialNumber)) {
              return true;
            }
          }
        } catch (err) {
          _iterator21.e(err);
        } finally {
          _iterator21.f();
        }
        return false;
      }
    }, {
      key: "sign",
      value: function () {
        var _sign2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee27(privateKey) {
          var hashAlgorithm,
            crypto,
            signatureParameters,
            parameters,
            signature,
            _args27 = arguments;
          return _regeneratorRuntime().wrap(function _callee27$(_context27) {
            while (1) switch (_context27.prev = _context27.next) {
              case 0:
                hashAlgorithm = _args27.length > 1 && _args27[1] !== undefined ? _args27[1] : "SHA-1";
                crypto = _args27.length > 2 && _args27[2] !== undefined ? _args27[2] : getCrypto(true);
                if (privateKey) {
                  _context27.next = 4;
                  break;
                }
                throw new Error("Need to provide a private key for signing");
              case 4:
                _context27.next = 6;
                return crypto.getSignatureParameters(privateKey, hashAlgorithm);
              case 6:
                signatureParameters = _context27.sent;
                parameters = signatureParameters.parameters;
                this.signature = signatureParameters.signatureAlgorithm;
                this.signatureAlgorithm = signatureParameters.signatureAlgorithm;
                this.tbsView = new Uint8Array(this.encodeTBS().toBER());
                _context27.next = 13;
                return crypto.signWithPrivateKey(this.tbsView, privateKey, parameters);
              case 13:
                signature = _context27.sent;
                this.signatureValue = new BitString({
                  valueHex: signature
                });
              case 15:
              case "end":
                return _context27.stop();
            }
          }, _callee27, this);
        }));
        function sign(_x50) {
          return _sign2.apply(this, arguments);
        }
        return sign;
      }()
    }, {
      key: "verify",
      value: function () {
        var _verify4 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee28() {
          var parameters,
            crypto,
            subjectPublicKeyInfo,
            _iterator22,
            _step22,
            extension,
            _args28 = arguments;
          return _regeneratorRuntime().wrap(function _callee28$(_context28) {
            while (1) switch (_context28.prev = _context28.next) {
              case 0:
                parameters = _args28.length > 0 && _args28[0] !== undefined ? _args28[0] : {};
                crypto = _args28.length > 1 && _args28[1] !== undefined ? _args28[1] : getCrypto(true);
                if (!parameters.issuerCertificate) {
                  _context28.next = 6;
                  break;
                }
                subjectPublicKeyInfo = parameters.issuerCertificate.subjectPublicKeyInfo;
                if (this.issuer.isEqual(parameters.issuerCertificate.subject)) {
                  _context28.next = 6;
                  break;
                }
                return _context28.abrupt("return", false);
              case 6:
                if (parameters.publicKeyInfo) {
                  subjectPublicKeyInfo = parameters.publicKeyInfo;
                }
                if (subjectPublicKeyInfo) {
                  _context28.next = 9;
                  break;
                }
                throw new Error("Issuer's certificate must be provided as an input parameter");
              case 9:
                if (!this.crlExtensions) {
                  _context28.next = 28;
                  break;
                }
                _iterator22 = _createForOfIteratorHelper(this.crlExtensions.extensions);
                _context28.prev = 11;
                _iterator22.s();
              case 13:
                if ((_step22 = _iterator22.n()).done) {
                  _context28.next = 20;
                  break;
                }
                extension = _step22.value;
                if (!extension.critical) {
                  _context28.next = 18;
                  break;
                }
                if (WELL_KNOWN_EXTENSIONS.includes(extension.extnID)) {
                  _context28.next = 18;
                  break;
                }
                return _context28.abrupt("return", false);
              case 18:
                _context28.next = 13;
                break;
              case 20:
                _context28.next = 25;
                break;
              case 22:
                _context28.prev = 22;
                _context28.t0 = _context28["catch"](11);
                _iterator22.e(_context28.t0);
              case 25:
                _context28.prev = 25;
                _iterator22.f();
                return _context28.finish(25);
              case 28:
                return _context28.abrupt("return", crypto.verifyWithPublicKey(this.tbsView, this.signatureValue, subjectPublicKeyInfo, this.signatureAlgorithm));
              case 29:
              case "end":
                return _context28.stop();
            }
          }, _callee28, this, [[11, 22, 25, 28]]);
        }));
        function verify() {
          return _verify4.apply(this, arguments);
        }
        return verify;
      }()
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case TBS$3:
            return EMPTY_BUFFER;
          case VERSION$e:
            return 0;
          case SIGNATURE$3:
            return new AlgorithmIdentifier();
          case ISSUER$1:
            return new RelativeDistinguishedNames();
          case THIS_UPDATE$1:
            return new Time();
          case NEXT_UPDATE$1:
            return new Time();
          case REVOKED_CERTIFICATES:
            return [];
          case CRL_EXTENSIONS:
            return new Extensions();
          case SIGNATURE_ALGORITHM$4:
            return new AlgorithmIdentifier();
          case SIGNATURE_VALUE$1:
            return new BitString();
          default:
            return _superPropGet(CertificateRevocationList, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || "CertificateList",
          value: [tbsCertList(parameters), AlgorithmIdentifier.schema(names.signatureAlgorithm || {
            names: {
              blockName: SIGNATURE_ALGORITHM$4
            }
          }), new BitString({
            name: names.signatureValue || SIGNATURE_VALUE$1
          })]
        });
      }
    }]);
  }(PkiObject);
  CertificateRevocationList.CLASS_NAME = "CertificateRevocationList";
  var CRL_ID = "crlId";
  var CRL_VALUE = "crlValue";
  var PARSED_VALUE$3 = "parsedValue";
  var CLEAR_PROPS$M = [CRL_ID, CRL_VALUE];
  var CRLBag = function (_PkiObject61) {
    function CRLBag() {
      var _this120;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, CRLBag);
      _this120 = _callSuper(this, CRLBag);
      _this120.crlId = getParametersValue(parameters, CRL_ID, CRLBag.defaultValues(CRL_ID));
      _this120.crlValue = getParametersValue(parameters, CRL_VALUE, CRLBag.defaultValues(CRL_VALUE));
      if (PARSED_VALUE$3 in parameters) {
        _this120.parsedValue = getParametersValue(parameters, PARSED_VALUE$3, CRLBag.defaultValues(PARSED_VALUE$3));
      }
      if (parameters.schema) {
        _this120.fromSchema(parameters.schema);
      }
      return _this120;
    }
    _inherits(CRLBag, _PkiObject61);
    return _createClass(CRLBag, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$M);
        var asn1 = compareSchema(schema, schema, CRLBag.schema({
          names: {
            id: CRL_ID,
            value: CRL_VALUE
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.crlId = asn1.result.crlId.valueBlock.toString();
        this.crlValue = asn1.result.crlValue;
        switch (this.crlId) {
          case id_CRLBag_X509CRL:
            {
              this.parsedValue = CertificateRevocationList.fromBER(this.certValue.valueBlock.valueHex);
            }
            break;
          default:
            throw new Error("Incorrect CRL_ID value in CRLBag: ".concat(this.crlId));
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        if (this.parsedValue) {
          this.crlId = id_CRLBag_X509CRL;
          this.crlValue = new OctetString({
            valueHex: this.parsedValue.toSchema().toBER(false)
          });
        }
        return new Sequence({
          value: [new ObjectIdentifier({
            value: this.crlId
          }), new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [this.crlValue.toSchema()]
          })]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          crlId: this.crlId,
          crlValue: this.crlValue.toJSON()
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case CRL_ID:
            return EMPTY_STRING;
          case CRL_VALUE:
            return new Any();
          case PARSED_VALUE$3:
            return {};
          default:
            return _superPropGet(CRLBag, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case CRL_ID:
            return memberValue === EMPTY_STRING;
          case CRL_VALUE:
            return memberValue instanceof Any;
          case PARSED_VALUE$3:
            return memberValue instanceof Object && Object.keys(memberValue).length === 0;
          default:
            return _superPropGet(CRLBag, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new ObjectIdentifier({
            name: names.id || "id"
          }), new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [new Any({
              name: names.value || "value"
            })]
          })]
        });
      }
    }]);
  }(PkiObject);
  CRLBag.CLASS_NAME = "CRLBag";
  var VERSION$d = "version";
  var ENCRYPTED_CONTENT_INFO$1 = "encryptedContentInfo";
  var UNPROTECTED_ATTRS$1 = "unprotectedAttrs";
  var CLEAR_PROPS$L = [VERSION$d, ENCRYPTED_CONTENT_INFO$1, UNPROTECTED_ATTRS$1];
  var EncryptedData = function (_PkiObject62) {
    function EncryptedData() {
      var _this121;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, EncryptedData);
      _this121 = _callSuper(this, EncryptedData);
      _this121.version = getParametersValue(parameters, VERSION$d, EncryptedData.defaultValues(VERSION$d));
      _this121.encryptedContentInfo = getParametersValue(parameters, ENCRYPTED_CONTENT_INFO$1, EncryptedData.defaultValues(ENCRYPTED_CONTENT_INFO$1));
      if (UNPROTECTED_ATTRS$1 in parameters) {
        _this121.unprotectedAttrs = getParametersValue(parameters, UNPROTECTED_ATTRS$1, EncryptedData.defaultValues(UNPROTECTED_ATTRS$1));
      }
      if (parameters.schema) {
        _this121.fromSchema(parameters.schema);
      }
      return _this121;
    }
    _inherits(EncryptedData, _PkiObject62);
    return _createClass(EncryptedData, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$L);
        var asn1 = compareSchema(schema, schema, EncryptedData.schema({
          names: {
            version: VERSION$d,
            encryptedContentInfo: {
              names: {
                blockName: ENCRYPTED_CONTENT_INFO$1
              }
            },
            unprotectedAttrs: UNPROTECTED_ATTRS$1
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result.version.valueBlock.valueDec;
        this.encryptedContentInfo = new EncryptedContentInfo({
          schema: asn1.result.encryptedContentInfo
        });
        if (UNPROTECTED_ATTRS$1 in asn1.result) this.unprotectedAttrs = Array.from(asn1.result.unprotectedAttrs, function (element) {
          return new Attribute({
            schema: element
          });
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        outputArray.push(new Integer({
          value: this.version
        }));
        outputArray.push(this.encryptedContentInfo.toSchema());
        if (this.unprotectedAttrs) {
          outputArray.push(new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: Array.from(this.unprotectedAttrs, function (o) {
              return o.toSchema();
            })
          }));
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          version: this.version,
          encryptedContentInfo: this.encryptedContentInfo.toJSON()
        };
        if (this.unprotectedAttrs) res.unprotectedAttrs = Array.from(this.unprotectedAttrs, function (o) {
          return o.toJSON();
        });
        return res;
      }
    }, {
      key: "encrypt",
      value: function () {
        var _encrypt2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee29(parameters) {
          var crypto,
            encryptParams,
            _args29 = arguments;
          return _regeneratorRuntime().wrap(function _callee29$(_context29) {
            while (1) switch (_context29.prev = _context29.next) {
              case 0:
                crypto = _args29.length > 1 && _args29[1] !== undefined ? _args29[1] : getCrypto(true);
                ArgumentError.assert(parameters, "parameters", "object");
                encryptParams = _objectSpread2(_objectSpread2({}, parameters), {}, {
                  contentType: "1.2.840.113549.1.7.1"
                });
                _context29.next = 5;
                return crypto.encryptEncryptedContentInfo(encryptParams);
              case 5:
                this.encryptedContentInfo = _context29.sent;
              case 6:
              case "end":
                return _context29.stop();
            }
          }, _callee29, this);
        }));
        function encrypt(_x51) {
          return _encrypt2.apply(this, arguments);
        }
        return encrypt;
      }()
    }, {
      key: "decrypt",
      value: function () {
        var _decrypt2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee30(parameters) {
          var crypto,
            decryptParams,
            _args30 = arguments;
          return _regeneratorRuntime().wrap(function _callee30$(_context30) {
            while (1) switch (_context30.prev = _context30.next) {
              case 0:
                crypto = _args30.length > 1 && _args30[1] !== undefined ? _args30[1] : getCrypto(true);
                ArgumentError.assert(parameters, "parameters", "object");
                decryptParams = _objectSpread2(_objectSpread2({}, parameters), {}, {
                  encryptedContentInfo: this.encryptedContentInfo
                });
                return _context30.abrupt("return", crypto.decryptEncryptedContentInfo(decryptParams));
              case 4:
              case "end":
                return _context30.stop();
            }
          }, _callee30, this);
        }));
        function decrypt(_x52) {
          return _decrypt2.apply(this, arguments);
        }
        return decrypt;
      }()
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case VERSION$d:
            return 0;
          case ENCRYPTED_CONTENT_INFO$1:
            return new EncryptedContentInfo();
          case UNPROTECTED_ATTRS$1:
            return [];
          default:
            return _superPropGet(EncryptedData, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VERSION$d:
            return memberValue === 0;
          case ENCRYPTED_CONTENT_INFO$1:
            return EncryptedContentInfo.compareWithDefault("contentType", memberValue.contentType) && EncryptedContentInfo.compareWithDefault("contentEncryptionAlgorithm", memberValue.contentEncryptionAlgorithm) && EncryptedContentInfo.compareWithDefault("encryptedContent", memberValue.encryptedContent);
          case UNPROTECTED_ATTRS$1:
            return memberValue.length === 0;
          default:
            return _superPropGet(EncryptedData, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Integer({
            name: names.version || EMPTY_STRING
          }), EncryptedContentInfo.schema(names.encryptedContentInfo || {}), new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: [new Repeated({
              name: names.unprotectedAttrs || EMPTY_STRING,
              value: Attribute.schema()
            })]
          })]
        });
      }
    }]);
  }(PkiObject);
  EncryptedData.CLASS_NAME = "EncryptedData";
  var ENCRYPTION_ALGORITHM = "encryptionAlgorithm";
  var ENCRYPTED_DATA = "encryptedData";
  var PARSED_VALUE$2 = "parsedValue";
  var CLEAR_PROPS$K = [ENCRYPTION_ALGORITHM, ENCRYPTED_DATA];
  var PKCS8ShroudedKeyBag = function (_PkiObject63) {
    function PKCS8ShroudedKeyBag() {
      var _this122;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, PKCS8ShroudedKeyBag);
      _this122 = _callSuper(this, PKCS8ShroudedKeyBag);
      _this122.encryptionAlgorithm = getParametersValue(parameters, ENCRYPTION_ALGORITHM, PKCS8ShroudedKeyBag.defaultValues(ENCRYPTION_ALGORITHM));
      _this122.encryptedData = getParametersValue(parameters, ENCRYPTED_DATA, PKCS8ShroudedKeyBag.defaultValues(ENCRYPTED_DATA));
      if (PARSED_VALUE$2 in parameters) {
        _this122.parsedValue = getParametersValue(parameters, PARSED_VALUE$2, PKCS8ShroudedKeyBag.defaultValues(PARSED_VALUE$2));
      }
      if (parameters.schema) {
        _this122.fromSchema(parameters.schema);
      }
      return _this122;
    }
    _inherits(PKCS8ShroudedKeyBag, _PkiObject63);
    return _createClass(PKCS8ShroudedKeyBag, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$K);
        var asn1 = compareSchema(schema, schema, PKCS8ShroudedKeyBag.schema({
          names: {
            encryptionAlgorithm: {
              names: {
                blockName: ENCRYPTION_ALGORITHM
              }
            },
            encryptedData: ENCRYPTED_DATA
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.encryptionAlgorithm = new AlgorithmIdentifier({
          schema: asn1.result.encryptionAlgorithm
        });
        this.encryptedData = asn1.result.encryptedData;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: [this.encryptionAlgorithm.toSchema(), this.encryptedData]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          encryptionAlgorithm: this.encryptionAlgorithm.toJSON(),
          encryptedData: this.encryptedData.toJSON()
        };
      }
    }, {
      key: "parseInternalValues",
      value: function () {
        var _parseInternalValues = _asyncToGenerator(_regeneratorRuntime().mark(function _callee31(parameters) {
          var crypto,
            cmsEncrypted,
            decryptedData,
            _args31 = arguments;
          return _regeneratorRuntime().wrap(function _callee31$(_context31) {
            while (1) switch (_context31.prev = _context31.next) {
              case 0:
                crypto = _args31.length > 1 && _args31[1] !== undefined ? _args31[1] : getCrypto(true);
                cmsEncrypted = new EncryptedData({
                  encryptedContentInfo: new EncryptedContentInfo({
                    contentEncryptionAlgorithm: this.encryptionAlgorithm,
                    encryptedContent: this.encryptedData
                  })
                });
                _context31.next = 4;
                return cmsEncrypted.decrypt(parameters, crypto);
              case 4:
                decryptedData = _context31.sent;
                this.parsedValue = PrivateKeyInfo.fromBER(decryptedData);
              case 6:
              case "end":
                return _context31.stop();
            }
          }, _callee31, this);
        }));
        function parseInternalValues(_x53) {
          return _parseInternalValues.apply(this, arguments);
        }
        return parseInternalValues;
      }()
    }, {
      key: "makeInternalValues",
      value: function () {
        var _makeInternalValues = _asyncToGenerator(_regeneratorRuntime().mark(function _callee32(parameters) {
          var crypto,
            cmsEncrypted,
            encryptParams,
            _args32 = arguments;
          return _regeneratorRuntime().wrap(function _callee32$(_context32) {
            while (1) switch (_context32.prev = _context32.next) {
              case 0:
                crypto = _args32.length > 1 && _args32[1] !== undefined ? _args32[1] : getCrypto(true);
                if (this.parsedValue) {
                  _context32.next = 3;
                  break;
                }
                throw new Error("Please initialize \"parsedValue\" first");
              case 3:
                cmsEncrypted = new EncryptedData();
                encryptParams = _objectSpread2(_objectSpread2({}, parameters), {}, {
                  contentToEncrypt: this.parsedValue.toSchema().toBER(false)
                });
                _context32.next = 7;
                return cmsEncrypted.encrypt(encryptParams, crypto);
              case 7:
                if (cmsEncrypted.encryptedContentInfo.encryptedContent) {
                  _context32.next = 9;
                  break;
                }
                throw new Error("The filed `encryptedContent` in EncryptedContentInfo is empty");
              case 9:
                this.encryptionAlgorithm = cmsEncrypted.encryptedContentInfo.contentEncryptionAlgorithm;
                this.encryptedData = cmsEncrypted.encryptedContentInfo.encryptedContent;
              case 11:
              case "end":
                return _context32.stop();
            }
          }, _callee32, this);
        }));
        function makeInternalValues(_x54) {
          return _makeInternalValues.apply(this, arguments);
        }
        return makeInternalValues;
      }()
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case ENCRYPTION_ALGORITHM:
            return new AlgorithmIdentifier();
          case ENCRYPTED_DATA:
            return new OctetString();
          case PARSED_VALUE$2:
            return {};
          default:
            return _superPropGet(PKCS8ShroudedKeyBag, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case ENCRYPTION_ALGORITHM:
            return AlgorithmIdentifier.compareWithDefault("algorithmId", memberValue.algorithmId) && "algorithmParams" in memberValue === false;
          case ENCRYPTED_DATA:
            return memberValue.isEqual(PKCS8ShroudedKeyBag.defaultValues(memberName));
          case PARSED_VALUE$2:
            return memberValue instanceof Object && Object.keys(memberValue).length === 0;
          default:
            return _superPropGet(PKCS8ShroudedKeyBag, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [AlgorithmIdentifier.schema(names.encryptionAlgorithm || {
            names: {
              blockName: ENCRYPTION_ALGORITHM
            }
          }), new Choice({
            value: [new OctetString({
              name: names.encryptedData || ENCRYPTED_DATA
            }), new OctetString({
              idBlock: {
                isConstructed: true
              },
              name: names.encryptedData || ENCRYPTED_DATA
            })]
          })]
        });
      }
    }]);
  }(PkiObject);
  PKCS8ShroudedKeyBag.CLASS_NAME = "PKCS8ShroudedKeyBag";
  var SECRET_TYPE_ID = "secretTypeId";
  var SECRET_VALUE = "secretValue";
  var CLEAR_PROPS$J = [SECRET_TYPE_ID, SECRET_VALUE];
  var SecretBag = function (_PkiObject64) {
    function SecretBag() {
      var _this123;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, SecretBag);
      _this123 = _callSuper(this, SecretBag);
      _this123.secretTypeId = getParametersValue(parameters, SECRET_TYPE_ID, SecretBag.defaultValues(SECRET_TYPE_ID));
      _this123.secretValue = getParametersValue(parameters, SECRET_VALUE, SecretBag.defaultValues(SECRET_VALUE));
      if (parameters.schema) {
        _this123.fromSchema(parameters.schema);
      }
      return _this123;
    }
    _inherits(SecretBag, _PkiObject64);
    return _createClass(SecretBag, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$J);
        var asn1 = compareSchema(schema, schema, SecretBag.schema({
          names: {
            id: SECRET_TYPE_ID,
            value: SECRET_VALUE
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.secretTypeId = asn1.result.secretTypeId.valueBlock.toString();
        this.secretValue = asn1.result.secretValue;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: [new ObjectIdentifier({
            value: this.secretTypeId
          }), new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [this.secretValue.toSchema()]
          })]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          secretTypeId: this.secretTypeId,
          secretValue: this.secretValue.toJSON()
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case SECRET_TYPE_ID:
            return EMPTY_STRING;
          case SECRET_VALUE:
            return new Any();
          default:
            return _superPropGet(SecretBag, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case SECRET_TYPE_ID:
            return memberValue === EMPTY_STRING;
          case SECRET_VALUE:
            return memberValue instanceof Any;
          default:
            return _superPropGet(SecretBag, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new ObjectIdentifier({
            name: names.id || "id"
          }), new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [new Any({
              name: names.value || "value"
            })]
          })]
        });
      }
    }]);
  }(PkiObject);
  SecretBag.CLASS_NAME = "SecretBag";
  var SafeBagValueFactory = function () {
    function SafeBagValueFactory() {
      _classCallCheck(this, SafeBagValueFactory);
    }
    return _createClass(SafeBagValueFactory, null, [{
      key: "getItems",
      value: function getItems() {
        if (!this.items) {
          this.items = {};
          SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.1", PrivateKeyInfo);
          SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.2", PKCS8ShroudedKeyBag);
          SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.3", CertBag);
          SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.4", CRLBag);
          SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.5", SecretBag);
          SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.6", SafeContents);
        }
        return this.items;
      }
    }, {
      key: "register",
      value: function register(id, type) {
        this.getItems()[id] = type;
      }
    }, {
      key: "find",
      value: function find(id) {
        return this.getItems()[id] || null;
      }
    }]);
  }();
  var BAG_ID = "bagId";
  var BAG_VALUE = "bagValue";
  var BAG_ATTRIBUTES = "bagAttributes";
  var CLEAR_PROPS$I = [BAG_ID, BAG_VALUE, BAG_ATTRIBUTES];
  var SafeBag = function (_PkiObject65) {
    function SafeBag() {
      var _this124;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, SafeBag);
      _this124 = _callSuper(this, SafeBag);
      _this124.bagId = getParametersValue(parameters, BAG_ID, SafeBag.defaultValues(BAG_ID));
      _this124.bagValue = getParametersValue(parameters, BAG_VALUE, SafeBag.defaultValues(BAG_VALUE));
      if (BAG_ATTRIBUTES in parameters) {
        _this124.bagAttributes = getParametersValue(parameters, BAG_ATTRIBUTES, SafeBag.defaultValues(BAG_ATTRIBUTES));
      }
      if (parameters.schema) {
        _this124.fromSchema(parameters.schema);
      }
      return _this124;
    }
    _inherits(SafeBag, _PkiObject65);
    return _createClass(SafeBag, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$I);
        var asn1 = compareSchema(schema, schema, SafeBag.schema({
          names: {
            bagId: BAG_ID,
            bagValue: BAG_VALUE,
            bagAttributes: BAG_ATTRIBUTES
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.bagId = asn1.result.bagId.valueBlock.toString();
        var bagType = SafeBagValueFactory.find(this.bagId);
        if (!bagType) {
          throw new Error("Invalid BAG_ID for SafeBag: ".concat(this.bagId));
        }
        this.bagValue = new bagType({
          schema: asn1.result.bagValue
        });
        if (BAG_ATTRIBUTES in asn1.result) {
          this.bagAttributes = Array.from(asn1.result.bagAttributes, function (element) {
            return new Attribute({
              schema: element
            });
          });
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [new ObjectIdentifier({
          value: this.bagId
        }), new Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [this.bagValue.toSchema()]
        })];
        if (this.bagAttributes) {
          outputArray.push(new Set({
            value: Array.from(this.bagAttributes, function (o) {
              return o.toSchema();
            })
          }));
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var output = {
          bagId: this.bagId,
          bagValue: this.bagValue.toJSON()
        };
        if (this.bagAttributes) {
          output.bagAttributes = Array.from(this.bagAttributes, function (o) {
            return o.toJSON();
          });
        }
        return output;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case BAG_ID:
            return EMPTY_STRING;
          case BAG_VALUE:
            return new Any();
          case BAG_ATTRIBUTES:
            return [];
          default:
            return _superPropGet(SafeBag, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case BAG_ID:
            return memberValue === EMPTY_STRING;
          case BAG_VALUE:
            return memberValue instanceof Any;
          case BAG_ATTRIBUTES:
            return memberValue.length === 0;
          default:
            return _superPropGet(SafeBag, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new ObjectIdentifier({
            name: names.bagId || BAG_ID
          }), new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [new Any({
              name: names.bagValue || BAG_VALUE
            })]
          }), new Set({
            optional: true,
            value: [new Repeated({
              name: names.bagAttributes || BAG_ATTRIBUTES,
              value: Attribute.schema()
            })]
          })]
        });
      }
    }]);
  }(PkiObject);
  SafeBag.CLASS_NAME = "SafeBag";
  var SAFE_BUGS = "safeBags";
  var SafeContents = function (_PkiObject66) {
    function SafeContents() {
      var _this125;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, SafeContents);
      _this125 = _callSuper(this, SafeContents);
      _this125.safeBags = getParametersValue(parameters, SAFE_BUGS, SafeContents.defaultValues(SAFE_BUGS));
      if (parameters.schema) {
        _this125.fromSchema(parameters.schema);
      }
      return _this125;
    }
    _inherits(SafeContents, _PkiObject66);
    return _createClass(SafeContents, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, [SAFE_BUGS]);
        var asn1 = compareSchema(schema, schema, SafeContents.schema({
          names: {
            safeBags: SAFE_BUGS
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.safeBags = Array.from(asn1.result.safeBags, function (element) {
          return new SafeBag({
            schema: element
          });
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: Array.from(this.safeBags, function (o) {
            return o.toSchema();
          })
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          safeBags: Array.from(this.safeBags, function (o) {
            return o.toJSON();
          })
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case SAFE_BUGS:
            return [];
          default:
            return _superPropGet(SafeContents, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case SAFE_BUGS:
            return memberValue.length === 0;
          default:
            return _superPropGet(SafeContents, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Repeated({
            name: names.safeBags || EMPTY_STRING,
            value: SafeBag.schema()
          })]
        });
      }
    }]);
  }(PkiObject);
  SafeContents.CLASS_NAME = "SafeContents";
  var OTHER_CERT_FORMAT = "otherCertFormat";
  var OTHER_CERT = "otherCert";
  var CLEAR_PROPS$H = [OTHER_CERT_FORMAT, OTHER_CERT];
  var OtherCertificateFormat = function (_PkiObject67) {
    function OtherCertificateFormat() {
      var _this126;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, OtherCertificateFormat);
      _this126 = _callSuper(this, OtherCertificateFormat);
      _this126.otherCertFormat = getParametersValue(parameters, OTHER_CERT_FORMAT, OtherCertificateFormat.defaultValues(OTHER_CERT_FORMAT));
      _this126.otherCert = getParametersValue(parameters, OTHER_CERT, OtherCertificateFormat.defaultValues(OTHER_CERT));
      if (parameters.schema) {
        _this126.fromSchema(parameters.schema);
      }
      return _this126;
    }
    _inherits(OtherCertificateFormat, _PkiObject67);
    return _createClass(OtherCertificateFormat, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$H);
        var asn1 = compareSchema(schema, schema, OtherCertificateFormat.schema());
        AsnError.assertSchema(asn1, this.className);
        this.otherCertFormat = asn1.result.otherCertFormat.valueBlock.toString();
        this.otherCert = asn1.result.otherCert;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: [new ObjectIdentifier({
            value: this.otherCertFormat
          }), this.otherCert]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          otherCertFormat: this.otherCertFormat
        };
        if (!(this.otherCert instanceof Any)) {
          res.otherCert = this.otherCert.toJSON();
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case OTHER_CERT_FORMAT:
            return EMPTY_STRING;
          case OTHER_CERT:
            return new Any();
          default:
            return _superPropGet(OtherCertificateFormat, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new ObjectIdentifier({
            name: names.otherCertFormat || OTHER_CERT_FORMAT
          }), new Any({
            name: names.otherCert || OTHER_CERT
          })]
        });
      }
    }]);
  }(PkiObject);
  var CERTIFICATES$1 = "certificates";
  var CLEAR_PROPS$G = [CERTIFICATES$1];
  var CertificateSet = function (_PkiObject68) {
    function CertificateSet() {
      var _this127;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, CertificateSet);
      _this127 = _callSuper(this, CertificateSet);
      _this127.certificates = getParametersValue(parameters, CERTIFICATES$1, CertificateSet.defaultValues(CERTIFICATES$1));
      if (parameters.schema) {
        _this127.fromSchema(parameters.schema);
      }
      return _this127;
    }
    _inherits(CertificateSet, _PkiObject68);
    return _createClass(CertificateSet, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$G);
        var asn1 = compareSchema(schema, schema, CertificateSet.schema());
        AsnError.assertSchema(asn1, this.className);
        this.certificates = Array.from(asn1.result.certificates || [], function (element) {
          var initialTagNumber = element.idBlock.tagNumber;
          if (element.idBlock.tagClass === 1) return new Certificate({
            schema: element
          });
          var elementSequence = new Sequence({
            value: element.valueBlock.value
          });
          switch (initialTagNumber) {
            case 1:
              if (elementSequence.valueBlock.value[0].valueBlock.value[0].valueBlock.valueDec === 1) {
                return new AttributeCertificateV2({
                  schema: elementSequence
                });
              } else {
                return new AttributeCertificateV1({
                  schema: elementSequence
                });
              }
            case 2:
              return new AttributeCertificateV2({
                schema: elementSequence
              });
            case 3:
              return new OtherCertificateFormat({
                schema: elementSequence
              });
          }
          return element;
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Set({
          value: Array.from(this.certificates, function (element) {
            switch (true) {
              case element instanceof Certificate:
                return element.toSchema();
              case element instanceof AttributeCertificateV1:
                return new Constructed({
                  idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                  },
                  value: element.toSchema().valueBlock.value
                });
              case element instanceof AttributeCertificateV2:
                return new Constructed({
                  idBlock: {
                    tagClass: 3,
                    tagNumber: 2
                  },
                  value: element.toSchema().valueBlock.value
                });
              case element instanceof OtherCertificateFormat:
                return new Constructed({
                  idBlock: {
                    tagClass: 3,
                    tagNumber: 3
                  },
                  value: element.toSchema().valueBlock.value
                });
            }
            return element.toSchema();
          })
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          certificates: Array.from(this.certificates, function (o) {
            return o.toJSON();
          })
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case CERTIFICATES$1:
            return [];
          default:
            return _superPropGet(CertificateSet, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Set({
          name: names.blockName || EMPTY_STRING,
          value: [new Repeated({
            name: names.certificates || CERTIFICATES$1,
            value: new Choice({
              value: [Certificate.schema(), new Constructed({
                idBlock: {
                  tagClass: 3,
                  tagNumber: 0
                },
                value: [new Any()]
              }), new Constructed({
                idBlock: {
                  tagClass: 3,
                  tagNumber: 1
                },
                value: [new Sequence()]
              }), new Constructed({
                idBlock: {
                  tagClass: 3,
                  tagNumber: 2
                },
                value: AttributeCertificateV2.schema().valueBlock.value
              }), new Constructed({
                idBlock: {
                  tagClass: 3,
                  tagNumber: 3
                },
                value: OtherCertificateFormat.schema().valueBlock.value
              })]
            })
          })]
        });
      }
    }]);
  }(PkiObject);
  CertificateSet.CLASS_NAME = "CertificateSet";
  var OTHER_REV_INFO_FORMAT = "otherRevInfoFormat";
  var OTHER_REV_INFO = "otherRevInfo";
  var CLEAR_PROPS$F = [OTHER_REV_INFO_FORMAT, OTHER_REV_INFO];
  var OtherRevocationInfoFormat = function (_PkiObject69) {
    function OtherRevocationInfoFormat() {
      var _this128;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, OtherRevocationInfoFormat);
      _this128 = _callSuper(this, OtherRevocationInfoFormat);
      _this128.otherRevInfoFormat = getParametersValue(parameters, OTHER_REV_INFO_FORMAT, OtherRevocationInfoFormat.defaultValues(OTHER_REV_INFO_FORMAT));
      _this128.otherRevInfo = getParametersValue(parameters, OTHER_REV_INFO, OtherRevocationInfoFormat.defaultValues(OTHER_REV_INFO));
      if (parameters.schema) {
        _this128.fromSchema(parameters.schema);
      }
      return _this128;
    }
    _inherits(OtherRevocationInfoFormat, _PkiObject69);
    return _createClass(OtherRevocationInfoFormat, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$F);
        var asn1 = compareSchema(schema, schema, OtherRevocationInfoFormat.schema());
        AsnError.assertSchema(asn1, this.className);
        this.otherRevInfoFormat = asn1.result.otherRevInfoFormat.valueBlock.toString();
        this.otherRevInfo = asn1.result.otherRevInfo;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: [new ObjectIdentifier({
            value: this.otherRevInfoFormat
          }), this.otherRevInfo]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          otherRevInfoFormat: this.otherRevInfoFormat
        };
        if (!(this.otherRevInfo instanceof Any)) {
          res.otherRevInfo = this.otherRevInfo.toJSON();
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case OTHER_REV_INFO_FORMAT:
            return EMPTY_STRING;
          case OTHER_REV_INFO:
            return new Any();
          default:
            return _superPropGet(OtherRevocationInfoFormat, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new ObjectIdentifier({
            name: names.otherRevInfoFormat || OTHER_REV_INFO_FORMAT
          }), new Any({
            name: names.otherRevInfo || OTHER_REV_INFO
          })]
        });
      }
    }]);
  }(PkiObject);
  OtherRevocationInfoFormat.CLASS_NAME = "OtherRevocationInfoFormat";
  var CRLS$3 = "crls";
  var OTHER_REVOCATION_INFOS = "otherRevocationInfos";
  var CLEAR_PROPS$E = [CRLS$3];
  var RevocationInfoChoices = function (_PkiObject70) {
    function RevocationInfoChoices() {
      var _this129;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, RevocationInfoChoices);
      _this129 = _callSuper(this, RevocationInfoChoices);
      _this129.crls = getParametersValue(parameters, CRLS$3, RevocationInfoChoices.defaultValues(CRLS$3));
      _this129.otherRevocationInfos = getParametersValue(parameters, OTHER_REVOCATION_INFOS, RevocationInfoChoices.defaultValues(OTHER_REVOCATION_INFOS));
      if (parameters.schema) {
        _this129.fromSchema(parameters.schema);
      }
      return _this129;
    }
    _inherits(RevocationInfoChoices, _PkiObject70);
    return _createClass(RevocationInfoChoices, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$E);
        var asn1 = compareSchema(schema, schema, RevocationInfoChoices.schema({
          names: {
            crls: CRLS$3
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (asn1.result.crls) {
          var _iterator23 = _createForOfIteratorHelper(asn1.result.crls),
            _step23;
          try {
            for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
              var element = _step23.value;
              if (element.idBlock.tagClass === 1) this.crls.push(new CertificateRevocationList({
                schema: element
              }));else this.otherRevocationInfos.push(new OtherRevocationInfoFormat({
                schema: element
              }));
            }
          } catch (err) {
            _iterator23.e(err);
          } finally {
            _iterator23.f();
          }
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        outputArray.push.apply(outputArray, _toConsumableArray(Array.from(this.crls, function (o) {
          return o.toSchema();
        })));
        outputArray.push.apply(outputArray, _toConsumableArray(Array.from(this.otherRevocationInfos, function (element) {
          var schema = element.toSchema();
          schema.idBlock.tagClass = 3;
          schema.idBlock.tagNumber = 1;
          return schema;
        })));
        return new Set({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          crls: Array.from(this.crls, function (o) {
            return o.toJSON();
          }),
          otherRevocationInfos: Array.from(this.otherRevocationInfos, function (o) {
            return o.toJSON();
          })
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case CRLS$3:
            return [];
          case OTHER_REVOCATION_INFOS:
            return [];
          default:
            return _superPropGet(RevocationInfoChoices, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Set({
          name: names.blockName || EMPTY_STRING,
          value: [new Repeated({
            name: names.crls || EMPTY_STRING,
            value: new Choice({
              value: [CertificateRevocationList.schema(), new Constructed({
                idBlock: {
                  tagClass: 3,
                  tagNumber: 1
                },
                value: [new ObjectIdentifier(), new Any()]
              })]
            })
          })]
        });
      }
    }]);
  }(PkiObject);
  RevocationInfoChoices.CLASS_NAME = "RevocationInfoChoices";
  var CERTS$3 = "certs";
  var CRLS$2 = "crls";
  var CLEAR_PROPS$D = [CERTS$3, CRLS$2];
  var OriginatorInfo = function (_PkiObject71) {
    function OriginatorInfo() {
      var _this130;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, OriginatorInfo);
      _this130 = _callSuper(this, OriginatorInfo);
      _this130.crls = getParametersValue(parameters, CRLS$2, OriginatorInfo.defaultValues(CRLS$2));
      if (parameters.schema) {
        _this130.fromSchema(parameters.schema);
      }
      return _this130;
    }
    _inherits(OriginatorInfo, _PkiObject71);
    return _createClass(OriginatorInfo, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$D);
        var asn1 = compareSchema(schema, schema, OriginatorInfo.schema({
          names: {
            certs: CERTS$3,
            crls: CRLS$2
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (CERTS$3 in asn1.result) {
          this.certs = new CertificateSet({
            schema: new Set({
              value: asn1.result.certs.valueBlock.value
            })
          });
        }
        if (CRLS$2 in asn1.result) {
          this.crls = new RevocationInfoChoices({
            schema: new Set({
              value: asn1.result.crls.valueBlock.value
            })
          });
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var sequenceValue = [];
        if (this.certs) {
          sequenceValue.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: this.certs.toSchema().valueBlock.value
          }));
        }
        if (this.crls) {
          sequenceValue.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: this.crls.toSchema().valueBlock.value
          }));
        }
        return new Sequence({
          value: sequenceValue
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {};
        if (this.certs) {
          res.certs = this.certs.toJSON();
        }
        if (this.crls) {
          res.crls = this.crls.toJSON();
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case CERTS$3:
            return new CertificateSet();
          case CRLS$2:
            return new RevocationInfoChoices();
          default:
            return _superPropGet(OriginatorInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case CERTS$3:
            return memberValue.certificates.length === 0;
          case CRLS$2:
            return memberValue.crls.length === 0 && memberValue.otherRevocationInfos.length === 0;
          default:
            return _superPropGet(OriginatorInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Constructed({
            name: names.certs || EMPTY_STRING,
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: CertificateSet.schema().valueBlock.value
          }), new Constructed({
            name: names.crls || EMPTY_STRING,
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: RevocationInfoChoices.schema().valueBlock.value
          })]
        });
      }
    }]);
  }(PkiObject);
  OriginatorInfo.CLASS_NAME = "OriginatorInfo";
  var ISSUER = "issuer";
  var SERIAL_NUMBER$2 = "serialNumber";
  var CLEAR_PROPS$C = [ISSUER, SERIAL_NUMBER$2];
  var IssuerAndSerialNumber = function (_PkiObject72) {
    function IssuerAndSerialNumber() {
      var _this131;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, IssuerAndSerialNumber);
      _this131 = _callSuper(this, IssuerAndSerialNumber);
      _this131.issuer = getParametersValue(parameters, ISSUER, IssuerAndSerialNumber.defaultValues(ISSUER));
      _this131.serialNumber = getParametersValue(parameters, SERIAL_NUMBER$2, IssuerAndSerialNumber.defaultValues(SERIAL_NUMBER$2));
      if (parameters.schema) {
        _this131.fromSchema(parameters.schema);
      }
      return _this131;
    }
    _inherits(IssuerAndSerialNumber, _PkiObject72);
    return _createClass(IssuerAndSerialNumber, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$C);
        var asn1 = compareSchema(schema, schema, IssuerAndSerialNumber.schema({
          names: {
            issuer: {
              names: {
                blockName: ISSUER
              }
            },
            serialNumber: SERIAL_NUMBER$2
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.issuer = new RelativeDistinguishedNames({
          schema: asn1.result.issuer
        });
        this.serialNumber = asn1.result.serialNumber;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: [this.issuer.toSchema(), this.serialNumber]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          issuer: this.issuer.toJSON(),
          serialNumber: this.serialNumber.toJSON()
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case ISSUER:
            return new RelativeDistinguishedNames();
          case SERIAL_NUMBER$2:
            return new Integer();
          default:
            return _superPropGet(IssuerAndSerialNumber, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [RelativeDistinguishedNames.schema(names.issuer || {}), new Integer({
            name: names.serialNumber || EMPTY_STRING
          })]
        });
      }
    }]);
  }(PkiObject);
  IssuerAndSerialNumber.CLASS_NAME = "IssuerAndSerialNumber";
  var VARIANT$3 = "variant";
  var VALUE$3 = "value";
  var CLEAR_PROPS$B = ["blockName"];
  var RecipientIdentifier = function (_PkiObject73) {
    function RecipientIdentifier() {
      var _this132;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, RecipientIdentifier);
      _this132 = _callSuper(this, RecipientIdentifier);
      _this132.variant = getParametersValue(parameters, VARIANT$3, RecipientIdentifier.defaultValues(VARIANT$3));
      if (VALUE$3 in parameters) {
        _this132.value = getParametersValue(parameters, VALUE$3, RecipientIdentifier.defaultValues(VALUE$3));
      }
      if (parameters.schema) {
        _this132.fromSchema(parameters.schema);
      }
      return _this132;
    }
    _inherits(RecipientIdentifier, _PkiObject73);
    return _createClass(RecipientIdentifier, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$B);
        var asn1 = compareSchema(schema, schema, RecipientIdentifier.schema({
          names: {
            blockName: "blockName"
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (asn1.result.blockName.idBlock.tagClass === 1) {
          this.variant = 1;
          this.value = new IssuerAndSerialNumber({
            schema: asn1.result.blockName
          });
        } else {
          this.variant = 2;
          this.value = new OctetString({
            valueHex: asn1.result.blockName.valueBlock.valueHex
          });
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        switch (this.variant) {
          case 1:
            if (!(this.value instanceof IssuerAndSerialNumber)) {
              throw new Error("Incorrect type of RecipientIdentifier.value. It should be IssuerAndSerialNumber.");
            }
            return this.value.toSchema();
          case 2:
            if (!(this.value instanceof OctetString)) {
              throw new Error("Incorrect type of RecipientIdentifier.value. It should be ASN.1 OctetString.");
            }
            return new Primitive({
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              valueHex: this.value.valueBlock.valueHexView
            });
          default:
            return new Any();
        }
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          variant: this.variant
        };
        if ((this.variant === 1 || this.variant === 2) && this.value) {
          res.value = this.value.toJSON();
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case VARIANT$3:
            return -1;
          case VALUE$3:
            return {};
          default:
            return _superPropGet(RecipientIdentifier, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VARIANT$3:
            return memberValue === -1;
          case VALUE$3:
            return Object.keys(memberValue).length === 0;
          default:
            return _superPropGet(RecipientIdentifier, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Choice({
          value: [IssuerAndSerialNumber.schema({
            names: {
              blockName: names.blockName || EMPTY_STRING
            }
          }), new Primitive({
            name: names.blockName || EMPTY_STRING,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            }
          })]
        });
      }
    }]);
  }(PkiObject);
  RecipientIdentifier.CLASS_NAME = "RecipientIdentifier";
  var VERSION$c = "version";
  var RID$1 = "rid";
  var KEY_ENCRYPTION_ALGORITHM$3 = "keyEncryptionAlgorithm";
  var ENCRYPTED_KEY$3 = "encryptedKey";
  var RECIPIENT_CERTIFICATE$1 = "recipientCertificate";
  var CLEAR_PROPS$A = [VERSION$c, RID$1, KEY_ENCRYPTION_ALGORITHM$3, ENCRYPTED_KEY$3];
  var KeyTransRecipientInfo = function (_PkiObject74) {
    function KeyTransRecipientInfo() {
      var _this133;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, KeyTransRecipientInfo);
      _this133 = _callSuper(this, KeyTransRecipientInfo);
      _this133.version = getParametersValue(parameters, VERSION$c, KeyTransRecipientInfo.defaultValues(VERSION$c));
      _this133.rid = getParametersValue(parameters, RID$1, KeyTransRecipientInfo.defaultValues(RID$1));
      _this133.keyEncryptionAlgorithm = getParametersValue(parameters, KEY_ENCRYPTION_ALGORITHM$3, KeyTransRecipientInfo.defaultValues(KEY_ENCRYPTION_ALGORITHM$3));
      _this133.encryptedKey = getParametersValue(parameters, ENCRYPTED_KEY$3, KeyTransRecipientInfo.defaultValues(ENCRYPTED_KEY$3));
      _this133.recipientCertificate = getParametersValue(parameters, RECIPIENT_CERTIFICATE$1, KeyTransRecipientInfo.defaultValues(RECIPIENT_CERTIFICATE$1));
      if (parameters.schema) {
        _this133.fromSchema(parameters.schema);
      }
      return _this133;
    }
    _inherits(KeyTransRecipientInfo, _PkiObject74);
    return _createClass(KeyTransRecipientInfo, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$A);
        var asn1 = compareSchema(schema, schema, KeyTransRecipientInfo.schema({
          names: {
            version: VERSION$c,
            rid: {
              names: {
                blockName: RID$1
              }
            },
            keyEncryptionAlgorithm: {
              names: {
                blockName: KEY_ENCRYPTION_ALGORITHM$3
              }
            },
            encryptedKey: ENCRYPTED_KEY$3
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result.version.valueBlock.valueDec;
        if (asn1.result.rid.idBlock.tagClass === 3) {
          this.rid = new OctetString({
            valueHex: asn1.result.rid.valueBlock.valueHex
          });
        } else {
          this.rid = new IssuerAndSerialNumber({
            schema: asn1.result.rid
          });
        }
        this.keyEncryptionAlgorithm = new AlgorithmIdentifier({
          schema: asn1.result.keyEncryptionAlgorithm
        });
        this.encryptedKey = asn1.result.encryptedKey;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        if (this.rid instanceof IssuerAndSerialNumber) {
          this.version = 0;
          outputArray.push(new Integer({
            value: this.version
          }));
          outputArray.push(this.rid.toSchema());
        } else {
          this.version = 2;
          outputArray.push(new Integer({
            value: this.version
          }));
          outputArray.push(new Primitive({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            valueHex: this.rid.valueBlock.valueHexView
          }));
        }
        outputArray.push(this.keyEncryptionAlgorithm.toSchema());
        outputArray.push(this.encryptedKey);
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          version: this.version,
          rid: this.rid.toJSON(),
          keyEncryptionAlgorithm: this.keyEncryptionAlgorithm.toJSON(),
          encryptedKey: this.encryptedKey.toJSON()
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case VERSION$c:
            return -1;
          case RID$1:
            return {};
          case KEY_ENCRYPTION_ALGORITHM$3:
            return new AlgorithmIdentifier();
          case ENCRYPTED_KEY$3:
            return new OctetString();
          case RECIPIENT_CERTIFICATE$1:
            return new Certificate();
          default:
            return _superPropGet(KeyTransRecipientInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VERSION$c:
            return memberValue === KeyTransRecipientInfo.defaultValues(VERSION$c);
          case RID$1:
            return Object.keys(memberValue).length === 0;
          case KEY_ENCRYPTION_ALGORITHM$3:
          case ENCRYPTED_KEY$3:
            return memberValue.isEqual(KeyTransRecipientInfo.defaultValues(memberName));
          case RECIPIENT_CERTIFICATE$1:
            return false;
          default:
            return _superPropGet(KeyTransRecipientInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Integer({
            name: names.version || EMPTY_STRING
          }), RecipientIdentifier.schema(names.rid || {}), AlgorithmIdentifier.schema(names.keyEncryptionAlgorithm || {}), new OctetString({
            name: names.encryptedKey || EMPTY_STRING
          })]
        });
      }
    }]);
  }(PkiObject);
  KeyTransRecipientInfo.CLASS_NAME = "KeyTransRecipientInfo";
  var ALGORITHM = "algorithm";
  var PUBLIC_KEY = "publicKey";
  var CLEAR_PROPS$z = [ALGORITHM, PUBLIC_KEY];
  var OriginatorPublicKey = function (_PkiObject75) {
    function OriginatorPublicKey() {
      var _this134;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, OriginatorPublicKey);
      _this134 = _callSuper(this, OriginatorPublicKey);
      _this134.algorithm = getParametersValue(parameters, ALGORITHM, OriginatorPublicKey.defaultValues(ALGORITHM));
      _this134.publicKey = getParametersValue(parameters, PUBLIC_KEY, OriginatorPublicKey.defaultValues(PUBLIC_KEY));
      if (parameters.schema) {
        _this134.fromSchema(parameters.schema);
      }
      return _this134;
    }
    _inherits(OriginatorPublicKey, _PkiObject75);
    return _createClass(OriginatorPublicKey, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$z);
        var asn1 = compareSchema(schema, schema, OriginatorPublicKey.schema({
          names: {
            algorithm: {
              names: {
                blockName: ALGORITHM
              }
            },
            publicKey: PUBLIC_KEY
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.algorithm = new AlgorithmIdentifier({
          schema: asn1.result.algorithm
        });
        this.publicKey = asn1.result.publicKey;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: [this.algorithm.toSchema(), this.publicKey]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          algorithm: this.algorithm.toJSON(),
          publicKey: this.publicKey.toJSON()
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case ALGORITHM:
            return new AlgorithmIdentifier();
          case PUBLIC_KEY:
            return new BitString();
          default:
            return _superPropGet(OriginatorPublicKey, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case ALGORITHM:
          case PUBLIC_KEY:
            return memberValue.isEqual(OriginatorPublicKey.defaultValues(memberName));
          default:
            return _superPropGet(OriginatorPublicKey, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [AlgorithmIdentifier.schema(names.algorithm || {}), new BitString({
            name: names.publicKey || EMPTY_STRING
          })]
        });
      }
    }]);
  }(PkiObject);
  OriginatorPublicKey.CLASS_NAME = "OriginatorPublicKey";
  var VARIANT$2 = "variant";
  var VALUE$2 = "value";
  var CLEAR_PROPS$y = ["blockName"];
  var OriginatorIdentifierOrKey = function (_PkiObject76) {
    function OriginatorIdentifierOrKey() {
      var _this135;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, OriginatorIdentifierOrKey);
      _this135 = _callSuper(this, OriginatorIdentifierOrKey);
      _this135.variant = getParametersValue(parameters, VARIANT$2, OriginatorIdentifierOrKey.defaultValues(VARIANT$2));
      if (VALUE$2 in parameters) {
        _this135.value = getParametersValue(parameters, VALUE$2, OriginatorIdentifierOrKey.defaultValues(VALUE$2));
      }
      if (parameters.schema) {
        _this135.fromSchema(parameters.schema);
      }
      return _this135;
    }
    _inherits(OriginatorIdentifierOrKey, _PkiObject76);
    return _createClass(OriginatorIdentifierOrKey, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$y);
        var asn1 = compareSchema(schema, schema, OriginatorIdentifierOrKey.schema({
          names: {
            blockName: "blockName"
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (asn1.result.blockName.idBlock.tagClass === 1) {
          this.variant = 1;
          this.value = new IssuerAndSerialNumber({
            schema: asn1.result.blockName
          });
        } else {
          if (asn1.result.blockName.idBlock.tagNumber === 0) {
            asn1.result.blockName.idBlock.tagClass = 1;
            asn1.result.blockName.idBlock.tagNumber = 4;
            this.variant = 2;
            this.value = asn1.result.blockName;
          } else {
            this.variant = 3;
            this.value = new OriginatorPublicKey({
              schema: new Sequence({
                value: asn1.result.blockName.valueBlock.value
              })
            });
          }
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        switch (this.variant) {
          case 1:
            return this.value.toSchema();
          case 2:
            this.value.idBlock.tagClass = 3;
            this.value.idBlock.tagNumber = 0;
            return this.value;
          case 3:
            {
              var _schema = this.value.toSchema();
              _schema.idBlock.tagClass = 3;
              _schema.idBlock.tagNumber = 1;
              return _schema;
            }
          default:
            return new Any();
        }
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          variant: this.variant
        };
        if (this.variant === 1 || this.variant === 2 || this.variant === 3) {
          res.value = this.value.toJSON();
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case VARIANT$2:
            return -1;
          case VALUE$2:
            return {};
          default:
            return _superPropGet(OriginatorIdentifierOrKey, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VARIANT$2:
            return memberValue === -1;
          case VALUE$2:
            return Object.keys(memberValue).length === 0;
          default:
            return _superPropGet(OriginatorIdentifierOrKey, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Choice({
          value: [IssuerAndSerialNumber.schema({
            names: {
              blockName: names.blockName || EMPTY_STRING
            }
          }), new Primitive({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            name: names.blockName || EMPTY_STRING
          }), new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            name: names.blockName || EMPTY_STRING,
            value: OriginatorPublicKey.schema().valueBlock.value
          })]
        });
      }
    }]);
  }(PkiObject);
  OriginatorIdentifierOrKey.CLASS_NAME = "OriginatorIdentifierOrKey";
  var KEY_ATTR_ID = "keyAttrId";
  var KEY_ATTR = "keyAttr";
  var CLEAR_PROPS$x = [KEY_ATTR_ID, KEY_ATTR];
  var OtherKeyAttribute = function (_PkiObject77) {
    function OtherKeyAttribute() {
      var _this136;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, OtherKeyAttribute);
      _this136 = _callSuper(this, OtherKeyAttribute);
      _this136.keyAttrId = getParametersValue(parameters, KEY_ATTR_ID, OtherKeyAttribute.defaultValues(KEY_ATTR_ID));
      if (KEY_ATTR in parameters) {
        _this136.keyAttr = getParametersValue(parameters, KEY_ATTR, OtherKeyAttribute.defaultValues(KEY_ATTR));
      }
      if (parameters.schema) {
        _this136.fromSchema(parameters.schema);
      }
      return _this136;
    }
    _inherits(OtherKeyAttribute, _PkiObject77);
    return _createClass(OtherKeyAttribute, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$x);
        var asn1 = compareSchema(schema, schema, OtherKeyAttribute.schema({
          names: {
            keyAttrId: KEY_ATTR_ID,
            keyAttr: KEY_ATTR
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.keyAttrId = asn1.result.keyAttrId.valueBlock.toString();
        if (KEY_ATTR in asn1.result) {
          this.keyAttr = asn1.result.keyAttr;
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        outputArray.push(new ObjectIdentifier({
          value: this.keyAttrId
        }));
        if (KEY_ATTR in this) {
          outputArray.push(this.keyAttr);
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          keyAttrId: this.keyAttrId
        };
        if (KEY_ATTR in this) {
          res.keyAttr = this.keyAttr.toJSON();
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case KEY_ATTR_ID:
            return EMPTY_STRING;
          case KEY_ATTR:
            return {};
          default:
            return _superPropGet(OtherKeyAttribute, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case KEY_ATTR_ID:
            return typeof memberValue === "string" && memberValue === EMPTY_STRING;
          case KEY_ATTR:
            return Object.keys(memberValue).length === 0;
          default:
            return _superPropGet(OtherKeyAttribute, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          optional: names.optional || true,
          name: names.blockName || EMPTY_STRING,
          value: [new ObjectIdentifier({
            name: names.keyAttrId || EMPTY_STRING
          }), new Any({
            optional: true,
            name: names.keyAttr || EMPTY_STRING
          })]
        });
      }
    }]);
  }(PkiObject);
  OtherKeyAttribute.CLASS_NAME = "OtherKeyAttribute";
  var SUBJECT_KEY_IDENTIFIER = "subjectKeyIdentifier";
  var DATE$1 = "date";
  var OTHER$1 = "other";
  var CLEAR_PROPS$w = [SUBJECT_KEY_IDENTIFIER, DATE$1, OTHER$1];
  var RecipientKeyIdentifier = function (_PkiObject78) {
    function RecipientKeyIdentifier() {
      var _this137;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, RecipientKeyIdentifier);
      _this137 = _callSuper(this, RecipientKeyIdentifier);
      _this137.subjectKeyIdentifier = getParametersValue(parameters, SUBJECT_KEY_IDENTIFIER, RecipientKeyIdentifier.defaultValues(SUBJECT_KEY_IDENTIFIER));
      if (DATE$1 in parameters) {
        _this137.date = getParametersValue(parameters, DATE$1, RecipientKeyIdentifier.defaultValues(DATE$1));
      }
      if (OTHER$1 in parameters) {
        _this137.other = getParametersValue(parameters, OTHER$1, RecipientKeyIdentifier.defaultValues(OTHER$1));
      }
      if (parameters.schema) {
        _this137.fromSchema(parameters.schema);
      }
      return _this137;
    }
    _inherits(RecipientKeyIdentifier, _PkiObject78);
    return _createClass(RecipientKeyIdentifier, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$w);
        var asn1 = compareSchema(schema, schema, RecipientKeyIdentifier.schema({
          names: {
            subjectKeyIdentifier: SUBJECT_KEY_IDENTIFIER,
            date: DATE$1,
            other: {
              names: {
                blockName: OTHER$1
              }
            }
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.subjectKeyIdentifier = asn1.result.subjectKeyIdentifier;
        if (DATE$1 in asn1.result) this.date = asn1.result.date;
        if (OTHER$1 in asn1.result) this.other = new OtherKeyAttribute({
          schema: asn1.result.other
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        outputArray.push(this.subjectKeyIdentifier);
        if (this.date) {
          outputArray.push(this.date);
        }
        if (this.other) {
          outputArray.push(this.other.toSchema());
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          subjectKeyIdentifier: this.subjectKeyIdentifier.toJSON()
        };
        if (this.date) {
          res.date = this.date.toJSON();
        }
        if (this.other) {
          res.other = this.other.toJSON();
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case SUBJECT_KEY_IDENTIFIER:
            return new OctetString();
          case DATE$1:
            return new GeneralizedTime();
          case OTHER$1:
            return new OtherKeyAttribute();
          default:
            return _superPropGet(RecipientKeyIdentifier, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case SUBJECT_KEY_IDENTIFIER:
            return memberValue.isEqual(RecipientKeyIdentifier.defaultValues(SUBJECT_KEY_IDENTIFIER));
          case DATE$1:
            return memberValue.year === 0 && memberValue.month === 0 && memberValue.day === 0 && memberValue.hour === 0 && memberValue.minute === 0 && memberValue.second === 0 && memberValue.millisecond === 0;
          case OTHER$1:
            return memberValue.keyAttrId === EMPTY_STRING && "keyAttr" in memberValue === false;
          default:
            return _superPropGet(RecipientKeyIdentifier, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new OctetString({
            name: names.subjectKeyIdentifier || EMPTY_STRING
          }), new GeneralizedTime({
            optional: true,
            name: names.date || EMPTY_STRING
          }), OtherKeyAttribute.schema(names.other || {})]
        });
      }
    }]);
  }(PkiObject);
  RecipientKeyIdentifier.CLASS_NAME = "RecipientKeyIdentifier";
  var VARIANT$1 = "variant";
  var VALUE$1 = "value";
  var CLEAR_PROPS$v = ["blockName"];
  var KeyAgreeRecipientIdentifier = function (_PkiObject79) {
    function KeyAgreeRecipientIdentifier() {
      var _this138;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, KeyAgreeRecipientIdentifier);
      _this138 = _callSuper(this, KeyAgreeRecipientIdentifier);
      _this138.variant = getParametersValue(parameters, VARIANT$1, KeyAgreeRecipientIdentifier.defaultValues(VARIANT$1));
      _this138.value = getParametersValue(parameters, VALUE$1, KeyAgreeRecipientIdentifier.defaultValues(VALUE$1));
      if (parameters.schema) {
        _this138.fromSchema(parameters.schema);
      }
      return _this138;
    }
    _inherits(KeyAgreeRecipientIdentifier, _PkiObject79);
    return _createClass(KeyAgreeRecipientIdentifier, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$v);
        var asn1 = compareSchema(schema, schema, KeyAgreeRecipientIdentifier.schema({
          names: {
            blockName: "blockName"
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (asn1.result.blockName.idBlock.tagClass === 1) {
          this.variant = 1;
          this.value = new IssuerAndSerialNumber({
            schema: asn1.result.blockName
          });
        } else {
          this.variant = 2;
          this.value = new RecipientKeyIdentifier({
            schema: new Sequence({
              value: asn1.result.blockName.valueBlock.value
            })
          });
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        switch (this.variant) {
          case 1:
            return this.value.toSchema();
          case 2:
            return new Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: this.value.toSchema().valueBlock.value
            });
          default:
            return new Any();
        }
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          variant: this.variant
        };
        if (this.variant === 1 || this.variant === 2) {
          res.value = this.value.toJSON();
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case VARIANT$1:
            return -1;
          case VALUE$1:
            return {};
          default:
            return _superPropGet(KeyAgreeRecipientIdentifier, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VARIANT$1:
            return memberValue === -1;
          case VALUE$1:
            return Object.keys(memberValue).length === 0;
          default:
            return _superPropGet(KeyAgreeRecipientIdentifier, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Choice({
          value: [IssuerAndSerialNumber.schema(names.issuerAndSerialNumber || {
            names: {
              blockName: names.blockName || EMPTY_STRING
            }
          }), new Constructed({
            name: names.blockName || EMPTY_STRING,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: RecipientKeyIdentifier.schema(names.rKeyId || {
              names: {
                blockName: names.blockName || EMPTY_STRING
              }
            }).valueBlock.value
          })]
        });
      }
    }]);
  }(PkiObject);
  KeyAgreeRecipientIdentifier.CLASS_NAME = "KeyAgreeRecipientIdentifier";
  var RID = "rid";
  var ENCRYPTED_KEY$2 = "encryptedKey";
  var CLEAR_PROPS$u = [RID, ENCRYPTED_KEY$2];
  var RecipientEncryptedKey = function (_PkiObject80) {
    function RecipientEncryptedKey() {
      var _this139;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, RecipientEncryptedKey);
      _this139 = _callSuper(this, RecipientEncryptedKey);
      _this139.rid = getParametersValue(parameters, RID, RecipientEncryptedKey.defaultValues(RID));
      _this139.encryptedKey = getParametersValue(parameters, ENCRYPTED_KEY$2, RecipientEncryptedKey.defaultValues(ENCRYPTED_KEY$2));
      if (parameters.schema) {
        _this139.fromSchema(parameters.schema);
      }
      return _this139;
    }
    _inherits(RecipientEncryptedKey, _PkiObject80);
    return _createClass(RecipientEncryptedKey, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$u);
        var asn1 = compareSchema(schema, schema, RecipientEncryptedKey.schema({
          names: {
            rid: {
              names: {
                blockName: RID
              }
            },
            encryptedKey: ENCRYPTED_KEY$2
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.rid = new KeyAgreeRecipientIdentifier({
          schema: asn1.result.rid
        });
        this.encryptedKey = asn1.result.encryptedKey;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: [this.rid.toSchema(), this.encryptedKey]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          rid: this.rid.toJSON(),
          encryptedKey: this.encryptedKey.toJSON()
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case RID:
            return new KeyAgreeRecipientIdentifier();
          case ENCRYPTED_KEY$2:
            return new OctetString();
          default:
            return _superPropGet(RecipientEncryptedKey, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case RID:
            return memberValue.variant === -1 && "value" in memberValue === false;
          case ENCRYPTED_KEY$2:
            return memberValue.isEqual(RecipientEncryptedKey.defaultValues(ENCRYPTED_KEY$2));
          default:
            return _superPropGet(RecipientEncryptedKey, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [KeyAgreeRecipientIdentifier.schema(names.rid || {}), new OctetString({
            name: names.encryptedKey || EMPTY_STRING
          })]
        });
      }
    }]);
  }(PkiObject);
  RecipientEncryptedKey.CLASS_NAME = "RecipientEncryptedKey";
  var ENCRYPTED_KEYS = "encryptedKeys";
  var RECIPIENT_ENCRYPTED_KEYS = "RecipientEncryptedKeys";
  var CLEAR_PROPS$t = [RECIPIENT_ENCRYPTED_KEYS];
  var RecipientEncryptedKeys = function (_PkiObject81) {
    function RecipientEncryptedKeys() {
      var _this140;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, RecipientEncryptedKeys);
      _this140 = _callSuper(this, RecipientEncryptedKeys);
      _this140.encryptedKeys = getParametersValue(parameters, ENCRYPTED_KEYS, RecipientEncryptedKeys.defaultValues(ENCRYPTED_KEYS));
      if (parameters.schema) {
        _this140.fromSchema(parameters.schema);
      }
      return _this140;
    }
    _inherits(RecipientEncryptedKeys, _PkiObject81);
    return _createClass(RecipientEncryptedKeys, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$t);
        var asn1 = compareSchema(schema, schema, RecipientEncryptedKeys.schema({
          names: {
            RecipientEncryptedKeys: RECIPIENT_ENCRYPTED_KEYS
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.encryptedKeys = Array.from(asn1.result.RecipientEncryptedKeys, function (element) {
          return new RecipientEncryptedKey({
            schema: element
          });
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: Array.from(this.encryptedKeys, function (o) {
            return o.toSchema();
          })
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          encryptedKeys: Array.from(this.encryptedKeys, function (o) {
            return o.toJSON();
          })
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case ENCRYPTED_KEYS:
            return [];
          default:
            return _superPropGet(RecipientEncryptedKeys, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case ENCRYPTED_KEYS:
            return memberValue.length === 0;
          default:
            return _superPropGet(RecipientEncryptedKeys, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Repeated({
            name: names.RecipientEncryptedKeys || EMPTY_STRING,
            value: RecipientEncryptedKey.schema()
          })]
        });
      }
    }]);
  }(PkiObject);
  RecipientEncryptedKeys.CLASS_NAME = "RecipientEncryptedKeys";
  var VERSION$b = "version";
  var ORIGINATOR = "originator";
  var UKM = "ukm";
  var KEY_ENCRYPTION_ALGORITHM$2 = "keyEncryptionAlgorithm";
  var RECIPIENT_ENCRYPTED_KEY = "recipientEncryptedKeys";
  var RECIPIENT_CERTIFICATE = "recipientCertificate";
  var RECIPIENT_PUBLIC_KEY = "recipientPublicKey";
  var CLEAR_PROPS$s = [VERSION$b, ORIGINATOR, UKM, KEY_ENCRYPTION_ALGORITHM$2, RECIPIENT_ENCRYPTED_KEY];
  var KeyAgreeRecipientInfo = function (_PkiObject82) {
    function KeyAgreeRecipientInfo() {
      var _this141;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, KeyAgreeRecipientInfo);
      _this141 = _callSuper(this, KeyAgreeRecipientInfo);
      _this141.version = getParametersValue(parameters, VERSION$b, KeyAgreeRecipientInfo.defaultValues(VERSION$b));
      _this141.originator = getParametersValue(parameters, ORIGINATOR, KeyAgreeRecipientInfo.defaultValues(ORIGINATOR));
      if (UKM in parameters) {
        _this141.ukm = getParametersValue(parameters, UKM, KeyAgreeRecipientInfo.defaultValues(UKM));
      }
      _this141.keyEncryptionAlgorithm = getParametersValue(parameters, KEY_ENCRYPTION_ALGORITHM$2, KeyAgreeRecipientInfo.defaultValues(KEY_ENCRYPTION_ALGORITHM$2));
      _this141.recipientEncryptedKeys = getParametersValue(parameters, RECIPIENT_ENCRYPTED_KEY, KeyAgreeRecipientInfo.defaultValues(RECIPIENT_ENCRYPTED_KEY));
      _this141.recipientCertificate = getParametersValue(parameters, RECIPIENT_CERTIFICATE, KeyAgreeRecipientInfo.defaultValues(RECIPIENT_CERTIFICATE));
      _this141.recipientPublicKey = getParametersValue(parameters, RECIPIENT_PUBLIC_KEY, KeyAgreeRecipientInfo.defaultValues(RECIPIENT_PUBLIC_KEY));
      if (parameters.schema) {
        _this141.fromSchema(parameters.schema);
      }
      return _this141;
    }
    _inherits(KeyAgreeRecipientInfo, _PkiObject82);
    return _createClass(KeyAgreeRecipientInfo, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$s);
        var asn1 = compareSchema(schema, schema, KeyAgreeRecipientInfo.schema({
          names: {
            version: VERSION$b,
            originator: {
              names: {
                blockName: ORIGINATOR
              }
            },
            ukm: UKM,
            keyEncryptionAlgorithm: {
              names: {
                blockName: KEY_ENCRYPTION_ALGORITHM$2
              }
            },
            recipientEncryptedKeys: {
              names: {
                blockName: RECIPIENT_ENCRYPTED_KEY
              }
            }
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result.version.valueBlock.valueDec;
        this.originator = new OriginatorIdentifierOrKey({
          schema: asn1.result.originator
        });
        if (UKM in asn1.result) this.ukm = asn1.result.ukm;
        this.keyEncryptionAlgorithm = new AlgorithmIdentifier({
          schema: asn1.result.keyEncryptionAlgorithm
        });
        this.recipientEncryptedKeys = new RecipientEncryptedKeys({
          schema: asn1.result.recipientEncryptedKeys
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        outputArray.push(new Integer({
          value: this.version
        }));
        outputArray.push(new Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [this.originator.toSchema()]
        }));
        if (this.ukm) {
          outputArray.push(new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: [this.ukm]
          }));
        }
        outputArray.push(this.keyEncryptionAlgorithm.toSchema());
        outputArray.push(this.recipientEncryptedKeys.toSchema());
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          version: this.version,
          originator: this.originator.toJSON(),
          keyEncryptionAlgorithm: this.keyEncryptionAlgorithm.toJSON(),
          recipientEncryptedKeys: this.recipientEncryptedKeys.toJSON()
        };
        if (this.ukm) {
          res.ukm = this.ukm.toJSON();
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case VERSION$b:
            return 0;
          case ORIGINATOR:
            return new OriginatorIdentifierOrKey();
          case UKM:
            return new OctetString();
          case KEY_ENCRYPTION_ALGORITHM$2:
            return new AlgorithmIdentifier();
          case RECIPIENT_ENCRYPTED_KEY:
            return new RecipientEncryptedKeys();
          case RECIPIENT_CERTIFICATE:
            return new Certificate();
          case RECIPIENT_PUBLIC_KEY:
            return null;
          default:
            return _superPropGet(KeyAgreeRecipientInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VERSION$b:
            return memberValue === 0;
          case ORIGINATOR:
            return memberValue.variant === -1 && "value" in memberValue === false;
          case UKM:
            return memberValue.isEqual(KeyAgreeRecipientInfo.defaultValues(UKM));
          case KEY_ENCRYPTION_ALGORITHM$2:
            return memberValue.algorithmId === EMPTY_STRING && "algorithmParams" in memberValue === false;
          case RECIPIENT_ENCRYPTED_KEY:
            return memberValue.encryptedKeys.length === 0;
          case RECIPIENT_CERTIFICATE:
            return false;
          case RECIPIENT_PUBLIC_KEY:
            return false;
          default:
            return _superPropGet(KeyAgreeRecipientInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Integer({
            name: names.version || EMPTY_STRING
          }), new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [OriginatorIdentifierOrKey.schema(names.originator || {})]
          }), new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: [new OctetString({
              name: names.ukm || EMPTY_STRING
            })]
          }), AlgorithmIdentifier.schema(names.keyEncryptionAlgorithm || {}), RecipientEncryptedKeys.schema(names.recipientEncryptedKeys || {})]
        });
      }
    }]);
  }(PkiObject);
  KeyAgreeRecipientInfo.CLASS_NAME = "KeyAgreeRecipientInfo";
  var KEY_IDENTIFIER = "keyIdentifier";
  var DATE = "date";
  var OTHER = "other";
  var CLEAR_PROPS$r = [KEY_IDENTIFIER, DATE, OTHER];
  var KEKIdentifier = function (_PkiObject83) {
    function KEKIdentifier() {
      var _this142;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, KEKIdentifier);
      _this142 = _callSuper(this, KEKIdentifier);
      _this142.keyIdentifier = getParametersValue(parameters, KEY_IDENTIFIER, KEKIdentifier.defaultValues(KEY_IDENTIFIER));
      if (DATE in parameters) {
        _this142.date = getParametersValue(parameters, DATE, KEKIdentifier.defaultValues(DATE));
      }
      if (OTHER in parameters) {
        _this142.other = getParametersValue(parameters, OTHER, KEKIdentifier.defaultValues(OTHER));
      }
      if (parameters.schema) {
        _this142.fromSchema(parameters.schema);
      }
      return _this142;
    }
    _inherits(KEKIdentifier, _PkiObject83);
    return _createClass(KEKIdentifier, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$r);
        var asn1 = compareSchema(schema, schema, KEKIdentifier.schema({
          names: {
            keyIdentifier: KEY_IDENTIFIER,
            date: DATE,
            other: {
              names: {
                blockName: OTHER
              }
            }
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.keyIdentifier = asn1.result.keyIdentifier;
        if (DATE in asn1.result) this.date = asn1.result.date;
        if (OTHER in asn1.result) this.other = new OtherKeyAttribute({
          schema: asn1.result.other
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        outputArray.push(this.keyIdentifier);
        if (this.date) {
          outputArray.push(this.date);
        }
        if (this.other) {
          outputArray.push(this.other.toSchema());
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          keyIdentifier: this.keyIdentifier.toJSON()
        };
        if (this.date) {
          res.date = this.date;
        }
        if (this.other) {
          res.other = this.other.toJSON();
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case KEY_IDENTIFIER:
            return new OctetString();
          case DATE:
            return new GeneralizedTime();
          case OTHER:
            return new OtherKeyAttribute();
          default:
            return _superPropGet(KEKIdentifier, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case KEY_IDENTIFIER:
            return memberValue.isEqual(KEKIdentifier.defaultValues(KEY_IDENTIFIER));
          case DATE:
            return memberValue.year === 0 && memberValue.month === 0 && memberValue.day === 0 && memberValue.hour === 0 && memberValue.minute === 0 && memberValue.second === 0 && memberValue.millisecond === 0;
          case OTHER:
            return memberValue.compareWithDefault("keyAttrId", memberValue.keyAttrId) && "keyAttr" in memberValue === false;
          default:
            return _superPropGet(KEKIdentifier, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new OctetString({
            name: names.keyIdentifier || EMPTY_STRING
          }), new GeneralizedTime({
            optional: true,
            name: names.date || EMPTY_STRING
          }), OtherKeyAttribute.schema(names.other || {})]
        });
      }
    }]);
  }(PkiObject);
  KEKIdentifier.CLASS_NAME = "KEKIdentifier";
  var VERSION$a = "version";
  var KEK_ID = "kekid";
  var KEY_ENCRYPTION_ALGORITHM$1 = "keyEncryptionAlgorithm";
  var ENCRYPTED_KEY$1 = "encryptedKey";
  var PER_DEFINED_KEK = "preDefinedKEK";
  var CLEAR_PROPS$q = [VERSION$a, KEK_ID, KEY_ENCRYPTION_ALGORITHM$1, ENCRYPTED_KEY$1];
  var KEKRecipientInfo = function (_PkiObject84) {
    function KEKRecipientInfo() {
      var _this143;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, KEKRecipientInfo);
      _this143 = _callSuper(this, KEKRecipientInfo);
      _this143.version = getParametersValue(parameters, VERSION$a, KEKRecipientInfo.defaultValues(VERSION$a));
      _this143.kekid = getParametersValue(parameters, KEK_ID, KEKRecipientInfo.defaultValues(KEK_ID));
      _this143.keyEncryptionAlgorithm = getParametersValue(parameters, KEY_ENCRYPTION_ALGORITHM$1, KEKRecipientInfo.defaultValues(KEY_ENCRYPTION_ALGORITHM$1));
      _this143.encryptedKey = getParametersValue(parameters, ENCRYPTED_KEY$1, KEKRecipientInfo.defaultValues(ENCRYPTED_KEY$1));
      _this143.preDefinedKEK = getParametersValue(parameters, PER_DEFINED_KEK, KEKRecipientInfo.defaultValues(PER_DEFINED_KEK));
      if (parameters.schema) {
        _this143.fromSchema(parameters.schema);
      }
      return _this143;
    }
    _inherits(KEKRecipientInfo, _PkiObject84);
    return _createClass(KEKRecipientInfo, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$q);
        var asn1 = compareSchema(schema, schema, KEKRecipientInfo.schema({
          names: {
            version: VERSION$a,
            kekid: {
              names: {
                blockName: KEK_ID
              }
            },
            keyEncryptionAlgorithm: {
              names: {
                blockName: KEY_ENCRYPTION_ALGORITHM$1
              }
            },
            encryptedKey: ENCRYPTED_KEY$1
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result.version.valueBlock.valueDec;
        this.kekid = new KEKIdentifier({
          schema: asn1.result.kekid
        });
        this.keyEncryptionAlgorithm = new AlgorithmIdentifier({
          schema: asn1.result.keyEncryptionAlgorithm
        });
        this.encryptedKey = asn1.result.encryptedKey;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: [new Integer({
            value: this.version
          }), this.kekid.toSchema(), this.keyEncryptionAlgorithm.toSchema(), this.encryptedKey]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          version: this.version,
          kekid: this.kekid.toJSON(),
          keyEncryptionAlgorithm: this.keyEncryptionAlgorithm.toJSON(),
          encryptedKey: this.encryptedKey.toJSON()
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case VERSION$a:
            return 0;
          case KEK_ID:
            return new KEKIdentifier();
          case KEY_ENCRYPTION_ALGORITHM$1:
            return new AlgorithmIdentifier();
          case ENCRYPTED_KEY$1:
            return new OctetString();
          case PER_DEFINED_KEK:
            return EMPTY_BUFFER;
          default:
            return _superPropGet(KEKRecipientInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case "KEKRecipientInfo":
            return memberValue === KEKRecipientInfo.defaultValues(VERSION$a);
          case KEK_ID:
            return memberValue.compareWithDefault("keyIdentifier", memberValue.keyIdentifier) && "date" in memberValue === false && "other" in memberValue === false;
          case KEY_ENCRYPTION_ALGORITHM$1:
            return memberValue.algorithmId === EMPTY_STRING && "algorithmParams" in memberValue === false;
          case ENCRYPTED_KEY$1:
            return memberValue.isEqual(KEKRecipientInfo.defaultValues(ENCRYPTED_KEY$1));
          case PER_DEFINED_KEK:
            return memberValue.byteLength === 0;
          default:
            return _superPropGet(KEKRecipientInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Integer({
            name: names.version || EMPTY_STRING
          }), KEKIdentifier.schema(names.kekid || {}), AlgorithmIdentifier.schema(names.keyEncryptionAlgorithm || {}), new OctetString({
            name: names.encryptedKey || EMPTY_STRING
          })]
        });
      }
    }]);
  }(PkiObject);
  KEKRecipientInfo.CLASS_NAME = "KEKRecipientInfo";
  var VERSION$9 = "version";
  var KEY_DERIVATION_ALGORITHM = "keyDerivationAlgorithm";
  var KEY_ENCRYPTION_ALGORITHM = "keyEncryptionAlgorithm";
  var ENCRYPTED_KEY = "encryptedKey";
  var PASSWORD = "password";
  var CLEAR_PROPS$p = [VERSION$9, KEY_DERIVATION_ALGORITHM, KEY_ENCRYPTION_ALGORITHM, ENCRYPTED_KEY];
  var PasswordRecipientinfo = function (_PkiObject85) {
    function PasswordRecipientinfo() {
      var _this144;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, PasswordRecipientinfo);
      _this144 = _callSuper(this, PasswordRecipientinfo);
      _this144.version = getParametersValue(parameters, VERSION$9, PasswordRecipientinfo.defaultValues(VERSION$9));
      if (KEY_DERIVATION_ALGORITHM in parameters) {
        _this144.keyDerivationAlgorithm = getParametersValue(parameters, KEY_DERIVATION_ALGORITHM, PasswordRecipientinfo.defaultValues(KEY_DERIVATION_ALGORITHM));
      }
      _this144.keyEncryptionAlgorithm = getParametersValue(parameters, KEY_ENCRYPTION_ALGORITHM, PasswordRecipientinfo.defaultValues(KEY_ENCRYPTION_ALGORITHM));
      _this144.encryptedKey = getParametersValue(parameters, ENCRYPTED_KEY, PasswordRecipientinfo.defaultValues(ENCRYPTED_KEY));
      _this144.password = getParametersValue(parameters, PASSWORD, PasswordRecipientinfo.defaultValues(PASSWORD));
      if (parameters.schema) {
        _this144.fromSchema(parameters.schema);
      }
      return _this144;
    }
    _inherits(PasswordRecipientinfo, _PkiObject85);
    return _createClass(PasswordRecipientinfo, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$p);
        var asn1 = compareSchema(schema, schema, PasswordRecipientinfo.schema({
          names: {
            version: VERSION$9,
            keyDerivationAlgorithm: KEY_DERIVATION_ALGORITHM,
            keyEncryptionAlgorithm: {
              names: {
                blockName: KEY_ENCRYPTION_ALGORITHM
              }
            },
            encryptedKey: ENCRYPTED_KEY
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result.version.valueBlock.valueDec;
        if (KEY_DERIVATION_ALGORITHM in asn1.result) {
          this.keyDerivationAlgorithm = new AlgorithmIdentifier({
            schema: new Sequence({
              value: asn1.result.keyDerivationAlgorithm.valueBlock.value
            })
          });
        }
        this.keyEncryptionAlgorithm = new AlgorithmIdentifier({
          schema: asn1.result.keyEncryptionAlgorithm
        });
        this.encryptedKey = asn1.result.encryptedKey;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        outputArray.push(new Integer({
          value: this.version
        }));
        if (this.keyDerivationAlgorithm) {
          outputArray.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: this.keyDerivationAlgorithm.toSchema().valueBlock.value
          }));
        }
        outputArray.push(this.keyEncryptionAlgorithm.toSchema());
        outputArray.push(this.encryptedKey);
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          version: this.version,
          keyEncryptionAlgorithm: this.keyEncryptionAlgorithm.toJSON(),
          encryptedKey: this.encryptedKey.toJSON()
        };
        if (this.keyDerivationAlgorithm) {
          res.keyDerivationAlgorithm = this.keyDerivationAlgorithm.toJSON();
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case VERSION$9:
            return -1;
          case KEY_DERIVATION_ALGORITHM:
            return new AlgorithmIdentifier();
          case KEY_ENCRYPTION_ALGORITHM:
            return new AlgorithmIdentifier();
          case ENCRYPTED_KEY:
            return new OctetString();
          case PASSWORD:
            return EMPTY_BUFFER;
          default:
            return _superPropGet(PasswordRecipientinfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VERSION$9:
            return memberValue === -1;
          case KEY_DERIVATION_ALGORITHM:
          case KEY_ENCRYPTION_ALGORITHM:
            return memberValue.algorithmId === EMPTY_STRING && "algorithmParams" in memberValue === false;
          case ENCRYPTED_KEY:
            return memberValue.isEqual(PasswordRecipientinfo.defaultValues(ENCRYPTED_KEY));
          case PASSWORD:
            return memberValue.byteLength === 0;
          default:
            return _superPropGet(PasswordRecipientinfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Integer({
            name: names.version || EMPTY_STRING
          }), new Constructed({
            name: names.keyDerivationAlgorithm || EMPTY_STRING,
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: AlgorithmIdentifier.schema().valueBlock.value
          }), AlgorithmIdentifier.schema(names.keyEncryptionAlgorithm || {}), new OctetString({
            name: names.encryptedKey || EMPTY_STRING
          })]
        });
      }
    }]);
  }(PkiObject);
  PasswordRecipientinfo.CLASS_NAME = "PasswordRecipientInfo";
  var ORI_TYPE = "oriType";
  var ORI_VALUE = "oriValue";
  var CLEAR_PROPS$o = [ORI_TYPE, ORI_VALUE];
  var OtherRecipientInfo = function (_PkiObject86) {
    function OtherRecipientInfo() {
      var _this145;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, OtherRecipientInfo);
      _this145 = _callSuper(this, OtherRecipientInfo);
      _this145.oriType = getParametersValue(parameters, ORI_TYPE, OtherRecipientInfo.defaultValues(ORI_TYPE));
      _this145.oriValue = getParametersValue(parameters, ORI_VALUE, OtherRecipientInfo.defaultValues(ORI_VALUE));
      if (parameters.schema) {
        _this145.fromSchema(parameters.schema);
      }
      return _this145;
    }
    _inherits(OtherRecipientInfo, _PkiObject86);
    return _createClass(OtherRecipientInfo, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$o);
        var asn1 = compareSchema(schema, schema, OtherRecipientInfo.schema({
          names: {
            oriType: ORI_TYPE,
            oriValue: ORI_VALUE
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.oriType = asn1.result.oriType.valueBlock.toString();
        this.oriValue = asn1.result.oriValue;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: [new ObjectIdentifier({
            value: this.oriType
          }), this.oriValue]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          oriType: this.oriType
        };
        if (!OtherRecipientInfo.compareWithDefault(ORI_VALUE, this.oriValue)) {
          res.oriValue = this.oriValue.toJSON();
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case ORI_TYPE:
            return EMPTY_STRING;
          case ORI_VALUE:
            return {};
          default:
            return _superPropGet(OtherRecipientInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case ORI_TYPE:
            return memberValue === EMPTY_STRING;
          case ORI_VALUE:
            return Object.keys(memberValue).length === 0;
          default:
            return _superPropGet(OtherRecipientInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new ObjectIdentifier({
            name: names.oriType || EMPTY_STRING
          }), new Any({
            name: names.oriValue || EMPTY_STRING
          })]
        });
      }
    }]);
  }(PkiObject);
  OtherRecipientInfo.CLASS_NAME = "OtherRecipientInfo";
  var VARIANT = "variant";
  var VALUE = "value";
  var CLEAR_PROPS$n = ["blockName"];
  var RecipientInfo = function (_PkiObject87) {
    function RecipientInfo() {
      var _this146;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, RecipientInfo);
      _this146 = _callSuper(this, RecipientInfo);
      _this146.variant = getParametersValue(parameters, VARIANT, RecipientInfo.defaultValues(VARIANT));
      if (VALUE in parameters) {
        _this146.value = getParametersValue(parameters, VALUE, RecipientInfo.defaultValues(VALUE));
      }
      if (parameters.schema) {
        _this146.fromSchema(parameters.schema);
      }
      return _this146;
    }
    _inherits(RecipientInfo, _PkiObject87);
    return _createClass(RecipientInfo, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$n);
        var asn1 = compareSchema(schema, schema, RecipientInfo.schema({
          names: {
            blockName: "blockName"
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (asn1.result.blockName.idBlock.tagClass === 1) {
          this.variant = 1;
          this.value = new KeyTransRecipientInfo({
            schema: asn1.result.blockName
          });
        } else {
          var blockSequence = new Sequence({
            value: asn1.result.blockName.valueBlock.value
          });
          switch (asn1.result.blockName.idBlock.tagNumber) {
            case 1:
              this.variant = 2;
              this.value = new KeyAgreeRecipientInfo({
                schema: blockSequence
              });
              break;
            case 2:
              this.variant = 3;
              this.value = new KEKRecipientInfo({
                schema: blockSequence
              });
              break;
            case 3:
              this.variant = 4;
              this.value = new PasswordRecipientinfo({
                schema: blockSequence
              });
              break;
            case 4:
              this.variant = 5;
              this.value = new OtherRecipientInfo({
                schema: blockSequence
              });
              break;
            default:
              throw new Error("Incorrect structure of RecipientInfo block");
          }
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        ParameterError.assertEmpty(this.value, "value", "RecipientInfo");
        var _schema = this.value.toSchema();
        switch (this.variant) {
          case 1:
            return _schema;
          case 2:
          case 3:
          case 4:
            _schema.idBlock.tagClass = 3;
            _schema.idBlock.tagNumber = this.variant - 1;
            return _schema;
          default:
            return new Any();
        }
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          variant: this.variant
        };
        if (this.value && this.variant >= 1 && this.variant <= 4) {
          res.value = this.value.toJSON();
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case VARIANT:
            return -1;
          case VALUE:
            return {};
          default:
            return _superPropGet(RecipientInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VARIANT:
            return memberValue === RecipientInfo.defaultValues(memberName);
          case VALUE:
            return Object.keys(memberValue).length === 0;
          default:
            return _superPropGet(RecipientInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Choice({
          value: [KeyTransRecipientInfo.schema({
            names: {
              blockName: names.blockName || EMPTY_STRING
            }
          }), new Constructed({
            name: names.blockName || EMPTY_STRING,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: KeyAgreeRecipientInfo.schema().valueBlock.value
          }), new Constructed({
            name: names.blockName || EMPTY_STRING,
            idBlock: {
              tagClass: 3,
              tagNumber: 2
            },
            value: KEKRecipientInfo.schema().valueBlock.value
          }), new Constructed({
            name: names.blockName || EMPTY_STRING,
            idBlock: {
              tagClass: 3,
              tagNumber: 3
            },
            value: PasswordRecipientinfo.schema().valueBlock.value
          }), new Constructed({
            name: names.blockName || EMPTY_STRING,
            idBlock: {
              tagClass: 3,
              tagNumber: 4
            },
            value: OtherRecipientInfo.schema().valueBlock.value
          })]
        });
      }
    }]);
  }(PkiObject);
  RecipientInfo.CLASS_NAME = "RecipientInfo";
  var HASH_ALGORITHM$2 = "hashAlgorithm";
  var MASK_GEN_ALGORITHM = "maskGenAlgorithm";
  var P_SOURCE_ALGORITHM = "pSourceAlgorithm";
  var CLEAR_PROPS$m = [HASH_ALGORITHM$2, MASK_GEN_ALGORITHM, P_SOURCE_ALGORITHM];
  var RSAESOAEPParams = function (_PkiObject88) {
    function RSAESOAEPParams() {
      var _this147;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, RSAESOAEPParams);
      _this147 = _callSuper(this, RSAESOAEPParams);
      _this147.hashAlgorithm = getParametersValue(parameters, HASH_ALGORITHM$2, RSAESOAEPParams.defaultValues(HASH_ALGORITHM$2));
      _this147.maskGenAlgorithm = getParametersValue(parameters, MASK_GEN_ALGORITHM, RSAESOAEPParams.defaultValues(MASK_GEN_ALGORITHM));
      _this147.pSourceAlgorithm = getParametersValue(parameters, P_SOURCE_ALGORITHM, RSAESOAEPParams.defaultValues(P_SOURCE_ALGORITHM));
      if (parameters.schema) {
        _this147.fromSchema(parameters.schema);
      }
      return _this147;
    }
    _inherits(RSAESOAEPParams, _PkiObject88);
    return _createClass(RSAESOAEPParams, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$m);
        var asn1 = compareSchema(schema, schema, RSAESOAEPParams.schema({
          names: {
            hashAlgorithm: {
              names: {
                blockName: HASH_ALGORITHM$2
              }
            },
            maskGenAlgorithm: {
              names: {
                blockName: MASK_GEN_ALGORITHM
              }
            },
            pSourceAlgorithm: {
              names: {
                blockName: P_SOURCE_ALGORITHM
              }
            }
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (HASH_ALGORITHM$2 in asn1.result) this.hashAlgorithm = new AlgorithmIdentifier({
          schema: asn1.result.hashAlgorithm
        });
        if (MASK_GEN_ALGORITHM in asn1.result) this.maskGenAlgorithm = new AlgorithmIdentifier({
          schema: asn1.result.maskGenAlgorithm
        });
        if (P_SOURCE_ALGORITHM in asn1.result) this.pSourceAlgorithm = new AlgorithmIdentifier({
          schema: asn1.result.pSourceAlgorithm
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        if (!this.hashAlgorithm.isEqual(RSAESOAEPParams.defaultValues(HASH_ALGORITHM$2))) {
          outputArray.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [this.hashAlgorithm.toSchema()]
          }));
        }
        if (!this.maskGenAlgorithm.isEqual(RSAESOAEPParams.defaultValues(MASK_GEN_ALGORITHM))) {
          outputArray.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: [this.maskGenAlgorithm.toSchema()]
          }));
        }
        if (!this.pSourceAlgorithm.isEqual(RSAESOAEPParams.defaultValues(P_SOURCE_ALGORITHM))) {
          outputArray.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 2
            },
            value: [this.pSourceAlgorithm.toSchema()]
          }));
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {};
        if (!this.hashAlgorithm.isEqual(RSAESOAEPParams.defaultValues(HASH_ALGORITHM$2))) {
          res.hashAlgorithm = this.hashAlgorithm.toJSON();
        }
        if (!this.maskGenAlgorithm.isEqual(RSAESOAEPParams.defaultValues(MASK_GEN_ALGORITHM))) {
          res.maskGenAlgorithm = this.maskGenAlgorithm.toJSON();
        }
        if (!this.pSourceAlgorithm.isEqual(RSAESOAEPParams.defaultValues(P_SOURCE_ALGORITHM))) {
          res.pSourceAlgorithm = this.pSourceAlgorithm.toJSON();
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case HASH_ALGORITHM$2:
            return new AlgorithmIdentifier({
              algorithmId: "1.3.14.3.2.26",
              algorithmParams: new Null()
            });
          case MASK_GEN_ALGORITHM:
            return new AlgorithmIdentifier({
              algorithmId: "1.2.840.113549.1.1.8",
              algorithmParams: new AlgorithmIdentifier({
                algorithmId: "1.3.14.3.2.26",
                algorithmParams: new Null()
              }).toSchema()
            });
          case P_SOURCE_ALGORITHM:
            return new AlgorithmIdentifier({
              algorithmId: "1.2.840.113549.1.1.9",
              algorithmParams: new OctetString({
                valueHex: new Uint8Array([0xda, 0x39, 0xa3, 0xee, 0x5e, 0x6b, 0x4b, 0x0d, 0x32, 0x55, 0xbf, 0xef, 0x95, 0x60, 0x18, 0x90, 0xaf, 0xd8, 0x07, 0x09]).buffer
              })
            });
          default:
            return _superPropGet(RSAESOAEPParams, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            optional: true,
            value: [AlgorithmIdentifier.schema(names.hashAlgorithm || {})]
          }), new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            optional: true,
            value: [AlgorithmIdentifier.schema(names.maskGenAlgorithm || {})]
          }), new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 2
            },
            optional: true,
            value: [AlgorithmIdentifier.schema(names.pSourceAlgorithm || {})]
          })]
        });
      }
    }]);
  }(PkiObject);
  RSAESOAEPParams.CLASS_NAME = "RSAESOAEPParams";
  var KEY_INFO = "keyInfo";
  var ENTITY_U_INFO = "entityUInfo";
  var SUPP_PUB_INFO = "suppPubInfo";
  var CLEAR_PROPS$l = [KEY_INFO, ENTITY_U_INFO, SUPP_PUB_INFO];
  var ECCCMSSharedInfo = function (_PkiObject89) {
    function ECCCMSSharedInfo() {
      var _this148;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, ECCCMSSharedInfo);
      _this148 = _callSuper(this, ECCCMSSharedInfo);
      _this148.keyInfo = getParametersValue(parameters, KEY_INFO, ECCCMSSharedInfo.defaultValues(KEY_INFO));
      if (ENTITY_U_INFO in parameters) {
        _this148.entityUInfo = getParametersValue(parameters, ENTITY_U_INFO, ECCCMSSharedInfo.defaultValues(ENTITY_U_INFO));
      }
      _this148.suppPubInfo = getParametersValue(parameters, SUPP_PUB_INFO, ECCCMSSharedInfo.defaultValues(SUPP_PUB_INFO));
      if (parameters.schema) {
        _this148.fromSchema(parameters.schema);
      }
      return _this148;
    }
    _inherits(ECCCMSSharedInfo, _PkiObject89);
    return _createClass(ECCCMSSharedInfo, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$l);
        var asn1 = compareSchema(schema, schema, ECCCMSSharedInfo.schema({
          names: {
            keyInfo: {
              names: {
                blockName: KEY_INFO
              }
            },
            entityUInfo: ENTITY_U_INFO,
            suppPubInfo: SUPP_PUB_INFO
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.keyInfo = new AlgorithmIdentifier({
          schema: asn1.result.keyInfo
        });
        if (ENTITY_U_INFO in asn1.result) this.entityUInfo = asn1.result.entityUInfo.valueBlock.value[0];
        this.suppPubInfo = asn1.result.suppPubInfo.valueBlock.value[0];
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        outputArray.push(this.keyInfo.toSchema());
        if (this.entityUInfo) {
          outputArray.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [this.entityUInfo]
          }));
        }
        outputArray.push(new Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 2
          },
          value: [this.suppPubInfo]
        }));
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          keyInfo: this.keyInfo.toJSON(),
          suppPubInfo: this.suppPubInfo.toJSON()
        };
        if (this.entityUInfo) {
          res.entityUInfo = this.entityUInfo.toJSON();
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case KEY_INFO:
            return new AlgorithmIdentifier();
          case ENTITY_U_INFO:
            return new OctetString();
          case SUPP_PUB_INFO:
            return new OctetString();
          default:
            return _superPropGet(ECCCMSSharedInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case KEY_INFO:
          case ENTITY_U_INFO:
          case SUPP_PUB_INFO:
            return memberValue.isEqual(ECCCMSSharedInfo.defaultValues(memberName));
          default:
            return _superPropGet(ECCCMSSharedInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [AlgorithmIdentifier.schema(names.keyInfo || {}), new Constructed({
            name: names.entityUInfo || EMPTY_STRING,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            optional: true,
            value: [new OctetString()]
          }), new Constructed({
            name: names.suppPubInfo || EMPTY_STRING,
            idBlock: {
              tagClass: 3,
              tagNumber: 2
            },
            value: [new OctetString()]
          })]
        });
      }
    }]);
  }(PkiObject);
  ECCCMSSharedInfo.CLASS_NAME = "ECCCMSSharedInfo";
  var VERSION$8 = "version";
  var ORIGINATOR_INFO = "originatorInfo";
  var RECIPIENT_INFOS = "recipientInfos";
  var ENCRYPTED_CONTENT_INFO = "encryptedContentInfo";
  var UNPROTECTED_ATTRS = "unprotectedAttrs";
  var CLEAR_PROPS$k = [VERSION$8, ORIGINATOR_INFO, RECIPIENT_INFOS, ENCRYPTED_CONTENT_INFO, UNPROTECTED_ATTRS];
  var defaultEncryptionParams = {
    kdfAlgorithm: "SHA-512",
    kekEncryptionLength: 256
  };
  var curveLengthByName = {
    "P-256": 256,
    "P-384": 384,
    "P-521": 528
  };
  var EnvelopedData = function (_PkiObject90) {
    function EnvelopedData() {
      var _this149;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, EnvelopedData);
      _this149 = _callSuper(this, EnvelopedData);
      _this149.version = getParametersValue(parameters, VERSION$8, EnvelopedData.defaultValues(VERSION$8));
      if (ORIGINATOR_INFO in parameters) {
        _this149.originatorInfo = getParametersValue(parameters, ORIGINATOR_INFO, EnvelopedData.defaultValues(ORIGINATOR_INFO));
      }
      _this149.recipientInfos = getParametersValue(parameters, RECIPIENT_INFOS, EnvelopedData.defaultValues(RECIPIENT_INFOS));
      _this149.encryptedContentInfo = getParametersValue(parameters, ENCRYPTED_CONTENT_INFO, EnvelopedData.defaultValues(ENCRYPTED_CONTENT_INFO));
      if (UNPROTECTED_ATTRS in parameters) {
        _this149.unprotectedAttrs = getParametersValue(parameters, UNPROTECTED_ATTRS, EnvelopedData.defaultValues(UNPROTECTED_ATTRS));
      }
      _this149.policy = {
        disableSplit: !!parameters.disableSplit
      };
      if (parameters.schema) {
        _this149.fromSchema(parameters.schema);
      }
      return _this149;
    }
    _inherits(EnvelopedData, _PkiObject90);
    return _createClass(EnvelopedData, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$k);
        var asn1 = compareSchema(schema, schema, EnvelopedData.schema({
          names: {
            version: VERSION$8,
            originatorInfo: ORIGINATOR_INFO,
            recipientInfos: RECIPIENT_INFOS,
            encryptedContentInfo: {
              names: {
                blockName: ENCRYPTED_CONTENT_INFO
              }
            },
            unprotectedAttrs: UNPROTECTED_ATTRS
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result.version.valueBlock.valueDec;
        if (ORIGINATOR_INFO in asn1.result) {
          this.originatorInfo = new OriginatorInfo({
            schema: new Sequence({
              value: asn1.result.originatorInfo.valueBlock.value
            })
          });
        }
        this.recipientInfos = Array.from(asn1.result.recipientInfos, function (o) {
          return new RecipientInfo({
            schema: o
          });
        });
        this.encryptedContentInfo = new EncryptedContentInfo({
          schema: asn1.result.encryptedContentInfo
        });
        if (UNPROTECTED_ATTRS in asn1.result) this.unprotectedAttrs = Array.from(asn1.result.unprotectedAttrs, function (o) {
          return new Attribute({
            schema: o
          });
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        outputArray.push(new Integer({
          value: this.version
        }));
        if (this.originatorInfo) {
          outputArray.push(new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: this.originatorInfo.toSchema().valueBlock.value
          }));
        }
        outputArray.push(new Set({
          value: Array.from(this.recipientInfos, function (o) {
            return o.toSchema();
          })
        }));
        outputArray.push(this.encryptedContentInfo.toSchema());
        if (this.unprotectedAttrs) {
          outputArray.push(new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: Array.from(this.unprotectedAttrs, function (o) {
              return o.toSchema();
            })
          }));
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          version: this.version,
          recipientInfos: Array.from(this.recipientInfos, function (o) {
            return o.toJSON();
          }),
          encryptedContentInfo: this.encryptedContentInfo.toJSON()
        };
        if (this.originatorInfo) res.originatorInfo = this.originatorInfo.toJSON();
        if (this.unprotectedAttrs) res.unprotectedAttrs = Array.from(this.unprotectedAttrs, function (o) {
          return o.toJSON();
        });
        return res;
      }
    }, {
      key: "addRecipientByCertificate",
      value: function addRecipientByCertificate(certificate, parameters, variant) {
        var crypto = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : getCrypto(true);
        var encryptionParameters = Object.assign({
          useOAEP: true,
          oaepHashAlgorithm: "SHA-512"
        }, defaultEncryptionParams, parameters || {});
        if (certificate.subjectPublicKeyInfo.algorithm.algorithmId.indexOf("1.2.840.113549") !== -1) variant = 1;else {
          if (certificate.subjectPublicKeyInfo.algorithm.algorithmId.indexOf("1.2.840.10045") !== -1) variant = 2;else throw new Error("Unknown type of certificate's public key: ".concat(certificate.subjectPublicKeyInfo.algorithm.algorithmId));
        }
        switch (variant) {
          case 1:
            {
              var algorithmId;
              var algorithmParams;
              if (encryptionParameters.useOAEP === true) {
                algorithmId = crypto.getOIDByAlgorithm({
                  name: "RSA-OAEP"
                }, true, "keyEncryptionAlgorithm");
                var hashOID = crypto.getOIDByAlgorithm({
                  name: encryptionParameters.oaepHashAlgorithm
                }, true, "RSAES-OAEP-params");
                var hashAlgorithm = new AlgorithmIdentifier({
                  algorithmId: hashOID,
                  algorithmParams: new Null()
                });
                var rsaOAEPParams = new RSAESOAEPParams({
                  hashAlgorithm: hashAlgorithm,
                  maskGenAlgorithm: new AlgorithmIdentifier({
                    algorithmId: "1.2.840.113549.1.1.8",
                    algorithmParams: hashAlgorithm.toSchema()
                  })
                });
                algorithmParams = rsaOAEPParams.toSchema();
              } else {
                algorithmId = crypto.getOIDByAlgorithm({
                  name: "RSAES-PKCS1-v1_5"
                });
                if (algorithmId === EMPTY_STRING) throw new Error("Can not find OID for RSAES-PKCS1-v1_5");
                algorithmParams = new Null();
              }
              var keyInfo = new KeyTransRecipientInfo({
                version: 0,
                rid: new IssuerAndSerialNumber({
                  issuer: certificate.issuer,
                  serialNumber: certificate.serialNumber
                }),
                keyEncryptionAlgorithm: new AlgorithmIdentifier({
                  algorithmId: algorithmId,
                  algorithmParams: algorithmParams
                }),
                recipientCertificate: certificate
              });
              this.recipientInfos.push(new RecipientInfo({
                variant: 1,
                value: keyInfo
              }));
            }
            break;
          case 2:
            {
              var recipientIdentifier = new KeyAgreeRecipientIdentifier({
                variant: 1,
                value: new IssuerAndSerialNumber({
                  issuer: certificate.issuer,
                  serialNumber: certificate.serialNumber
                })
              });
              this._addKeyAgreeRecipientInfo(recipientIdentifier, encryptionParameters, {
                recipientCertificate: certificate
              }, crypto);
            }
            break;
          default:
            throw new Error("Unknown \"variant\" value: ".concat(variant));
        }
        return true;
      }
    }, {
      key: "addRecipientByPreDefinedData",
      value: function addRecipientByPreDefinedData(preDefinedData) {
        var parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var variant = arguments.length > 2 ? arguments[2] : undefined;
        var crypto = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : getCrypto(true);
        ArgumentError.assert(preDefinedData, "preDefinedData", "ArrayBuffer");
        if (!preDefinedData.byteLength) {
          throw new Error("Pre-defined data could have zero length");
        }
        if (!parameters.keyIdentifier) {
          var keyIdentifierBuffer = new ArrayBuffer(16);
          var keyIdentifierView = new Uint8Array(keyIdentifierBuffer);
          crypto.getRandomValues(keyIdentifierView);
          parameters.keyIdentifier = keyIdentifierBuffer;
        }
        if (!parameters.hmacHashAlgorithm) parameters.hmacHashAlgorithm = "SHA-512";
        if (parameters.iterationCount === undefined) {
          parameters.iterationCount = 2048;
        }
        if (!parameters.keyEncryptionAlgorithm) {
          parameters.keyEncryptionAlgorithm = {
            name: "AES-KW",
            length: 256
          };
        }
        if (!parameters.keyEncryptionAlgorithmParams) parameters.keyEncryptionAlgorithmParams = new Null();
        switch (variant) {
          case 1:
            {
              var kekOID = crypto.getOIDByAlgorithm(parameters.keyEncryptionAlgorithm, true, "keyEncryptionAlgorithm");
              var keyInfo = new KEKRecipientInfo({
                version: 4,
                kekid: new KEKIdentifier({
                  keyIdentifier: new OctetString({
                    valueHex: parameters.keyIdentifier
                  })
                }),
                keyEncryptionAlgorithm: new AlgorithmIdentifier({
                  algorithmId: kekOID,
                  algorithmParams: parameters.keyEncryptionAlgorithmParams
                }),
                preDefinedKEK: preDefinedData
              });
              this.recipientInfos.push(new RecipientInfo({
                variant: 3,
                value: keyInfo
              }));
            }
            break;
          case 2:
            {
              var pbkdf2OID = crypto.getOIDByAlgorithm({
                name: "PBKDF2"
              }, true, "keyDerivationAlgorithm");
              var saltBuffer = new ArrayBuffer(64);
              var saltView = new Uint8Array(saltBuffer);
              crypto.getRandomValues(saltView);
              var hmacOID = crypto.getOIDByAlgorithm({
                name: "HMAC",
                hash: {
                  name: parameters.hmacHashAlgorithm
                }
              }, true, "hmacHashAlgorithm");
              var pbkdf2Params = new PBKDF2Params({
                salt: new OctetString({
                  valueHex: saltBuffer
                }),
                iterationCount: parameters.iterationCount,
                prf: new AlgorithmIdentifier({
                  algorithmId: hmacOID,
                  algorithmParams: new Null()
                })
              });
              var _kekOID = crypto.getOIDByAlgorithm(parameters.keyEncryptionAlgorithm, true, "keyEncryptionAlgorithm");
              var _keyInfo = new PasswordRecipientinfo({
                version: 0,
                keyDerivationAlgorithm: new AlgorithmIdentifier({
                  algorithmId: pbkdf2OID,
                  algorithmParams: pbkdf2Params.toSchema()
                }),
                keyEncryptionAlgorithm: new AlgorithmIdentifier({
                  algorithmId: _kekOID,
                  algorithmParams: parameters.keyEncryptionAlgorithmParams
                }),
                password: preDefinedData
              });
              this.recipientInfos.push(new RecipientInfo({
                variant: 4,
                value: _keyInfo
              }));
            }
            break;
          default:
            throw new Error("Unknown value for \"variant\": ".concat(variant));
        }
      }
    }, {
      key: "addRecipientByKeyIdentifier",
      value: function addRecipientByKeyIdentifier(key, keyId, parameters) {
        var crypto = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : getCrypto(true);
        var encryptionParameters = Object.assign({}, defaultEncryptionParams, parameters || {});
        var recipientIdentifier = new KeyAgreeRecipientIdentifier({
          variant: 2,
          value: new RecipientKeyIdentifier({
            subjectKeyIdentifier: new OctetString({
              valueHex: keyId
            })
          })
        });
        this._addKeyAgreeRecipientInfo(recipientIdentifier, encryptionParameters, {
          recipientPublicKey: key
        }, crypto);
      }
    }, {
      key: "_addKeyAgreeRecipientInfo",
      value: function _addKeyAgreeRecipientInfo(recipientIdentifier, encryptionParameters, extraRecipientInfoParams) {
        var crypto = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : getCrypto(true);
        var encryptedKey = new RecipientEncryptedKey({
          rid: recipientIdentifier
        });
        var aesKWoid = crypto.getOIDByAlgorithm({
          name: "AES-KW",
          length: encryptionParameters.kekEncryptionLength
        }, true, "keyEncryptionAlgorithm");
        var aesKW = new AlgorithmIdentifier({
          algorithmId: aesKWoid
        });
        var ecdhOID = crypto.getOIDByAlgorithm({
          name: "ECDH",
          kdf: encryptionParameters.kdfAlgorithm
        }, true, "KeyAgreeRecipientInfo");
        var ukmBuffer = new ArrayBuffer(64);
        var ukmView = new Uint8Array(ukmBuffer);
        crypto.getRandomValues(ukmView);
        var recipientInfoParams = {
          version: 3,
          ukm: new OctetString({
            valueHex: ukmBuffer
          }),
          keyEncryptionAlgorithm: new AlgorithmIdentifier({
            algorithmId: ecdhOID,
            algorithmParams: aesKW.toSchema()
          }),
          recipientEncryptedKeys: new RecipientEncryptedKeys({
            encryptedKeys: [encryptedKey]
          })
        };
        var keyInfo = new KeyAgreeRecipientInfo(Object.assign(recipientInfoParams, extraRecipientInfoParams));
        this.recipientInfos.push(new RecipientInfo({
          variant: 2,
          value: keyInfo
        }));
      }
    }, {
      key: "encrypt",
      value: function () {
        var _encrypt3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee37(contentEncryptionAlgorithm, contentToEncrypt) {
          var _this150 = this;
          var crypto,
            ivBuffer,
            ivView,
            contentView,
            contentEncryptionOID,
            sessionKey,
            encryptedContent,
            exportedSessionKey,
            SubKeyAgreeRecipientInfo,
            SubKeyTransRecipientInfo,
            SubKEKRecipientInfo,
            SubPasswordRecipientinfo,
            res,
            i,
            _args37 = arguments;
          return _regeneratorRuntime().wrap(function _callee37$(_context37) {
            while (1) switch (_context37.prev = _context37.next) {
              case 0:
                crypto = _args37.length > 2 && _args37[2] !== undefined ? _args37[2] : getCrypto(true);
                ivBuffer = new ArrayBuffer(16);
                ivView = new Uint8Array(ivBuffer);
                crypto.getRandomValues(ivView);
                contentView = new Uint8Array(contentToEncrypt);
                contentEncryptionOID = crypto.getOIDByAlgorithm(contentEncryptionAlgorithm, true, "contentEncryptionAlgorithm");
                _context37.next = 8;
                return crypto.generateKey(contentEncryptionAlgorithm, true, ["encrypt"]);
              case 8:
                sessionKey = _context37.sent;
                _context37.next = 11;
                return crypto.encrypt({
                  name: contentEncryptionAlgorithm.name,
                  iv: ivView
                }, sessionKey, contentView);
              case 11:
                encryptedContent = _context37.sent;
                _context37.next = 14;
                return crypto.exportKey("raw", sessionKey);
              case 14:
                exportedSessionKey = _context37.sent;
                this.version = 2;
                this.encryptedContentInfo = new EncryptedContentInfo({
                  disableSplit: this.policy.disableSplit,
                  contentType: "1.2.840.113549.1.7.1",
                  contentEncryptionAlgorithm: new AlgorithmIdentifier({
                    algorithmId: contentEncryptionOID,
                    algorithmParams: new OctetString({
                      valueHex: ivBuffer
                    })
                  }),
                  encryptedContent: new OctetString({
                    valueHex: encryptedContent
                  })
                });
                SubKeyAgreeRecipientInfo = function () {
                  var _ref30 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee33(index) {
                    var recipientInfo, recipientCurve, recipientPublicKey, curveObject, curveOID, recipientCurveLength, ecdhKeys, exportedECDHPublicKey, derivedBits, aesKWAlgorithm, kwAlgorithm, kwLength, kwLengthBuffer, kwLengthView, j, eccInfo, encodedInfo, ecdhAlgorithm, derivedKeyRaw, awsKW, wrappedKey, originator;
                    return _regeneratorRuntime().wrap(function _callee33$(_context33) {
                      while (1) switch (_context33.prev = _context33.next) {
                        case 0:
                          recipientInfo = _this150.recipientInfos[index].value;
                          if (!recipientInfo.recipientPublicKey) {
                            _context33.next = 6;
                            break;
                          }
                          recipientCurve = recipientInfo.recipientPublicKey.algorithm.namedCurve;
                          recipientPublicKey = recipientInfo.recipientPublicKey;
                          _context33.next = 27;
                          break;
                        case 6:
                          if (!recipientInfo.recipientCertificate) {
                            _context33.next = 26;
                            break;
                          }
                          curveObject = recipientInfo.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;
                          if (!(curveObject.constructor.blockName() !== ObjectIdentifier.blockName())) {
                            _context33.next = 10;
                            break;
                          }
                          throw new Error("Incorrect \"recipientCertificate\" for index ".concat(index));
                        case 10:
                          curveOID = curveObject.valueBlock.toString();
                          _context33.t0 = curveOID;
                          _context33.next = _context33.t0 === "1.2.840.10045.3.1.7" ? 14 : _context33.t0 === "1.3.132.0.34" ? 16 : _context33.t0 === "1.3.132.0.35" ? 18 : 20;
                          break;
                        case 14:
                          recipientCurve = "P-256";
                          return _context33.abrupt("break", 21);
                        case 16:
                          recipientCurve = "P-384";
                          return _context33.abrupt("break", 21);
                        case 18:
                          recipientCurve = "P-521";
                          return _context33.abrupt("break", 21);
                        case 20:
                          throw new Error("Incorrect curve OID for index ".concat(index));
                        case 21:
                          _context33.next = 23;
                          return recipientInfo.recipientCertificate.getPublicKey({
                            algorithm: {
                              algorithm: {
                                name: "ECDH",
                                namedCurve: recipientCurve
                              },
                              usages: []
                            }
                          }, crypto);
                        case 23:
                          recipientPublicKey = _context33.sent;
                          _context33.next = 27;
                          break;
                        case 26:
                          throw new Error("Unsupported RecipientInfo");
                        case 27:
                          recipientCurveLength = curveLengthByName[recipientCurve];
                          _context33.next = 30;
                          return crypto.generateKey({
                            name: "ECDH",
                            namedCurve: recipientCurve
                          }, true, ["deriveBits"]);
                        case 30:
                          ecdhKeys = _context33.sent;
                          _context33.next = 33;
                          return crypto.exportKey("spki", ecdhKeys.publicKey);
                        case 33:
                          exportedECDHPublicKey = _context33.sent;
                          _context33.next = 36;
                          return crypto.deriveBits({
                            name: "ECDH",
                            public: recipientPublicKey
                          }, ecdhKeys.privateKey, recipientCurveLength);
                        case 36:
                          derivedBits = _context33.sent;
                          aesKWAlgorithm = new AlgorithmIdentifier({
                            schema: recipientInfo.keyEncryptionAlgorithm.algorithmParams
                          });
                          kwAlgorithm = crypto.getAlgorithmByOID(aesKWAlgorithm.algorithmId, true, "aesKWAlgorithm");
                          kwLength = kwAlgorithm.length;
                          kwLengthBuffer = new ArrayBuffer(4);
                          kwLengthView = new Uint8Array(kwLengthBuffer);
                          for (j = 3; j >= 0; j--) {
                            kwLengthView[j] = kwLength;
                            kwLength >>= 8;
                          }
                          eccInfo = new ECCCMSSharedInfo({
                            keyInfo: new AlgorithmIdentifier({
                              algorithmId: aesKWAlgorithm.algorithmId
                            }),
                            entityUInfo: recipientInfo.ukm,
                            suppPubInfo: new OctetString({
                              valueHex: kwLengthBuffer
                            })
                          });
                          encodedInfo = eccInfo.toSchema().toBER(false);
                          ecdhAlgorithm = crypto.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "ecdhAlgorithm");
                          _context33.next = 48;
                          return kdf(ecdhAlgorithm.kdf, derivedBits, kwAlgorithm.length, encodedInfo, crypto);
                        case 48:
                          derivedKeyRaw = _context33.sent;
                          _context33.next = 51;
                          return crypto.importKey("raw", derivedKeyRaw, {
                            name: "AES-KW"
                          }, true, ["wrapKey"]);
                        case 51:
                          awsKW = _context33.sent;
                          _context33.next = 54;
                          return crypto.wrapKey("raw", sessionKey, awsKW, {
                            name: "AES-KW"
                          });
                        case 54:
                          wrappedKey = _context33.sent;
                          originator = new OriginatorIdentifierOrKey();
                          originator.variant = 3;
                          originator.value = OriginatorPublicKey.fromBER(exportedECDHPublicKey);
                          recipientInfo.originator = originator;
                          recipientInfo.recipientEncryptedKeys.encryptedKeys[0].encryptedKey = new OctetString({
                            valueHex: wrappedKey
                          });
                          return _context33.abrupt("return", {
                            ecdhPrivateKey: ecdhKeys.privateKey
                          });
                        case 61:
                        case "end":
                          return _context33.stop();
                      }
                    }, _callee33);
                  }));
                  return function SubKeyAgreeRecipientInfo(_x57) {
                    return _ref30.apply(this, arguments);
                  };
                }();
                SubKeyTransRecipientInfo = function () {
                  var _ref31 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee34(index) {
                    var recipientInfo, algorithmParameters, schema, rsaOAEPParams, publicKey, encryptedKey;
                    return _regeneratorRuntime().wrap(function _callee34$(_context34) {
                      while (1) switch (_context34.prev = _context34.next) {
                        case 0:
                          recipientInfo = _this150.recipientInfos[index].value;
                          algorithmParameters = crypto.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "keyEncryptionAlgorithm");
                          if (!(algorithmParameters.name === "RSA-OAEP")) {
                            _context34.next = 8;
                            break;
                          }
                          schema = recipientInfo.keyEncryptionAlgorithm.algorithmParams;
                          rsaOAEPParams = new RSAESOAEPParams({
                            schema: schema
                          });
                          algorithmParameters.hash = crypto.getAlgorithmByOID(rsaOAEPParams.hashAlgorithm.algorithmId);
                          if (!("name" in algorithmParameters.hash === false)) {
                            _context34.next = 8;
                            break;
                          }
                          throw new Error("Incorrect OID for hash algorithm: ".concat(rsaOAEPParams.hashAlgorithm.algorithmId));
                        case 8:
                          _context34.prev = 8;
                          _context34.next = 11;
                          return recipientInfo.recipientCertificate.getPublicKey({
                            algorithm: {
                              algorithm: algorithmParameters,
                              usages: ["encrypt", "wrapKey"]
                            }
                          }, crypto);
                        case 11:
                          publicKey = _context34.sent;
                          _context34.next = 14;
                          return crypto.encrypt(publicKey.algorithm, publicKey, exportedSessionKey);
                        case 14:
                          encryptedKey = _context34.sent;
                          recipientInfo.encryptedKey = new OctetString({
                            valueHex: encryptedKey
                          });
                          _context34.next = 20;
                          break;
                        case 18:
                          _context34.prev = 18;
                          _context34.t0 = _context34["catch"](8);
                        case 20:
                        case "end":
                          return _context34.stop();
                      }
                    }, _callee34, null, [[8, 18]]);
                  }));
                  return function SubKeyTransRecipientInfo(_x58) {
                    return _ref31.apply(this, arguments);
                  };
                }();
                SubKEKRecipientInfo = function () {
                  var _ref32 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee35(index) {
                    var recipientInfo, kekAlgorithm, kekKey, wrappedKey;
                    return _regeneratorRuntime().wrap(function _callee35$(_context35) {
                      while (1) switch (_context35.prev = _context35.next) {
                        case 0:
                          recipientInfo = _this150.recipientInfos[index].value;
                          kekAlgorithm = crypto.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "kekAlgorithm");
                          _context35.next = 4;
                          return crypto.importKey("raw", new Uint8Array(recipientInfo.preDefinedKEK), kekAlgorithm, true, ["wrapKey"]);
                        case 4:
                          kekKey = _context35.sent;
                          _context35.next = 7;
                          return crypto.wrapKey("raw", sessionKey, kekKey, kekAlgorithm);
                        case 7:
                          wrappedKey = _context35.sent;
                          recipientInfo.encryptedKey = new OctetString({
                            valueHex: wrappedKey
                          });
                        case 9:
                        case "end":
                          return _context35.stop();
                      }
                    }, _callee35);
                  }));
                  return function SubKEKRecipientInfo(_x59) {
                    return _ref32.apply(this, arguments);
                  };
                }();
                SubPasswordRecipientinfo = function () {
                  var _ref33 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee36(index) {
                    var recipientInfo, pbkdf2Params, passwordView, derivationKey, kekAlgorithm, hmacHashAlgorithm, prfAlgorithm, saltView, iterations, derivedKey, wrappedKey;
                    return _regeneratorRuntime().wrap(function _callee36$(_context36) {
                      while (1) switch (_context36.prev = _context36.next) {
                        case 0:
                          recipientInfo = _this150.recipientInfos[index].value;
                          if (recipientInfo.keyDerivationAlgorithm) {
                            _context36.next = 3;
                            break;
                          }
                          throw new Error("Please append encoded \"keyDerivationAlgorithm\"");
                        case 3:
                          if (recipientInfo.keyDerivationAlgorithm.algorithmParams) {
                            _context36.next = 5;
                            break;
                          }
                          throw new Error("Incorrectly encoded \"keyDerivationAlgorithm\"");
                        case 5:
                          _context36.prev = 5;
                          pbkdf2Params = new PBKDF2Params({
                            schema: recipientInfo.keyDerivationAlgorithm.algorithmParams
                          });
                          _context36.next = 12;
                          break;
                        case 9:
                          _context36.prev = 9;
                          _context36.t0 = _context36["catch"](5);
                          throw new Error("Incorrectly encoded \"keyDerivationAlgorithm\"");
                        case 12:
                          passwordView = new Uint8Array(recipientInfo.password);
                          _context36.next = 15;
                          return crypto.importKey("raw", passwordView, "PBKDF2", false, ["deriveKey"]);
                        case 15:
                          derivationKey = _context36.sent;
                          kekAlgorithm = crypto.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "kekAlgorithm");
                          hmacHashAlgorithm = "SHA-1";
                          if (pbkdf2Params.prf) {
                            prfAlgorithm = crypto.getAlgorithmByOID(pbkdf2Params.prf.algorithmId, true, "prfAlgorithm");
                            hmacHashAlgorithm = prfAlgorithm.hash.name;
                          }
                          saltView = new Uint8Array(pbkdf2Params.salt.valueBlock.valueHex);
                          iterations = pbkdf2Params.iterationCount;
                          _context36.next = 23;
                          return crypto.deriveKey({
                            name: "PBKDF2",
                            hash: {
                              name: hmacHashAlgorithm
                            },
                            salt: saltView,
                            iterations: iterations
                          }, derivationKey, kekAlgorithm, true, ["wrapKey"]);
                        case 23:
                          derivedKey = _context36.sent;
                          _context36.next = 26;
                          return crypto.wrapKey("raw", sessionKey, derivedKey, kekAlgorithm);
                        case 26:
                          wrappedKey = _context36.sent;
                          recipientInfo.encryptedKey = new OctetString({
                            valueHex: wrappedKey
                          });
                        case 28:
                        case "end":
                          return _context36.stop();
                      }
                    }, _callee36, null, [[5, 9]]);
                  }));
                  return function SubPasswordRecipientinfo(_x60) {
                    return _ref33.apply(this, arguments);
                  };
                }();
                res = [];
                i = 0;
              case 23:
                if (!(i < this.recipientInfos.length)) {
                  _context37.next = 55;
                  break;
                }
                _context37.t0 = this.recipientInfos[i].variant;
                _context37.next = _context37.t0 === 1 ? 27 : _context37.t0 === 2 ? 33 : _context37.t0 === 3 ? 39 : _context37.t0 === 4 ? 45 : 51;
                break;
              case 27:
                _context37.t1 = res;
                _context37.next = 30;
                return SubKeyTransRecipientInfo(i);
              case 30:
                _context37.t2 = _context37.sent;
                _context37.t1.push.call(_context37.t1, _context37.t2);
                return _context37.abrupt("break", 52);
              case 33:
                _context37.t3 = res;
                _context37.next = 36;
                return SubKeyAgreeRecipientInfo(i);
              case 36:
                _context37.t4 = _context37.sent;
                _context37.t3.push.call(_context37.t3, _context37.t4);
                return _context37.abrupt("break", 52);
              case 39:
                _context37.t5 = res;
                _context37.next = 42;
                return SubKEKRecipientInfo(i);
              case 42:
                _context37.t6 = _context37.sent;
                _context37.t5.push.call(_context37.t5, _context37.t6);
                return _context37.abrupt("break", 52);
              case 45:
                _context37.t7 = res;
                _context37.next = 48;
                return SubPasswordRecipientinfo(i);
              case 48:
                _context37.t8 = _context37.sent;
                _context37.t7.push.call(_context37.t7, _context37.t8);
                return _context37.abrupt("break", 52);
              case 51:
                throw new Error("Unknown recipient type in array with index ".concat(i));
              case 52:
                i++;
                _context37.next = 23;
                break;
              case 55:
                return _context37.abrupt("return", res);
              case 56:
              case "end":
                return _context37.stop();
            }
          }, _callee37, this);
        }));
        function encrypt(_x55, _x56) {
          return _encrypt3.apply(this, arguments);
        }
        return encrypt;
      }()
    }, {
      key: "decrypt",
      value: function () {
        var _decrypt3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee45(recipientIndex, parameters) {
          var _this151 = this;
          var crypto,
            decryptionParameters,
            SubKeyAgreeRecipientInfo,
            SubKeyTransRecipientInfo,
            SubKEKRecipientInfo,
            SubPasswordRecipientinfo,
            unwrappedKey,
            algorithmId,
            contentEncryptionAlgorithm,
            ivBuffer,
            ivView,
            dataBuffer,
            _args45 = arguments;
          return _regeneratorRuntime().wrap(function _callee45$(_context45) {
            while (1) switch (_context45.prev = _context45.next) {
              case 0:
                crypto = _args45.length > 2 && _args45[2] !== undefined ? _args45[2] : getCrypto(true);
                decryptionParameters = parameters || {};
                if (!(recipientIndex + 1 > this.recipientInfos.length)) {
                  _context45.next = 4;
                  break;
                }
                throw new Error("Maximum value for \"index\" is: ".concat(this.recipientInfos.length - 1));
              case 4:
                SubKeyAgreeRecipientInfo = function () {
                  var _ref34 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee41(index) {
                    var recipientInfo, curveOID, recipientCurve, recipientCurveLength, originator, curveObject, _curveObject, ecdhPrivateKey, keyCrypto, buffer, ecdhPublicKey, sharedSecret, applyKDF, _applyKDF, kdfResult, importAesKwKey, aesKwKey, unwrapSessionKey, _kdfResult, _aesKwKey;
                    return _regeneratorRuntime().wrap(function _callee41$(_context41) {
                      while (1) switch (_context41.prev = _context41.next) {
                        case 0:
                          _applyKDF = function _applyKDF3() {
                            _applyKDF = _asyncToGenerator(_regeneratorRuntime().mark(function _callee40(includeAlgorithmParams) {
                              var aesKWAlgorithm, kwAlgorithm, kwLength, kwLengthBuffer, kwLengthView, j, keyInfoAlgorithm, eccInfo, encodedInfo, ecdhAlgorithm;
                              return _regeneratorRuntime().wrap(function _callee40$(_context40) {
                                while (1) switch (_context40.prev = _context40.next) {
                                  case 0:
                                    includeAlgorithmParams = includeAlgorithmParams || false;
                                    aesKWAlgorithm = new AlgorithmIdentifier({
                                      schema: recipientInfo.keyEncryptionAlgorithm.algorithmParams
                                    });
                                    kwAlgorithm = crypto.getAlgorithmByOID(aesKWAlgorithm.algorithmId, true, "kwAlgorithm");
                                    kwLength = kwAlgorithm.length;
                                    kwLengthBuffer = new ArrayBuffer(4);
                                    kwLengthView = new Uint8Array(kwLengthBuffer);
                                    for (j = 3; j >= 0; j--) {
                                      kwLengthView[j] = kwLength;
                                      kwLength >>= 8;
                                    }
                                    keyInfoAlgorithm = {
                                      algorithmId: aesKWAlgorithm.algorithmId
                                    };
                                    if (includeAlgorithmParams) {
                                      keyInfoAlgorithm.algorithmParams = new Null();
                                    }
                                    eccInfo = new ECCCMSSharedInfo({
                                      keyInfo: new AlgorithmIdentifier(keyInfoAlgorithm),
                                      entityUInfo: recipientInfo.ukm,
                                      suppPubInfo: new OctetString({
                                        valueHex: kwLengthBuffer
                                      })
                                    });
                                    encodedInfo = eccInfo.toSchema().toBER(false);
                                    ecdhAlgorithm = crypto.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "ecdhAlgorithm");
                                    if (ecdhAlgorithm.name) {
                                      _context40.next = 14;
                                      break;
                                    }
                                    throw new Error("Incorrect OID for key encryption algorithm: ".concat(recipientInfo.keyEncryptionAlgorithm.algorithmId));
                                  case 14:
                                    return _context40.abrupt("return", kdf(ecdhAlgorithm.kdf, sharedSecret, kwAlgorithm.length, encodedInfo, crypto));
                                  case 15:
                                  case "end":
                                    return _context40.stop();
                                }
                              }, _callee40);
                            }));
                            return _applyKDF.apply(this, arguments);
                          };
                          applyKDF = function _applyKDF2(_x64) {
                            return _applyKDF.apply(this, arguments);
                          };
                          recipientInfo = _this151.recipientInfos[index].value;
                          originator = recipientInfo.originator;
                          if (!decryptionParameters.recipientCertificate) {
                            _context41.next = 11;
                            break;
                          }
                          curveObject = decryptionParameters.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;
                          if (!(curveObject.constructor.blockName() !== ObjectIdentifier.blockName())) {
                            _context41.next = 8;
                            break;
                          }
                          throw new Error("Incorrect \"recipientCertificate\" for index ".concat(index));
                        case 8:
                          curveOID = curveObject.valueBlock.toString();
                          _context41.next = 19;
                          break;
                        case 11:
                          if (!originator.value.algorithm.algorithmParams) {
                            _context41.next = 18;
                            break;
                          }
                          _curveObject = originator.value.algorithm.algorithmParams;
                          if (!(_curveObject.constructor.blockName() !== ObjectIdentifier.blockName())) {
                            _context41.next = 15;
                            break;
                          }
                          throw new Error("Incorrect originator for index ".concat(index));
                        case 15:
                          curveOID = _curveObject.valueBlock.toString();
                          _context41.next = 19;
                          break;
                        case 18:
                          throw new Error("Parameter \"recipientCertificate\" is mandatory for \"KeyAgreeRecipientInfo\" if algorithm params are missing from originator");
                        case 19:
                          if (decryptionParameters.recipientPrivateKey) {
                            _context41.next = 21;
                            break;
                          }
                          throw new Error("Parameter \"recipientPrivateKey\" is mandatory for \"KeyAgreeRecipientInfo\"");
                        case 21:
                          _context41.t0 = curveOID;
                          _context41.next = _context41.t0 === "1.2.840.10045.3.1.7" ? 24 : _context41.t0 === "1.3.132.0.34" ? 27 : _context41.t0 === "1.3.132.0.35" ? 30 : 33;
                          break;
                        case 24:
                          recipientCurve = "P-256";
                          recipientCurveLength = 256;
                          return _context41.abrupt("break", 34);
                        case 27:
                          recipientCurve = "P-384";
                          recipientCurveLength = 384;
                          return _context41.abrupt("break", 34);
                        case 30:
                          recipientCurve = "P-521";
                          recipientCurveLength = 528;
                          return _context41.abrupt("break", 34);
                        case 33:
                          throw new Error("Incorrect curve OID for index ".concat(index));
                        case 34:
                          keyCrypto = crypto;
                          if (!BufferSourceConverter.isBufferSource(decryptionParameters.recipientPrivateKey)) {
                            _context41.next = 41;
                            break;
                          }
                          _context41.next = 38;
                          return crypto.importKey("pkcs8", decryptionParameters.recipientPrivateKey, {
                            name: "ECDH",
                            namedCurve: recipientCurve
                          }, true, ["deriveBits"]);
                        case 38:
                          ecdhPrivateKey = _context41.sent;
                          _context41.next = 43;
                          break;
                        case 41:
                          ecdhPrivateKey = decryptionParameters.recipientPrivateKey;
                          if ("crypto" in decryptionParameters && decryptionParameters.crypto) {
                            keyCrypto = decryptionParameters.crypto.subtle;
                          }
                        case 43:
                          if ("algorithmParams" in originator.value.algorithm === false) originator.value.algorithm.algorithmParams = new ObjectIdentifier({
                            value: curveOID
                          });
                          buffer = originator.value.toSchema().toBER(false);
                          _context41.next = 47;
                          return crypto.importKey("spki", buffer, {
                            name: "ECDH",
                            namedCurve: recipientCurve
                          }, true, []);
                        case 47:
                          ecdhPublicKey = _context41.sent;
                          _context41.next = 50;
                          return keyCrypto.deriveBits({
                            name: "ECDH",
                            public: ecdhPublicKey
                          }, ecdhPrivateKey, recipientCurveLength);
                        case 50:
                          sharedSecret = _context41.sent;
                          _context41.next = 53;
                          return applyKDF();
                        case 53:
                          kdfResult = _context41.sent;
                          importAesKwKey = function () {
                            var _ref35 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee38(kdfResult) {
                              return _regeneratorRuntime().wrap(function _callee38$(_context38) {
                                while (1) switch (_context38.prev = _context38.next) {
                                  case 0:
                                    return _context38.abrupt("return", crypto.importKey("raw", kdfResult, {
                                      name: "AES-KW"
                                    }, true, ["unwrapKey"]));
                                  case 1:
                                  case "end":
                                    return _context38.stop();
                                }
                              }, _callee38);
                            }));
                            return function importAesKwKey(_x65) {
                              return _ref35.apply(this, arguments);
                            };
                          }();
                          _context41.next = 57;
                          return importAesKwKey(kdfResult);
                        case 57:
                          aesKwKey = _context41.sent;
                          unwrapSessionKey = function () {
                            var _ref36 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee39(aesKwKey) {
                              var algorithmId, contentEncryptionAlgorithm;
                              return _regeneratorRuntime().wrap(function _callee39$(_context39) {
                                while (1) switch (_context39.prev = _context39.next) {
                                  case 0:
                                    algorithmId = _this151.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId;
                                    contentEncryptionAlgorithm = crypto.getAlgorithmByOID(algorithmId, true, "contentEncryptionAlgorithm");
                                    return _context39.abrupt("return", crypto.unwrapKey("raw", recipientInfo.recipientEncryptedKeys.encryptedKeys[0].encryptedKey.valueBlock.valueHexView, aesKwKey, {
                                      name: "AES-KW"
                                    }, contentEncryptionAlgorithm, true, ["decrypt"]));
                                  case 3:
                                  case "end":
                                    return _context39.stop();
                                }
                              }, _callee39);
                            }));
                            return function unwrapSessionKey(_x66) {
                              return _ref36.apply(this, arguments);
                            };
                          }();
                          _context41.prev = 59;
                          _context41.next = 62;
                          return unwrapSessionKey(aesKwKey);
                        case 62:
                          return _context41.abrupt("return", _context41.sent);
                        case 65:
                          _context41.prev = 65;
                          _context41.t1 = _context41["catch"](59);
                          _context41.next = 69;
                          return applyKDF(true);
                        case 69:
                          _kdfResult = _context41.sent;
                          _context41.next = 72;
                          return importAesKwKey(_kdfResult);
                        case 72:
                          _aesKwKey = _context41.sent;
                          return _context41.abrupt("return", unwrapSessionKey(_aesKwKey));
                        case 74:
                        case "end":
                          return _context41.stop();
                      }
                    }, _callee41, null, [[59, 65]]);
                  }));
                  return function SubKeyAgreeRecipientInfo(_x63) {
                    return _ref34.apply(this, arguments);
                  };
                }();
                SubKeyTransRecipientInfo = function () {
                  var _ref37 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee42(index) {
                    var recipientInfo, algorithmParameters, schema, rsaOAEPParams, privateKey, keyCrypto, sessionKey, algorithmId, contentEncryptionAlgorithm;
                    return _regeneratorRuntime().wrap(function _callee42$(_context42) {
                      while (1) switch (_context42.prev = _context42.next) {
                        case 0:
                          recipientInfo = _this151.recipientInfos[index].value;
                          if (decryptionParameters.recipientPrivateKey) {
                            _context42.next = 3;
                            break;
                          }
                          throw new Error("Parameter \"recipientPrivateKey\" is mandatory for \"KeyTransRecipientInfo\"");
                        case 3:
                          algorithmParameters = crypto.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "keyEncryptionAlgorithm");
                          if (!(algorithmParameters.name === "RSA-OAEP")) {
                            _context42.next = 10;
                            break;
                          }
                          schema = recipientInfo.keyEncryptionAlgorithm.algorithmParams;
                          rsaOAEPParams = new RSAESOAEPParams({
                            schema: schema
                          });
                          algorithmParameters.hash = crypto.getAlgorithmByOID(rsaOAEPParams.hashAlgorithm.algorithmId);
                          if (!("name" in algorithmParameters.hash === false)) {
                            _context42.next = 10;
                            break;
                          }
                          throw new Error("Incorrect OID for hash algorithm: ".concat(rsaOAEPParams.hashAlgorithm.algorithmId));
                        case 10:
                          keyCrypto = crypto;
                          if (!BufferSourceConverter.isBufferSource(decryptionParameters.recipientPrivateKey)) {
                            _context42.next = 17;
                            break;
                          }
                          _context42.next = 14;
                          return crypto.importKey("pkcs8", decryptionParameters.recipientPrivateKey, algorithmParameters, true, ["decrypt"]);
                        case 14:
                          privateKey = _context42.sent;
                          _context42.next = 19;
                          break;
                        case 17:
                          privateKey = decryptionParameters.recipientPrivateKey;
                          if ("crypto" in decryptionParameters && decryptionParameters.crypto) {
                            keyCrypto = decryptionParameters.crypto.subtle;
                          }
                        case 19:
                          _context42.next = 21;
                          return keyCrypto.decrypt(privateKey.algorithm, privateKey, recipientInfo.encryptedKey.valueBlock.valueHexView);
                        case 21:
                          sessionKey = _context42.sent;
                          algorithmId = _this151.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId;
                          contentEncryptionAlgorithm = crypto.getAlgorithmByOID(algorithmId, true, "contentEncryptionAlgorithm");
                          if (!("name" in contentEncryptionAlgorithm === false)) {
                            _context42.next = 26;
                            break;
                          }
                          throw new Error("Incorrect \"contentEncryptionAlgorithm\": ".concat(algorithmId));
                        case 26:
                          return _context42.abrupt("return", crypto.importKey("raw", sessionKey, contentEncryptionAlgorithm, true, ["decrypt"]));
                        case 27:
                        case "end":
                          return _context42.stop();
                      }
                    }, _callee42);
                  }));
                  return function SubKeyTransRecipientInfo(_x67) {
                    return _ref37.apply(this, arguments);
                  };
                }();
                SubKEKRecipientInfo = function () {
                  var _ref38 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee43(index) {
                    var recipientInfo, kekAlgorithm, importedKey, algorithmId, contentEncryptionAlgorithm;
                    return _regeneratorRuntime().wrap(function _callee43$(_context43) {
                      while (1) switch (_context43.prev = _context43.next) {
                        case 0:
                          recipientInfo = _this151.recipientInfos[index].value;
                          if (decryptionParameters.preDefinedData) {
                            _context43.next = 3;
                            break;
                          }
                          throw new Error("Parameter \"preDefinedData\" is mandatory for \"KEKRecipientInfo\"");
                        case 3:
                          kekAlgorithm = crypto.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "kekAlgorithm");
                          _context43.next = 6;
                          return crypto.importKey("raw", decryptionParameters.preDefinedData, kekAlgorithm, true, ["unwrapKey"]);
                        case 6:
                          importedKey = _context43.sent;
                          algorithmId = _this151.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId;
                          contentEncryptionAlgorithm = crypto.getAlgorithmByOID(algorithmId, true, "contentEncryptionAlgorithm");
                          if (contentEncryptionAlgorithm.name) {
                            _context43.next = 11;
                            break;
                          }
                          throw new Error("Incorrect \"contentEncryptionAlgorithm\": ".concat(algorithmId));
                        case 11:
                          return _context43.abrupt("return", crypto.unwrapKey("raw", recipientInfo.encryptedKey.valueBlock.valueHexView, importedKey, kekAlgorithm, contentEncryptionAlgorithm, true, ["decrypt"]));
                        case 12:
                        case "end":
                          return _context43.stop();
                      }
                    }, _callee43);
                  }));
                  return function SubKEKRecipientInfo(_x68) {
                    return _ref38.apply(this, arguments);
                  };
                }();
                SubPasswordRecipientinfo = function () {
                  var _ref39 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee44(index) {
                    var recipientInfo, pbkdf2Params, pbkdf2Key, kekAlgorithm, hmacHashAlgorithm, saltView, iterations, kekKey, algorithmId, contentEncryptionAlgorithm;
                    return _regeneratorRuntime().wrap(function _callee44$(_context44) {
                      while (1) switch (_context44.prev = _context44.next) {
                        case 0:
                          recipientInfo = _this151.recipientInfos[index].value;
                          if (decryptionParameters.preDefinedData) {
                            _context44.next = 3;
                            break;
                          }
                          throw new Error("Parameter \"preDefinedData\" is mandatory for \"KEKRecipientInfo\"");
                        case 3:
                          if (recipientInfo.keyDerivationAlgorithm) {
                            _context44.next = 5;
                            break;
                          }
                          throw new Error("Please append encoded \"keyDerivationAlgorithm\"");
                        case 5:
                          if (recipientInfo.keyDerivationAlgorithm.algorithmParams) {
                            _context44.next = 7;
                            break;
                          }
                          throw new Error("Incorrectly encoded \"keyDerivationAlgorithm\"");
                        case 7:
                          _context44.prev = 7;
                          pbkdf2Params = new PBKDF2Params({
                            schema: recipientInfo.keyDerivationAlgorithm.algorithmParams
                          });
                          _context44.next = 14;
                          break;
                        case 11:
                          _context44.prev = 11;
                          _context44.t0 = _context44["catch"](7);
                          throw new Error("Incorrectly encoded \"keyDerivationAlgorithm\"");
                        case 14:
                          _context44.next = 16;
                          return crypto.importKey("raw", decryptionParameters.preDefinedData, "PBKDF2", false, ["deriveKey"]);
                        case 16:
                          pbkdf2Key = _context44.sent;
                          kekAlgorithm = crypto.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "keyEncryptionAlgorithm");
                          hmacHashAlgorithm = pbkdf2Params.prf ? crypto.getAlgorithmByOID(pbkdf2Params.prf.algorithmId, true, "prfAlgorithm").hash.name : "SHA-1";
                          saltView = new Uint8Array(pbkdf2Params.salt.valueBlock.valueHex);
                          iterations = pbkdf2Params.iterationCount;
                          _context44.next = 23;
                          return crypto.deriveKey({
                            name: "PBKDF2",
                            hash: {
                              name: hmacHashAlgorithm
                            },
                            salt: saltView,
                            iterations: iterations
                          }, pbkdf2Key, kekAlgorithm, true, ["unwrapKey"]);
                        case 23:
                          kekKey = _context44.sent;
                          algorithmId = _this151.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId;
                          contentEncryptionAlgorithm = crypto.getAlgorithmByOID(algorithmId, true, "contentEncryptionAlgorithm");
                          return _context44.abrupt("return", crypto.unwrapKey("raw", recipientInfo.encryptedKey.valueBlock.valueHexView, kekKey, kekAlgorithm, contentEncryptionAlgorithm, true, ["decrypt"]));
                        case 27:
                        case "end":
                          return _context44.stop();
                      }
                    }, _callee44, null, [[7, 11]]);
                  }));
                  return function SubPasswordRecipientinfo(_x69) {
                    return _ref39.apply(this, arguments);
                  };
                }();
                _context45.t0 = this.recipientInfos[recipientIndex].variant;
                _context45.next = _context45.t0 === 1 ? 11 : _context45.t0 === 2 ? 15 : _context45.t0 === 3 ? 19 : _context45.t0 === 4 ? 23 : 27;
                break;
              case 11:
                _context45.next = 13;
                return SubKeyTransRecipientInfo(recipientIndex);
              case 13:
                unwrappedKey = _context45.sent;
                return _context45.abrupt("break", 28);
              case 15:
                _context45.next = 17;
                return SubKeyAgreeRecipientInfo(recipientIndex);
              case 17:
                unwrappedKey = _context45.sent;
                return _context45.abrupt("break", 28);
              case 19:
                _context45.next = 21;
                return SubKEKRecipientInfo(recipientIndex);
              case 21:
                unwrappedKey = _context45.sent;
                return _context45.abrupt("break", 28);
              case 23:
                _context45.next = 25;
                return SubPasswordRecipientinfo(recipientIndex);
              case 25:
                unwrappedKey = _context45.sent;
                return _context45.abrupt("break", 28);
              case 27:
                throw new Error("Unknown recipient type in array with index ".concat(recipientIndex));
              case 28:
                algorithmId = this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId;
                contentEncryptionAlgorithm = crypto.getAlgorithmByOID(algorithmId, true, "contentEncryptionAlgorithm");
                ivBuffer = this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams.valueBlock.valueHex;
                ivView = new Uint8Array(ivBuffer);
                if (this.encryptedContentInfo.encryptedContent) {
                  _context45.next = 34;
                  break;
                }
                throw new Error("Required property `encryptedContent` is empty");
              case 34:
                dataBuffer = this.encryptedContentInfo.getEncryptedContent();
                return _context45.abrupt("return", crypto.decrypt({
                  name: contentEncryptionAlgorithm.name,
                  iv: ivView
                }, unwrappedKey, dataBuffer));
              case 36:
              case "end":
                return _context45.stop();
            }
          }, _callee45, this);
        }));
        function decrypt(_x61, _x62) {
          return _decrypt3.apply(this, arguments);
        }
        return decrypt;
      }()
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case VERSION$8:
            return 0;
          case ORIGINATOR_INFO:
            return new OriginatorInfo();
          case RECIPIENT_INFOS:
            return [];
          case ENCRYPTED_CONTENT_INFO:
            return new EncryptedContentInfo();
          case UNPROTECTED_ATTRS:
            return [];
          default:
            return _superPropGet(EnvelopedData, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VERSION$8:
            return memberValue === EnvelopedData.defaultValues(memberName);
          case ORIGINATOR_INFO:
            return memberValue.certs.certificates.length === 0 && memberValue.crls.crls.length === 0;
          case RECIPIENT_INFOS:
          case UNPROTECTED_ATTRS:
            return memberValue.length === 0;
          case ENCRYPTED_CONTENT_INFO:
            return EncryptedContentInfo.compareWithDefault("contentType", memberValue.contentType) && EncryptedContentInfo.compareWithDefault("contentEncryptionAlgorithm", memberValue.contentEncryptionAlgorithm) && EncryptedContentInfo.compareWithDefault("encryptedContent", memberValue.encryptedContent);
          default:
            return _superPropGet(EnvelopedData, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Integer({
            name: names.version || EMPTY_STRING
          }), new Constructed({
            name: names.originatorInfo || EMPTY_STRING,
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: OriginatorInfo.schema().valueBlock.value
          }), new Set({
            value: [new Repeated({
              name: names.recipientInfos || EMPTY_STRING,
              value: RecipientInfo.schema()
            })]
          }), EncryptedContentInfo.schema(names.encryptedContentInfo || {}), new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: [new Repeated({
              name: names.unprotectedAttrs || EMPTY_STRING,
              value: Attribute.schema()
            })]
          })]
        });
      }
    }]);
  }(PkiObject);
  EnvelopedData.CLASS_NAME = "EnvelopedData";
  var SAFE_CONTENTS = "safeContents";
  var PARSED_VALUE$1 = "parsedValue";
  var CONTENT_INFOS = "contentInfos";
  var AuthenticatedSafe = function (_PkiObject91) {
    function AuthenticatedSafe() {
      var _this152;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, AuthenticatedSafe);
      _this152 = _callSuper(this, AuthenticatedSafe);
      _this152.safeContents = getParametersValue(parameters, SAFE_CONTENTS, AuthenticatedSafe.defaultValues(SAFE_CONTENTS));
      if (PARSED_VALUE$1 in parameters) {
        _this152.parsedValue = getParametersValue(parameters, PARSED_VALUE$1, AuthenticatedSafe.defaultValues(PARSED_VALUE$1));
      }
      if (parameters.schema) {
        _this152.fromSchema(parameters.schema);
      }
      return _this152;
    }
    _inherits(AuthenticatedSafe, _PkiObject91);
    return _createClass(AuthenticatedSafe, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, [CONTENT_INFOS]);
        var asn1 = compareSchema(schema, schema, AuthenticatedSafe.schema({
          names: {
            contentInfos: CONTENT_INFOS
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.safeContents = Array.from(asn1.result.contentInfos, function (element) {
          return new ContentInfo({
            schema: element
          });
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: Array.from(this.safeContents, function (o) {
            return o.toSchema();
          })
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          safeContents: Array.from(this.safeContents, function (o) {
            return o.toJSON();
          })
        };
      }
    }, {
      key: "parseInternalValues",
      value: function () {
        var _parseInternalValues2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee46(parameters) {
          var crypto,
            _iterator24,
            _step24,
            _step24$value,
            index,
            content,
            safeContent,
            errorTarget,
            authSafeContent,
            cmsEnveloped,
            envelopedData,
            recipientCertificate,
            recipientKey,
            decrypted,
            cmsEncrypted,
            password,
            _decrypted,
            _args46 = arguments;
          return _regeneratorRuntime().wrap(function _callee46$(_context46) {
            while (1) switch (_context46.prev = _context46.next) {
              case 0:
                crypto = _args46.length > 1 && _args46[1] !== undefined ? _args46[1] : getCrypto(true);
                ParameterError.assert(parameters, SAFE_CONTENTS);
                ArgumentError.assert(parameters.safeContents, SAFE_CONTENTS, "Array");
                if (!(parameters.safeContents.length !== this.safeContents.length)) {
                  _context46.next = 5;
                  break;
                }
                throw new ArgumentError("Length of \"parameters.safeContents\" must be equal to \"this.safeContents.length\"");
              case 5:
                this.parsedValue = {
                  safeContents: []
                };
                _iterator24 = _createForOfIteratorHelper(this.safeContents.entries());
                _context46.prev = 7;
                _iterator24.s();
              case 9:
                if ((_step24 = _iterator24.n()).done) {
                  _context46.next = 41;
                  break;
                }
                _step24$value = _slicedToArray(_step24.value, 2), index = _step24$value[0], content = _step24$value[1];
                safeContent = parameters.safeContents[index];
                errorTarget = "parameters.safeContents[".concat(index, "]");
                _context46.t0 = content.contentType;
                _context46.next = _context46.t0 === id_ContentType_Data ? 16 : _context46.t0 === id_ContentType_EnvelopedData ? 20 : _context46.t0 === id_ContentType_EncryptedData ? 30 : 38;
                break;
              case 16:
                ArgumentError.assert(content.content, "this.safeContents[j].content", OctetString);
                authSafeContent = content.content.getValue();
                this.parsedValue.safeContents.push({
                  privacyMode: 0,
                  value: SafeContents.fromBER(authSafeContent)
                });
                return _context46.abrupt("break", 39);
              case 20:
                cmsEnveloped = new EnvelopedData({
                  schema: content.content
                });
                ParameterError.assert(errorTarget, safeContent, "recipientCertificate", "recipientKey");
                envelopedData = safeContent;
                recipientCertificate = envelopedData.recipientCertificate;
                recipientKey = envelopedData.recipientKey;
                _context46.next = 27;
                return cmsEnveloped.decrypt(0, {
                  recipientCertificate: recipientCertificate,
                  recipientPrivateKey: recipientKey
                }, crypto);
              case 27:
                decrypted = _context46.sent;
                this.parsedValue.safeContents.push({
                  privacyMode: 2,
                  value: SafeContents.fromBER(decrypted)
                });
                return _context46.abrupt("break", 39);
              case 30:
                cmsEncrypted = new EncryptedData({
                  schema: content.content
                });
                ParameterError.assert(errorTarget, safeContent, "password");
                password = safeContent.password;
                _context46.next = 35;
                return cmsEncrypted.decrypt({
                  password: password
                }, crypto);
              case 35:
                _decrypted = _context46.sent;
                this.parsedValue.safeContents.push({
                  privacyMode: 1,
                  value: SafeContents.fromBER(_decrypted)
                });
                return _context46.abrupt("break", 39);
              case 38:
                throw new Error("Unknown \"contentType\" for AuthenticatedSafe: \" ".concat(content.contentType));
              case 39:
                _context46.next = 9;
                break;
              case 41:
                _context46.next = 46;
                break;
              case 43:
                _context46.prev = 43;
                _context46.t1 = _context46["catch"](7);
                _iterator24.e(_context46.t1);
              case 46:
                _context46.prev = 46;
                _iterator24.f();
                return _context46.finish(46);
              case 49:
              case "end":
                return _context46.stop();
            }
          }, _callee46, this, [[7, 43, 46, 49]]);
        }));
        function parseInternalValues(_x70) {
          return _parseInternalValues2.apply(this, arguments);
        }
        return parseInternalValues;
      }()
    }, {
      key: "makeInternalValues",
      value: function () {
        var _makeInternalValues2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee47(parameters) {
          var crypto,
            _iterator25,
            _step25,
            _step25$value,
            index,
            content,
            contentBuffer,
            cmsEncrypted,
            currentParameters,
            cmsEnveloped,
            contentToEncrypt,
            safeContent,
            encryptionAlgorithm,
            _args47 = arguments;
          return _regeneratorRuntime().wrap(function _callee47$(_context47) {
            while (1) switch (_context47.prev = _context47.next) {
              case 0:
                crypto = _args47.length > 1 && _args47[1] !== undefined ? _args47[1] : getCrypto(true);
                if (this.parsedValue) {
                  _context47.next = 3;
                  break;
                }
                throw new Error("Please run \"parseValues\" first or add \"parsedValue\" manually");
              case 3:
                ArgumentError.assert(this.parsedValue, "this.parsedValue", "object");
                ArgumentError.assert(this.parsedValue.safeContents, "this.parsedValue.safeContents", "Array");
                ArgumentError.assert(parameters, "parameters", "object");
                ParameterError.assert(parameters, "safeContents");
                ArgumentError.assert(parameters.safeContents, "parameters.safeContents", "Array");
                if (!(parameters.safeContents.length !== this.parsedValue.safeContents.length)) {
                  _context47.next = 10;
                  break;
                }
                throw new ArgumentError("Length of \"parameters.safeContents\" must be equal to \"this.parsedValue.safeContents\"");
              case 10:
                this.safeContents = [];
                _iterator25 = _createForOfIteratorHelper(this.parsedValue.safeContents.entries());
                _context47.prev = 12;
                _iterator25.s();
              case 14:
                if ((_step25 = _iterator25.n()).done) {
                  _context47.next = 54;
                  break;
                }
                _step25$value = _slicedToArray(_step25.value, 2), index = _step25$value[0], content = _step25$value[1];
                ParameterError.assert("content", content, "privacyMode", "value");
                ArgumentError.assert(content.value, "content.value", SafeContents);
                _context47.t0 = content.privacyMode;
                _context47.next = _context47.t0 === 0 ? 21 : _context47.t0 === 1 ? 24 : _context47.t0 === 2 ? 31 : 51;
                break;
              case 21:
                contentBuffer = content.value.toSchema().toBER(false);
                this.safeContents.push(new ContentInfo({
                  contentType: "1.2.840.113549.1.7.1",
                  content: new OctetString({
                    valueHex: contentBuffer
                  })
                }));
                return _context47.abrupt("break", 52);
              case 24:
                cmsEncrypted = new EncryptedData();
                currentParameters = parameters.safeContents[index];
                currentParameters.contentToEncrypt = content.value.toSchema().toBER(false);
                _context47.next = 29;
                return cmsEncrypted.encrypt(currentParameters, crypto);
              case 29:
                this.safeContents.push(new ContentInfo({
                  contentType: "1.2.840.113549.1.7.6",
                  content: cmsEncrypted.toSchema()
                }));
                return _context47.abrupt("break", 52);
              case 31:
                cmsEnveloped = new EnvelopedData();
                contentToEncrypt = content.value.toSchema().toBER(false);
                safeContent = parameters.safeContents[index];
                ParameterError.assert("parameters.safeContents[".concat(index, "]"), safeContent, "encryptingCertificate", "encryptionAlgorithm");
                _context47.t1 = true;
                _context47.next = _context47.t1 === (safeContent.encryptionAlgorithm.name.toLowerCase() === "aes-cbc") ? 38 : _context47.t1 === (safeContent.encryptionAlgorithm.name.toLowerCase() === "aes-gcm") ? 38 : 39;
                break;
              case 38:
                return _context47.abrupt("break", 40);
              case 39:
                throw new Error("Incorrect parameter \"encryptionAlgorithm\" in \"parameters.safeContents[i]\": ".concat(safeContent.encryptionAlgorithm));
              case 40:
                _context47.t2 = true;
                _context47.next = _context47.t2 === (safeContent.encryptionAlgorithm.length === 128) ? 43 : _context47.t2 === (safeContent.encryptionAlgorithm.length === 192) ? 43 : _context47.t2 === (safeContent.encryptionAlgorithm.length === 256) ? 43 : 44;
                break;
              case 43:
                return _context47.abrupt("break", 45);
              case 44:
                throw new Error("Incorrect parameter \"encryptionAlgorithm.length\" in \"parameters.safeContents[i]\": ".concat(safeContent.encryptionAlgorithm.length));
              case 45:
                encryptionAlgorithm = safeContent.encryptionAlgorithm;
                cmsEnveloped.addRecipientByCertificate(safeContent.encryptingCertificate, {}, undefined, crypto);
                _context47.next = 49;
                return cmsEnveloped.encrypt(encryptionAlgorithm, contentToEncrypt, crypto);
              case 49:
                this.safeContents.push(new ContentInfo({
                  contentType: "1.2.840.113549.1.7.3",
                  content: cmsEnveloped.toSchema()
                }));
                return _context47.abrupt("break", 52);
              case 51:
                throw new Error("Incorrect value for \"content.privacyMode\": ".concat(content.privacyMode));
              case 52:
                _context47.next = 14;
                break;
              case 54:
                _context47.next = 59;
                break;
              case 56:
                _context47.prev = 56;
                _context47.t3 = _context47["catch"](12);
                _iterator25.e(_context47.t3);
              case 59:
                _context47.prev = 59;
                _iterator25.f();
                return _context47.finish(59);
              case 62:
                return _context47.abrupt("return", this);
              case 63:
              case "end":
                return _context47.stop();
            }
          }, _callee47, this, [[12, 56, 59, 62]]);
        }));
        function makeInternalValues(_x71) {
          return _makeInternalValues2.apply(this, arguments);
        }
        return makeInternalValues;
      }()
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case SAFE_CONTENTS:
            return [];
          case PARSED_VALUE$1:
            return {};
          default:
            return _superPropGet(AuthenticatedSafe, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case SAFE_CONTENTS:
            return memberValue.length === 0;
          case PARSED_VALUE$1:
            return memberValue instanceof Object && Object.keys(memberValue).length === 0;
          default:
            return _superPropGet(AuthenticatedSafe, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Repeated({
            name: names.contentInfos || EMPTY_STRING,
            value: ContentInfo.schema()
          })]
        });
      }
    }]);
  }(PkiObject);
  AuthenticatedSafe.CLASS_NAME = "AuthenticatedSafe";
  var HASH_ALGORITHM$1 = "hashAlgorithm";
  var ISSUER_NAME_HASH = "issuerNameHash";
  var ISSUER_KEY_HASH = "issuerKeyHash";
  var SERIAL_NUMBER$1 = "serialNumber";
  var CLEAR_PROPS$j = [HASH_ALGORITHM$1, ISSUER_NAME_HASH, ISSUER_KEY_HASH, SERIAL_NUMBER$1];
  var CertID = function (_PkiObject92) {
    function CertID() {
      var _this153;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, CertID);
      _this153 = _callSuper(this, CertID);
      _this153.hashAlgorithm = getParametersValue(parameters, HASH_ALGORITHM$1, CertID.defaultValues(HASH_ALGORITHM$1));
      _this153.issuerNameHash = getParametersValue(parameters, ISSUER_NAME_HASH, CertID.defaultValues(ISSUER_NAME_HASH));
      _this153.issuerKeyHash = getParametersValue(parameters, ISSUER_KEY_HASH, CertID.defaultValues(ISSUER_KEY_HASH));
      _this153.serialNumber = getParametersValue(parameters, SERIAL_NUMBER$1, CertID.defaultValues(SERIAL_NUMBER$1));
      if (parameters.schema) {
        _this153.fromSchema(parameters.schema);
      }
      return _this153;
    }
    _inherits(CertID, _PkiObject92);
    return _createClass(CertID, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$j);
        var asn1 = compareSchema(schema, schema, CertID.schema({
          names: {
            hashAlgorithm: HASH_ALGORITHM$1,
            issuerNameHash: ISSUER_NAME_HASH,
            issuerKeyHash: ISSUER_KEY_HASH,
            serialNumber: SERIAL_NUMBER$1
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.hashAlgorithm = new AlgorithmIdentifier({
          schema: asn1.result.hashAlgorithm
        });
        this.issuerNameHash = asn1.result.issuerNameHash;
        this.issuerKeyHash = asn1.result.issuerKeyHash;
        this.serialNumber = asn1.result.serialNumber;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: [this.hashAlgorithm.toSchema(), this.issuerNameHash, this.issuerKeyHash, this.serialNumber]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          hashAlgorithm: this.hashAlgorithm.toJSON(),
          issuerNameHash: this.issuerNameHash.toJSON(),
          issuerKeyHash: this.issuerKeyHash.toJSON(),
          serialNumber: this.serialNumber.toJSON()
        };
      }
    }, {
      key: "isEqual",
      value: function isEqual(certificateID) {
        if (this.hashAlgorithm.algorithmId !== certificateID.hashAlgorithm.algorithmId) {
          return false;
        }
        if (!BufferSourceConverter.isEqual(this.issuerNameHash.valueBlock.valueHexView, certificateID.issuerNameHash.valueBlock.valueHexView)) {
          return false;
        }
        if (!BufferSourceConverter.isEqual(this.issuerKeyHash.valueBlock.valueHexView, certificateID.issuerKeyHash.valueBlock.valueHexView)) {
          return false;
        }
        if (!this.serialNumber.isEqual(certificateID.serialNumber)) {
          return false;
        }
        return true;
      }
    }, {
      key: "createForCertificate",
      value: function () {
        var _createForCertificate = _asyncToGenerator(_regeneratorRuntime().mark(function _callee48(certificate, parameters) {
          var crypto,
            hashOID,
            issuerCertificate,
            hashIssuerName,
            issuerKeyBuffer,
            hashIssuerKey,
            _args48 = arguments;
          return _regeneratorRuntime().wrap(function _callee48$(_context48) {
            while (1) switch (_context48.prev = _context48.next) {
              case 0:
                crypto = _args48.length > 2 && _args48[2] !== undefined ? _args48[2] : getCrypto(true);
                ParameterError.assert(parameters, HASH_ALGORITHM$1, "issuerCertificate");
                hashOID = crypto.getOIDByAlgorithm({
                  name: parameters.hashAlgorithm
                }, true, "hashAlgorithm");
                this.hashAlgorithm = new AlgorithmIdentifier({
                  algorithmId: hashOID,
                  algorithmParams: new Null()
                });
                issuerCertificate = parameters.issuerCertificate;
                this.serialNumber = certificate.serialNumber;
                _context48.next = 8;
                return crypto.digest({
                  name: parameters.hashAlgorithm
                }, issuerCertificate.subject.toSchema().toBER(false));
              case 8:
                hashIssuerName = _context48.sent;
                this.issuerNameHash = new OctetString({
                  valueHex: hashIssuerName
                });
                issuerKeyBuffer = issuerCertificate.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView;
                _context48.next = 13;
                return crypto.digest({
                  name: parameters.hashAlgorithm
                }, issuerKeyBuffer);
              case 13:
                hashIssuerKey = _context48.sent;
                this.issuerKeyHash = new OctetString({
                  valueHex: hashIssuerKey
                });
              case 15:
              case "end":
                return _context48.stop();
            }
          }, _callee48, this);
        }));
        function createForCertificate(_x72, _x73) {
          return _createForCertificate.apply(this, arguments);
        }
        return createForCertificate;
      }()
    }], [{
      key: "create",
      value: function () {
        var _create = _asyncToGenerator(_regeneratorRuntime().mark(function _callee49(certificate, parameters) {
          var crypto,
            certID,
            _args49 = arguments;
          return _regeneratorRuntime().wrap(function _callee49$(_context49) {
            while (1) switch (_context49.prev = _context49.next) {
              case 0:
                crypto = _args49.length > 2 && _args49[2] !== undefined ? _args49[2] : getCrypto(true);
                certID = new CertID();
                _context49.next = 4;
                return certID.createForCertificate(certificate, parameters, crypto);
              case 4:
                return _context49.abrupt("return", certID);
              case 5:
              case "end":
                return _context49.stop();
            }
          }, _callee49);
        }));
        function create(_x74, _x75) {
          return _create.apply(this, arguments);
        }
        return create;
      }()
    }, {
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case HASH_ALGORITHM$1:
            return new AlgorithmIdentifier();
          case ISSUER_NAME_HASH:
          case ISSUER_KEY_HASH:
            return new OctetString();
          case SERIAL_NUMBER$1:
            return new Integer();
          default:
            return _superPropGet(CertID, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case HASH_ALGORITHM$1:
            return memberValue.algorithmId === EMPTY_STRING && "algorithmParams" in memberValue === false;
          case ISSUER_NAME_HASH:
          case ISSUER_KEY_HASH:
          case SERIAL_NUMBER$1:
            return memberValue.isEqual(CertID.defaultValues(SERIAL_NUMBER$1));
          default:
            return _superPropGet(CertID, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [AlgorithmIdentifier.schema(names.hashAlgorithmObject || {
            names: {
              blockName: names.hashAlgorithm || EMPTY_STRING
            }
          }), new OctetString({
            name: names.issuerNameHash || EMPTY_STRING
          }), new OctetString({
            name: names.issuerKeyHash || EMPTY_STRING
          }), new Integer({
            name: names.serialNumber || EMPTY_STRING
          })]
        });
      }
    }]);
  }(PkiObject);
  CertID.CLASS_NAME = "CertID";
  var CERT_ID = "certID";
  var CERT_STATUS = "certStatus";
  var THIS_UPDATE = "thisUpdate";
  var NEXT_UPDATE = "nextUpdate";
  var SINGLE_EXTENSIONS = "singleExtensions";
  var CLEAR_PROPS$i = [CERT_ID, CERT_STATUS, THIS_UPDATE, NEXT_UPDATE, SINGLE_EXTENSIONS];
  var SingleResponse = function (_PkiObject93) {
    function SingleResponse() {
      var _this154;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, SingleResponse);
      _this154 = _callSuper(this, SingleResponse);
      _this154.certID = getParametersValue(parameters, CERT_ID, SingleResponse.defaultValues(CERT_ID));
      _this154.certStatus = getParametersValue(parameters, CERT_STATUS, SingleResponse.defaultValues(CERT_STATUS));
      _this154.thisUpdate = getParametersValue(parameters, THIS_UPDATE, SingleResponse.defaultValues(THIS_UPDATE));
      if (NEXT_UPDATE in parameters) {
        _this154.nextUpdate = getParametersValue(parameters, NEXT_UPDATE, SingleResponse.defaultValues(NEXT_UPDATE));
      }
      if (SINGLE_EXTENSIONS in parameters) {
        _this154.singleExtensions = getParametersValue(parameters, SINGLE_EXTENSIONS, SingleResponse.defaultValues(SINGLE_EXTENSIONS));
      }
      if (parameters.schema) {
        _this154.fromSchema(parameters.schema);
      }
      return _this154;
    }
    _inherits(SingleResponse, _PkiObject93);
    return _createClass(SingleResponse, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$i);
        var asn1 = compareSchema(schema, schema, SingleResponse.schema({
          names: {
            certID: {
              names: {
                blockName: CERT_ID
              }
            },
            certStatus: CERT_STATUS,
            thisUpdate: THIS_UPDATE,
            nextUpdate: NEXT_UPDATE,
            singleExtensions: {
              names: {
                blockName: SINGLE_EXTENSIONS
              }
            }
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.certID = new CertID({
          schema: asn1.result.certID
        });
        this.certStatus = asn1.result.certStatus;
        this.thisUpdate = asn1.result.thisUpdate.toDate();
        if (NEXT_UPDATE in asn1.result) this.nextUpdate = asn1.result.nextUpdate.toDate();
        if (SINGLE_EXTENSIONS in asn1.result) this.singleExtensions = Array.from(asn1.result.singleExtensions.valueBlock.value, function (element) {
          return new Extension({
            schema: element
          });
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        outputArray.push(this.certID.toSchema());
        outputArray.push(this.certStatus);
        outputArray.push(new GeneralizedTime({
          valueDate: this.thisUpdate
        }));
        if (this.nextUpdate) {
          outputArray.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [new GeneralizedTime({
              valueDate: this.nextUpdate
            })]
          }));
        }
        if (this.singleExtensions) {
          outputArray.push(new Sequence({
            value: Array.from(this.singleExtensions, function (o) {
              return o.toSchema();
            })
          }));
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          certID: this.certID.toJSON(),
          certStatus: this.certStatus.toJSON(),
          thisUpdate: this.thisUpdate
        };
        if (this.nextUpdate) {
          res.nextUpdate = this.nextUpdate;
        }
        if (this.singleExtensions) {
          res.singleExtensions = Array.from(this.singleExtensions, function (o) {
            return o.toJSON();
          });
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case CERT_ID:
            return new CertID();
          case CERT_STATUS:
            return {};
          case THIS_UPDATE:
          case NEXT_UPDATE:
            return new Date(0, 0, 0);
          case SINGLE_EXTENSIONS:
            return [];
          default:
            return _superPropGet(SingleResponse, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case CERT_ID:
            return CertID.compareWithDefault("hashAlgorithm", memberValue.hashAlgorithm) && CertID.compareWithDefault("issuerNameHash", memberValue.issuerNameHash) && CertID.compareWithDefault("issuerKeyHash", memberValue.issuerKeyHash) && CertID.compareWithDefault("serialNumber", memberValue.serialNumber);
          case CERT_STATUS:
            return Object.keys(memberValue).length === 0;
          case THIS_UPDATE:
          case NEXT_UPDATE:
            return memberValue === SingleResponse.defaultValues(memberName);
          default:
            return _superPropGet(SingleResponse, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [CertID.schema(names.certID || {}), new Choice({
            value: [new Primitive({
              name: names.certStatus || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              }
            }), new Constructed({
              name: names.certStatus || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: [new GeneralizedTime(), new Constructed({
                optional: true,
                idBlock: {
                  tagClass: 3,
                  tagNumber: 0
                },
                value: [new Enumerated()]
              })]
            }), new Primitive({
              name: names.certStatus || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 2
              },
              lenBlock: {
                length: 1
              }
            })]
          }), new GeneralizedTime({
            name: names.thisUpdate || EMPTY_STRING
          }), new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [new GeneralizedTime({
              name: names.nextUpdate || EMPTY_STRING
            })]
          }), new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: [Extensions.schema(names.singleExtensions || {})]
          })]
        });
      }
    }]);
  }(PkiObject);
  SingleResponse.CLASS_NAME = "SingleResponse";
  var TBS$2 = "tbs";
  var VERSION$7 = "version";
  var RESPONDER_ID = "responderID";
  var PRODUCED_AT = "producedAt";
  var RESPONSES = "responses";
  var RESPONSE_EXTENSIONS = "responseExtensions";
  var RESPONSE_DATA = "ResponseData";
  var RESPONSE_DATA_VERSION = "".concat(RESPONSE_DATA, ".").concat(VERSION$7);
  var RESPONSE_DATA_RESPONDER_ID = "".concat(RESPONSE_DATA, ".").concat(RESPONDER_ID);
  var RESPONSE_DATA_PRODUCED_AT = "".concat(RESPONSE_DATA, ".").concat(PRODUCED_AT);
  var RESPONSE_DATA_RESPONSES = "".concat(RESPONSE_DATA, ".").concat(RESPONSES);
  var RESPONSE_DATA_RESPONSE_EXTENSIONS = "".concat(RESPONSE_DATA, ".").concat(RESPONSE_EXTENSIONS);
  var CLEAR_PROPS$h = [RESPONSE_DATA, RESPONSE_DATA_VERSION, RESPONSE_DATA_RESPONDER_ID, RESPONSE_DATA_PRODUCED_AT, RESPONSE_DATA_RESPONSES, RESPONSE_DATA_RESPONSE_EXTENSIONS];
  var ResponseData = function (_PkiObject94) {
    function ResponseData() {
      var _this155;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, ResponseData);
      _this155 = _callSuper(this, ResponseData);
      _this155.tbsView = new Uint8Array(getParametersValue(parameters, TBS$2, ResponseData.defaultValues(TBS$2)));
      if (VERSION$7 in parameters) {
        _this155.version = getParametersValue(parameters, VERSION$7, ResponseData.defaultValues(VERSION$7));
      }
      _this155.responderID = getParametersValue(parameters, RESPONDER_ID, ResponseData.defaultValues(RESPONDER_ID));
      _this155.producedAt = getParametersValue(parameters, PRODUCED_AT, ResponseData.defaultValues(PRODUCED_AT));
      _this155.responses = getParametersValue(parameters, RESPONSES, ResponseData.defaultValues(RESPONSES));
      if (RESPONSE_EXTENSIONS in parameters) {
        _this155.responseExtensions = getParametersValue(parameters, RESPONSE_EXTENSIONS, ResponseData.defaultValues(RESPONSE_EXTENSIONS));
      }
      if (parameters.schema) {
        _this155.fromSchema(parameters.schema);
      }
      return _this155;
    }
    _inherits(ResponseData, _PkiObject94);
    return _createClass(ResponseData, [{
      key: "tbs",
      get: function get() {
        return BufferSourceConverter.toArrayBuffer(this.tbsView);
      },
      set: function set(value) {
        this.tbsView = new Uint8Array(value);
      }
    }, {
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$h);
        var asn1 = compareSchema(schema, schema, ResponseData.schema());
        AsnError.assertSchema(asn1, this.className);
        this.tbsView = asn1.result.ResponseData.valueBeforeDecodeView;
        if (RESPONSE_DATA_VERSION in asn1.result) this.version = asn1.result[RESPONSE_DATA_VERSION].valueBlock.valueDec;
        if (asn1.result[RESPONSE_DATA_RESPONDER_ID].idBlock.tagNumber === 1) this.responderID = new RelativeDistinguishedNames({
          schema: asn1.result[RESPONSE_DATA_RESPONDER_ID].valueBlock.value[0]
        });else this.responderID = asn1.result[RESPONSE_DATA_RESPONDER_ID].valueBlock.value[0];
        this.producedAt = asn1.result[RESPONSE_DATA_PRODUCED_AT].toDate();
        this.responses = Array.from(asn1.result[RESPONSE_DATA_RESPONSES], function (element) {
          return new SingleResponse({
            schema: element
          });
        });
        if (RESPONSE_DATA_RESPONSE_EXTENSIONS in asn1.result) this.responseExtensions = Array.from(asn1.result[RESPONSE_DATA_RESPONSE_EXTENSIONS].valueBlock.value, function (element) {
          return new Extension({
            schema: element
          });
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var encodeFlag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var tbsSchema;
        if (encodeFlag === false) {
          if (!this.tbsView.byteLength) {
            return ResponseData.schema();
          }
          var asn1 = _fromBER(this.tbsView);
          AsnError.assert(asn1, "TBS Response Data");
          tbsSchema = asn1.result;
        } else {
          var outputArray = [];
          if (VERSION$7 in this) {
            outputArray.push(new Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [new Integer({
                value: this.version
              })]
            }));
          }
          if (this.responderID instanceof RelativeDistinguishedNames) {
            outputArray.push(new Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: [this.responderID.toSchema()]
            }));
          } else {
            outputArray.push(new Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 2
              },
              value: [this.responderID]
            }));
          }
          outputArray.push(new GeneralizedTime({
            valueDate: this.producedAt
          }));
          outputArray.push(new Sequence({
            value: Array.from(this.responses, function (o) {
              return o.toSchema();
            })
          }));
          if (this.responseExtensions) {
            outputArray.push(new Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: [new Sequence({
                value: Array.from(this.responseExtensions, function (o) {
                  return o.toSchema();
                })
              })]
            }));
          }
          tbsSchema = new Sequence({
            value: outputArray
          });
        }
        return tbsSchema;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {};
        if (VERSION$7 in this) {
          res.version = this.version;
        }
        if (this.responderID) {
          res.responderID = this.responderID;
        }
        if (this.producedAt) {
          res.producedAt = this.producedAt;
        }
        if (this.responses) {
          res.responses = Array.from(this.responses, function (o) {
            return o.toJSON();
          });
        }
        if (this.responseExtensions) {
          res.responseExtensions = Array.from(this.responseExtensions, function (o) {
            return o.toJSON();
          });
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case VERSION$7:
            return 0;
          case TBS$2:
            return EMPTY_BUFFER;
          case RESPONDER_ID:
            return {};
          case PRODUCED_AT:
            return new Date(0, 0, 0);
          case RESPONSES:
          case RESPONSE_EXTENSIONS:
            return [];
          default:
            return _superPropGet(ResponseData, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case TBS$2:
            return memberValue.byteLength === 0;
          case RESPONDER_ID:
            return Object.keys(memberValue).length === 0;
          case PRODUCED_AT:
            return memberValue === ResponseData.defaultValues(memberName);
          case RESPONSES:
          case RESPONSE_EXTENSIONS:
            return memberValue.length === 0;
          default:
            return _superPropGet(ResponseData, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || RESPONSE_DATA,
          value: [new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [new Integer({
              name: names.version || RESPONSE_DATA_VERSION
            })]
          }), new Choice({
            value: [new Constructed({
              name: names.responderID || RESPONSE_DATA_RESPONDER_ID,
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: [RelativeDistinguishedNames.schema(names.ResponseDataByName || {
                names: {
                  blockName: "ResponseData.byName"
                }
              })]
            }), new Constructed({
              name: names.responderID || RESPONSE_DATA_RESPONDER_ID,
              idBlock: {
                tagClass: 3,
                tagNumber: 2
              },
              value: [new OctetString({
                name: names.ResponseDataByKey || "ResponseData.byKey"
              })]
            })]
          }), new GeneralizedTime({
            name: names.producedAt || RESPONSE_DATA_PRODUCED_AT
          }), new Sequence({
            value: [new Repeated({
              name: RESPONSE_DATA_RESPONSES,
              value: SingleResponse.schema(names.response || {})
            })]
          }), new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: [Extensions.schema(names.extensions || {
              names: {
                blockName: RESPONSE_DATA_RESPONSE_EXTENSIONS
              }
            })]
          })]
        });
      }
    }]);
  }(PkiObject);
  ResponseData.CLASS_NAME = "ResponseData";
  var TRUSTED_CERTS = "trustedCerts";
  var CERTS$2 = "certs";
  var CRLS$1 = "crls";
  var OCSPS$1 = "ocsps";
  var CHECK_DATE = "checkDate";
  var FIND_ORIGIN = "findOrigin";
  var FIND_ISSUER = "findIssuer";
  var ChainValidationCode;
  (function (ChainValidationCode) {
    ChainValidationCode[ChainValidationCode["unknown"] = -1] = "unknown";
    ChainValidationCode[ChainValidationCode["success"] = 0] = "success";
    ChainValidationCode[ChainValidationCode["noRevocation"] = 11] = "noRevocation";
    ChainValidationCode[ChainValidationCode["noPath"] = 60] = "noPath";
    ChainValidationCode[ChainValidationCode["noValidPath"] = 97] = "noValidPath";
  })(ChainValidationCode || (ChainValidationCode = {}));
  var ChainValidationError = function (_Error2) {
    function ChainValidationError(code, message) {
      var _this156;
      _classCallCheck(this, ChainValidationError);
      _this156 = _callSuper(this, ChainValidationError, [message]);
      _this156.name = ChainValidationError.NAME;
      _this156.code = code;
      _this156.message = message;
      return _this156;
    }
    _inherits(ChainValidationError, _Error2);
    return _createClass(ChainValidationError);
  }(_wrapNativeSuper(Error));
  ChainValidationError.NAME = "ChainValidationError";
  function isTrusted(cert, trustedList) {
    for (var i = 0; i < trustedList.length; i++) {
      if (BufferSourceConverter.isEqual(cert.tbsView, trustedList[i].tbsView)) {
        return true;
      }
    }
    return false;
  }
  var CertificateChainValidationEngine = function () {
    function CertificateChainValidationEngine() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, CertificateChainValidationEngine);
      this.trustedCerts = getParametersValue(parameters, TRUSTED_CERTS, this.defaultValues(TRUSTED_CERTS));
      this.certs = getParametersValue(parameters, CERTS$2, this.defaultValues(CERTS$2));
      this.crls = getParametersValue(parameters, CRLS$1, this.defaultValues(CRLS$1));
      this.ocsps = getParametersValue(parameters, OCSPS$1, this.defaultValues(OCSPS$1));
      this.checkDate = getParametersValue(parameters, CHECK_DATE, this.defaultValues(CHECK_DATE));
      this.findOrigin = getParametersValue(parameters, FIND_ORIGIN, this.defaultValues(FIND_ORIGIN));
      this.findIssuer = getParametersValue(parameters, FIND_ISSUER, this.defaultValues(FIND_ISSUER));
    }
    return _createClass(CertificateChainValidationEngine, [{
      key: "defaultFindIssuer",
      value: function () {
        var _defaultFindIssuer = _asyncToGenerator(_regeneratorRuntime().mark(function _callee50(certificate, validationEngine) {
          var crypto,
            result,
            keyIdentifier,
            authorityCertIssuer,
            authorityCertSerialNumber,
            verificationResult,
            _iterator26,
            _step26,
            extension,
            checkCertificate,
            _iterator28,
            _step28,
            trustedCert,
            _iterator29,
            _step29,
            intermediateCert,
            i,
            _verificationResult,
            _args50 = arguments;
          return _regeneratorRuntime().wrap(function _callee50$(_context50) {
            while (1) switch (_context50.prev = _context50.next) {
              case 0:
                checkCertificate = function _checkCertificate(possibleIssuer) {
                  if (keyIdentifier !== null) {
                    if (possibleIssuer.extensions) {
                      var extensionFound = false;
                      var _iterator27 = _createForOfIteratorHelper(possibleIssuer.extensions),
                        _step27;
                      try {
                        for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {
                          var _extension = _step27.value;
                          if (_extension.extnID === id_SubjectKeyIdentifier && _extension.parsedValue) {
                            extensionFound = true;
                            if (BufferSourceConverter.isEqual(_extension.parsedValue.valueBlock.valueHex, keyIdentifier.valueBlock.valueHexView)) {
                              result.push(possibleIssuer);
                            }
                            break;
                          }
                        }
                      } catch (err) {
                        _iterator27.e(err);
                      } finally {
                        _iterator27.f();
                      }
                      if (extensionFound) {
                        return;
                      }
                    }
                  }
                  var authorityCertSerialNumberEqual = false;
                  if (authorityCertSerialNumber !== null) authorityCertSerialNumberEqual = possibleIssuer.serialNumber.isEqual(authorityCertSerialNumber);
                  if (authorityCertIssuer !== null) {
                    if (possibleIssuer.subject.isEqual(authorityCertIssuer)) {
                      if (authorityCertSerialNumberEqual) result.push(possibleIssuer);
                    }
                  } else {
                    if (certificate.issuer.isEqual(possibleIssuer.subject)) result.push(possibleIssuer);
                  }
                };
                crypto = _args50.length > 2 && _args50[2] !== undefined ? _args50[2] : getCrypto(true);
                result = [];
                keyIdentifier = null;
                authorityCertIssuer = null;
                authorityCertSerialNumber = null;
                if (!certificate.subject.isEqual(certificate.issuer)) {
                  _context50.next = 17;
                  break;
                }
                _context50.prev = 7;
                _context50.next = 10;
                return certificate.verify(undefined, crypto);
              case 10:
                verificationResult = _context50.sent;
                if (!verificationResult) {
                  _context50.next = 13;
                  break;
                }
                return _context50.abrupt("return", [certificate]);
              case 13:
                _context50.next = 17;
                break;
              case 15:
                _context50.prev = 15;
                _context50.t0 = _context50["catch"](7);
              case 17:
                if (!certificate.extensions) {
                  _context50.next = 36;
                  break;
                }
                _iterator26 = _createForOfIteratorHelper(certificate.extensions);
                _context50.prev = 19;
                _iterator26.s();
              case 21:
                if ((_step26 = _iterator26.n()).done) {
                  _context50.next = 28;
                  break;
                }
                extension = _step26.value;
                if (!(extension.extnID === id_AuthorityKeyIdentifier && extension.parsedValue instanceof AuthorityKeyIdentifier)) {
                  _context50.next = 26;
                  break;
                }
                if (extension.parsedValue.keyIdentifier) {
                  keyIdentifier = extension.parsedValue.keyIdentifier;
                } else {
                  if (extension.parsedValue.authorityCertIssuer) {
                    authorityCertIssuer = extension.parsedValue.authorityCertIssuer;
                  }
                  if (extension.parsedValue.authorityCertSerialNumber) {
                    authorityCertSerialNumber = extension.parsedValue.authorityCertSerialNumber;
                  }
                }
                return _context50.abrupt("break", 28);
              case 26:
                _context50.next = 21;
                break;
              case 28:
                _context50.next = 33;
                break;
              case 30:
                _context50.prev = 30;
                _context50.t1 = _context50["catch"](19);
                _iterator26.e(_context50.t1);
              case 33:
                _context50.prev = 33;
                _iterator26.f();
                return _context50.finish(33);
              case 36:
                _iterator28 = _createForOfIteratorHelper(validationEngine.trustedCerts);
                try {
                  for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {
                    trustedCert = _step28.value;
                    checkCertificate(trustedCert);
                  }
                } catch (err) {
                  _iterator28.e(err);
                } finally {
                  _iterator28.f();
                }
                _iterator29 = _createForOfIteratorHelper(validationEngine.certs);
                try {
                  for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {
                    intermediateCert = _step29.value;
                    checkCertificate(intermediateCert);
                  }
                } catch (err) {
                  _iterator29.e(err);
                } finally {
                  _iterator29.f();
                }
                i = result.length - 1;
              case 41:
                if (!(i >= 0)) {
                  _context50.next = 55;
                  break;
                }
                _context50.prev = 42;
                _context50.next = 45;
                return certificate.verify(result[i], crypto);
              case 45:
                _verificationResult = _context50.sent;
                if (_verificationResult === false) result.splice(i, 1);
                _context50.next = 52;
                break;
              case 49:
                _context50.prev = 49;
                _context50.t2 = _context50["catch"](42);
                result.splice(i, 1);
              case 52:
                i--;
                _context50.next = 41;
                break;
              case 55:
                return _context50.abrupt("return", result);
              case 56:
              case "end":
                return _context50.stop();
            }
          }, _callee50, null, [[7, 15], [19, 30, 33, 36], [42, 49]]);
        }));
        function defaultFindIssuer(_x76, _x77) {
          return _defaultFindIssuer.apply(this, arguments);
        }
        return defaultFindIssuer;
      }()
    }, {
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case TRUSTED_CERTS:
            return [];
          case CERTS$2:
            return [];
          case CRLS$1:
            return [];
          case OCSPS$1:
            return [];
          case CHECK_DATE:
            return new Date();
          case FIND_ORIGIN:
            return CertificateChainValidationEngine.defaultFindOrigin;
          case FIND_ISSUER:
            return this.defaultFindIssuer;
          default:
            throw new Error("Invalid member name for CertificateChainValidationEngine class: ".concat(memberName));
        }
      }
    }, {
      key: "sort",
      value: function () {
        var _sort = _asyncToGenerator(_regeneratorRuntime().mark(function _callee56() {
          var _this157 = this;
          var passedWhenNotRevValues,
            crypto,
            localCerts,
            _buildPath,
            findCRL,
            findOCSP,
            checkForCA,
            _checkForCA,
            basicCheck,
            i,
            j,
            leafCert,
            result,
            certificatePath,
            _i33,
            found,
            _j,
            certificate,
            k,
            shortestLength,
            shortestIndex,
            _i34,
            _i35,
            _args56 = arguments;
          return _regeneratorRuntime().wrap(function _callee56$(_context56) {
            while (1) switch (_context56.prev = _context56.next) {
              case 0:
                _checkForCA = function _checkForCA3() {
                  _checkForCA = _asyncToGenerator(_regeneratorRuntime().mark(function _callee55(certificate) {
                    var needToCheckCRL,
                      isCA,
                      mustBeCA,
                      keyUsagePresent,
                      cRLSign,
                      _j2,
                      extension,
                      view,
                      _args55 = arguments;
                    return _regeneratorRuntime().wrap(function _callee55$(_context55) {
                      while (1) switch (_context55.prev = _context55.next) {
                        case 0:
                          needToCheckCRL = _args55.length > 1 && _args55[1] !== undefined ? _args55[1] : false;
                          isCA = false;
                          mustBeCA = false;
                          keyUsagePresent = false;
                          cRLSign = false;
                          if (!certificate.extensions) {
                            _context55.next = 22;
                            break;
                          }
                          _j2 = 0;
                        case 7:
                          if (!(_j2 < certificate.extensions.length)) {
                            _context55.next = 16;
                            break;
                          }
                          extension = certificate.extensions[_j2];
                          if (!(extension.critical && !extension.parsedValue)) {
                            _context55.next = 11;
                            break;
                          }
                          return _context55.abrupt("return", {
                            result: false,
                            resultCode: 6,
                            resultMessage: "Unable to parse critical certificate extension: ".concat(extension.extnID)
                          });
                        case 11:
                          if (extension.extnID === id_KeyUsage) {
                            keyUsagePresent = true;
                            view = new Uint8Array(extension.parsedValue.valueBlock.valueHex);
                            if ((view[0] & 0x04) === 0x04) mustBeCA = true;
                            if ((view[0] & 0x02) === 0x02) cRLSign = true;
                          }
                          if (extension.extnID === id_BasicConstraints) {
                            if ("cA" in extension.parsedValue) {
                              if (extension.parsedValue.cA === true) isCA = true;
                            }
                          }
                        case 13:
                          _j2++;
                          _context55.next = 7;
                          break;
                        case 16:
                          if (!(mustBeCA === true && isCA === false)) {
                            _context55.next = 18;
                            break;
                          }
                          return _context55.abrupt("return", {
                            result: false,
                            resultCode: 3,
                            resultMessage: "Unable to build certificate chain - using \"keyCertSign\" flag set without BasicConstraints"
                          });
                        case 18:
                          if (!(keyUsagePresent === true && isCA === true && mustBeCA === false)) {
                            _context55.next = 20;
                            break;
                          }
                          return _context55.abrupt("return", {
                            result: false,
                            resultCode: 4,
                            resultMessage: "Unable to build certificate chain - \"keyCertSign\" flag was not set"
                          });
                        case 20:
                          if (!(isCA === true && keyUsagePresent === true && needToCheckCRL && cRLSign === false)) {
                            _context55.next = 22;
                            break;
                          }
                          return _context55.abrupt("return", {
                            result: false,
                            resultCode: 5,
                            resultMessage: "Unable to build certificate chain - intermediate certificate must have \"cRLSign\" key usage flag"
                          });
                        case 22:
                          if (!(isCA === false)) {
                            _context55.next = 24;
                            break;
                          }
                          return _context55.abrupt("return", {
                            result: false,
                            resultCode: 7,
                            resultMessage: "Unable to build certificate chain - more than one possible end-user certificate"
                          });
                        case 24:
                          return _context55.abrupt("return", {
                            result: true,
                            resultCode: 0,
                            resultMessage: EMPTY_STRING
                          });
                        case 25:
                        case "end":
                          return _context55.stop();
                      }
                    }, _callee55);
                  }));
                  return _checkForCA.apply(this, arguments);
                };
                checkForCA = function _checkForCA2(_x83) {
                  return _checkForCA.apply(this, arguments);
                };
                passedWhenNotRevValues = _args56.length > 0 && _args56[0] !== undefined ? _args56[0] : false;
                crypto = _args56.length > 1 && _args56[1] !== undefined ? _args56[1] : getCrypto(true);
                localCerts = [];
                _buildPath = function () {
                  var _ref40 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee51(certificate, crypto) {
                    var result, checkUnique, findIssuerResult, i, buildPathResult, j, copy;
                    return _regeneratorRuntime().wrap(function _callee51$(_context51) {
                      while (1) switch (_context51.prev = _context51.next) {
                        case 0:
                          checkUnique = function _checkUnique(array) {
                            var unique = true;
                            for (var i = 0; i < array.length; i++) {
                              for (var j = 0; j < array.length; j++) {
                                if (j === i) continue;
                                if (array[i] === array[j]) {
                                  unique = false;
                                  break;
                                }
                              }
                              if (!unique) break;
                            }
                            return unique;
                          };
                          result = [];
                          if (!isTrusted(certificate, _this157.trustedCerts)) {
                            _context51.next = 4;
                            break;
                          }
                          return _context51.abrupt("return", [[certificate]]);
                        case 4:
                          _context51.next = 6;
                          return _this157.findIssuer(certificate, _this157, crypto);
                        case 6:
                          findIssuerResult = _context51.sent;
                          if (!(findIssuerResult.length === 0)) {
                            _context51.next = 9;
                            break;
                          }
                          throw new Error("No valid certificate paths found");
                        case 9:
                          i = 0;
                        case 10:
                          if (!(i < findIssuerResult.length)) {
                            _context51.next = 21;
                            break;
                          }
                          if (!BufferSourceConverter.isEqual(findIssuerResult[i].tbsView, certificate.tbsView)) {
                            _context51.next = 14;
                            break;
                          }
                          result.push([findIssuerResult[i]]);
                          return _context51.abrupt("continue", 18);
                        case 14:
                          _context51.next = 16;
                          return _buildPath(findIssuerResult[i], crypto);
                        case 16:
                          buildPathResult = _context51.sent;
                          for (j = 0; j < buildPathResult.length; j++) {
                            copy = buildPathResult[j].slice();
                            copy.splice(0, 0, findIssuerResult[i]);
                            if (checkUnique(copy)) result.push(copy);else result.push(buildPathResult[j]);
                          }
                        case 18:
                          i++;
                          _context51.next = 10;
                          break;
                        case 21:
                          return _context51.abrupt("return", result);
                        case 22:
                        case "end":
                          return _context51.stop();
                      }
                    }, _callee51);
                  }));
                  return function buildPath(_x78, _x79) {
                    return _ref40.apply(this, arguments);
                  };
                }();
                findCRL = function () {
                  var _ref41 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee52(certificate) {
                    var issuerCertificates, crls, crlsAndCertificates, i, crl, j, _result6;
                    return _regeneratorRuntime().wrap(function _callee52$(_context52) {
                      while (1) switch (_context52.prev = _context52.next) {
                        case 0:
                          issuerCertificates = [];
                          crls = [];
                          crlsAndCertificates = [];
                          issuerCertificates.push.apply(issuerCertificates, _toConsumableArray(localCerts.filter(function (element) {
                            return certificate.issuer.isEqual(element.subject);
                          })));
                          if (!(issuerCertificates.length === 0)) {
                            _context52.next = 6;
                            break;
                          }
                          return _context52.abrupt("return", {
                            status: 1,
                            statusMessage: "No certificate's issuers"
                          });
                        case 6:
                          crls.push.apply(crls, _toConsumableArray(_this157.crls.filter(function (o) {
                            return o.issuer.isEqual(certificate.issuer);
                          })));
                          if (!(crls.length === 0)) {
                            _context52.next = 9;
                            break;
                          }
                          return _context52.abrupt("return", {
                            status: 2,
                            statusMessage: "No CRLs for specific certificate issuer"
                          });
                        case 9:
                          i = 0;
                        case 10:
                          if (!(i < crls.length)) {
                            _context52.next = 33;
                            break;
                          }
                          crl = crls[i];
                          if (!(crl.nextUpdate && crl.nextUpdate.value < _this157.checkDate)) {
                            _context52.next = 14;
                            break;
                          }
                          return _context52.abrupt("continue", 30);
                        case 14:
                          j = 0;
                        case 15:
                          if (!(j < issuerCertificates.length)) {
                            _context52.next = 30;
                            break;
                          }
                          _context52.prev = 16;
                          _context52.next = 19;
                          return crls[i].verify({
                            issuerCertificate: issuerCertificates[j]
                          }, crypto);
                        case 19:
                          _result6 = _context52.sent;
                          if (!_result6) {
                            _context52.next = 23;
                            break;
                          }
                          crlsAndCertificates.push({
                            crl: crls[i],
                            certificate: issuerCertificates[j]
                          });
                          return _context52.abrupt("break", 30);
                        case 23:
                          _context52.next = 27;
                          break;
                        case 25:
                          _context52.prev = 25;
                          _context52.t0 = _context52["catch"](16);
                        case 27:
                          j++;
                          _context52.next = 15;
                          break;
                        case 30:
                          i++;
                          _context52.next = 10;
                          break;
                        case 33:
                          if (!crlsAndCertificates.length) {
                            _context52.next = 35;
                            break;
                          }
                          return _context52.abrupt("return", {
                            status: 0,
                            statusMessage: EMPTY_STRING,
                            result: crlsAndCertificates
                          });
                        case 35:
                          return _context52.abrupt("return", {
                            status: 3,
                            statusMessage: "No valid CRLs found"
                          });
                        case 36:
                        case "end":
                          return _context52.stop();
                      }
                    }, _callee52, null, [[16, 25]]);
                  }));
                  return function findCRL(_x80) {
                    return _ref41.apply(this, arguments);
                  };
                }();
                findOCSP = function () {
                  var _ref42 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee53(certificate, issuerCertificate) {
                    var hashAlgorithm, i, ocsp, _result7;
                    return _regeneratorRuntime().wrap(function _callee53$(_context53) {
                      while (1) switch (_context53.prev = _context53.next) {
                        case 0:
                          hashAlgorithm = crypto.getAlgorithmByOID(certificate.signatureAlgorithm.algorithmId);
                          if (hashAlgorithm.name) {
                            _context53.next = 3;
                            break;
                          }
                          return _context53.abrupt("return", 1);
                        case 3:
                          if (hashAlgorithm.hash) {
                            _context53.next = 5;
                            break;
                          }
                          return _context53.abrupt("return", 1);
                        case 5:
                          i = 0;
                        case 6:
                          if (!(i < _this157.ocsps.length)) {
                            _context53.next = 18;
                            break;
                          }
                          ocsp = _this157.ocsps[i];
                          _context53.next = 10;
                          return ocsp.getCertificateStatus(certificate, issuerCertificate, crypto);
                        case 10:
                          _result7 = _context53.sent;
                          if (!_result7.isForCertificate) {
                            _context53.next = 15;
                            break;
                          }
                          if (!(_result7.status === 0)) {
                            _context53.next = 14;
                            break;
                          }
                          return _context53.abrupt("return", 0);
                        case 14:
                          return _context53.abrupt("return", 1);
                        case 15:
                          i++;
                          _context53.next = 6;
                          break;
                        case 18:
                          return _context53.abrupt("return", 2);
                        case 19:
                        case "end":
                          return _context53.stop();
                      }
                    }, _callee53);
                  }));
                  return function findOCSP(_x81, _x82) {
                    return _ref42.apply(this, arguments);
                  };
                }();
                basicCheck = function () {
                  var _ref43 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee54(path, checkDate) {
                    var i, _i30, _i31, ocspResult, crlResult, j, isCertificateRevoked, isCertificateCA, issuerCertificate, extensionFound, _iterator30, _step30, extension, _iterator31, _step31, _step31$value, _i32, cert, _result8;
                    return _regeneratorRuntime().wrap(function _callee54$(_context54) {
                      while (1) switch (_context54.prev = _context54.next) {
                        case 0:
                          i = 0;
                        case 1:
                          if (!(i < path.length)) {
                            _context54.next = 7;
                            break;
                          }
                          if (!(path[i].notBefore.value > checkDate || path[i].notAfter.value < checkDate)) {
                            _context54.next = 4;
                            break;
                          }
                          return _context54.abrupt("return", {
                            result: false,
                            resultCode: 8,
                            resultMessage: "The certificate is either not yet valid or expired"
                          });
                        case 4:
                          i++;
                          _context54.next = 1;
                          break;
                        case 7:
                          if (!(path.length < 2)) {
                            _context54.next = 9;
                            break;
                          }
                          return _context54.abrupt("return", {
                            result: false,
                            resultCode: 9,
                            resultMessage: "Too short certificate path"
                          });
                        case 9:
                          _i30 = path.length - 2;
                        case 10:
                          if (!(_i30 >= 0)) {
                            _context54.next = 17;
                            break;
                          }
                          if (!(path[_i30].issuer.isEqual(path[_i30].subject) === false)) {
                            _context54.next = 14;
                            break;
                          }
                          if (!(path[_i30].issuer.isEqual(path[_i30 + 1].subject) === false)) {
                            _context54.next = 14;
                            break;
                          }
                          return _context54.abrupt("return", {
                            result: false,
                            resultCode: 10,
                            resultMessage: "Incorrect name chaining"
                          });
                        case 14:
                          _i30--;
                          _context54.next = 10;
                          break;
                        case 17:
                          if (!(_this157.crls.length !== 0 || _this157.ocsps.length !== 0)) {
                            _context54.next = 86;
                            break;
                          }
                          _i31 = 0;
                        case 19:
                          if (!(_i31 < path.length - 1)) {
                            _context54.next = 86;
                            break;
                          }
                          ocspResult = 2;
                          crlResult = {
                            status: 0,
                            statusMessage: EMPTY_STRING
                          };
                          if (!(_this157.ocsps.length !== 0)) {
                            _context54.next = 31;
                            break;
                          }
                          _context54.next = 25;
                          return findOCSP(path[_i31], path[_i31 + 1]);
                        case 25:
                          ocspResult = _context54.sent;
                          _context54.t0 = ocspResult;
                          _context54.next = _context54.t0 === 0 ? 29 : _context54.t0 === 1 ? 30 : 31;
                          break;
                        case 29:
                          return _context54.abrupt("continue", 83);
                        case 30:
                          return _context54.abrupt("return", {
                            result: false,
                            resultCode: 12,
                            resultMessage: "One of certificates was revoked via OCSP response"
                          });
                        case 31:
                          if (!(_this157.crls.length !== 0)) {
                            _context54.next = 55;
                            break;
                          }
                          _context54.next = 34;
                          return findCRL(path[_i31]);
                        case 34:
                          crlResult = _context54.sent;
                          if (!(crlResult.status === 0 && crlResult.result)) {
                            _context54.next = 51;
                            break;
                          }
                          j = 0;
                        case 37:
                          if (!(j < crlResult.result.length)) {
                            _context54.next = 49;
                            break;
                          }
                          isCertificateRevoked = crlResult.result[j].crl.isCertificateRevoked(path[_i31]);
                          if (!isCertificateRevoked) {
                            _context54.next = 41;
                            break;
                          }
                          return _context54.abrupt("return", {
                            result: false,
                            resultCode: 12,
                            resultMessage: "One of certificates had been revoked"
                          });
                        case 41:
                          _context54.next = 43;
                          return checkForCA(crlResult.result[j].certificate, true);
                        case 43:
                          isCertificateCA = _context54.sent;
                          if (!(isCertificateCA.result === false)) {
                            _context54.next = 46;
                            break;
                          }
                          return _context54.abrupt("return", {
                            result: false,
                            resultCode: 13,
                            resultMessage: "CRL issuer certificate is not a CA certificate or does not have crlSign flag"
                          });
                        case 46:
                          j++;
                          _context54.next = 37;
                          break;
                        case 49:
                          _context54.next = 53;
                          break;
                        case 51:
                          if (!(passedWhenNotRevValues === false)) {
                            _context54.next = 53;
                            break;
                          }
                          throw new ChainValidationError(ChainValidationCode.noRevocation, "No revocation values found for one of certificates: ".concat(crlResult.statusMessage));
                        case 53:
                          _context54.next = 57;
                          break;
                        case 55:
                          if (!(ocspResult === 2)) {
                            _context54.next = 57;
                            break;
                          }
                          return _context54.abrupt("return", {
                            result: false,
                            resultCode: 11,
                            resultMessage: "No revocation values found for one of certificates"
                          });
                        case 57:
                          if (!(ocspResult === 2 && crlResult.status === 2 && passedWhenNotRevValues)) {
                            _context54.next = 83;
                            break;
                          }
                          issuerCertificate = path[_i31 + 1];
                          extensionFound = false;
                          if (!issuerCertificate.extensions) {
                            _context54.next = 81;
                            break;
                          }
                          _iterator30 = _createForOfIteratorHelper(issuerCertificate.extensions);
                          _context54.prev = 62;
                          _iterator30.s();
                        case 64:
                          if ((_step30 = _iterator30.n()).done) {
                            _context54.next = 73;
                            break;
                          }
                          extension = _step30.value;
                          _context54.t1 = extension.extnID;
                          _context54.next = _context54.t1 === id_CRLDistributionPoints ? 69 : _context54.t1 === id_FreshestCRL ? 69 : _context54.t1 === id_AuthorityInfoAccess ? 69 : 71;
                          break;
                        case 69:
                          extensionFound = true;
                          return _context54.abrupt("break", 71);
                        case 71:
                          _context54.next = 64;
                          break;
                        case 73:
                          _context54.next = 78;
                          break;
                        case 75:
                          _context54.prev = 75;
                          _context54.t2 = _context54["catch"](62);
                          _iterator30.e(_context54.t2);
                        case 78:
                          _context54.prev = 78;
                          _iterator30.f();
                          return _context54.finish(78);
                        case 81:
                          if (!extensionFound) {
                            _context54.next = 83;
                            break;
                          }
                          throw new ChainValidationError(ChainValidationCode.noRevocation, "No revocation values found for one of certificates: ".concat(crlResult.statusMessage));
                        case 83:
                          _i31++;
                          _context54.next = 19;
                          break;
                        case 86:
                          _iterator31 = _createForOfIteratorHelper(path.entries());
                          _context54.prev = 87;
                          _iterator31.s();
                        case 89:
                          if ((_step31 = _iterator31.n()).done) {
                            _context54.next = 100;
                            break;
                          }
                          _step31$value = _slicedToArray(_step31.value, 2), _i32 = _step31$value[0], cert = _step31$value[1];
                          if (_i32) {
                            _context54.next = 93;
                            break;
                          }
                          return _context54.abrupt("continue", 98);
                        case 93:
                          _context54.next = 95;
                          return checkForCA(cert);
                        case 95:
                          _result8 = _context54.sent;
                          if (_result8.result) {
                            _context54.next = 98;
                            break;
                          }
                          return _context54.abrupt("return", {
                            result: false,
                            resultCode: 14,
                            resultMessage: "One of intermediate certificates is not a CA certificate"
                          });
                        case 98:
                          _context54.next = 89;
                          break;
                        case 100:
                          _context54.next = 105;
                          break;
                        case 102:
                          _context54.prev = 102;
                          _context54.t3 = _context54["catch"](87);
                          _iterator31.e(_context54.t3);
                        case 105:
                          _context54.prev = 105;
                          _iterator31.f();
                          return _context54.finish(105);
                        case 108:
                          return _context54.abrupt("return", {
                            result: true
                          });
                        case 109:
                        case "end":
                          return _context54.stop();
                      }
                    }, _callee54, null, [[62, 75, 78, 81], [87, 102, 105, 108]]);
                  }));
                  return function basicCheck(_x84, _x85) {
                    return _ref43.apply(this, arguments);
                  };
                }();
                localCerts.push.apply(localCerts, _toConsumableArray(this.trustedCerts));
                localCerts.push.apply(localCerts, _toConsumableArray(this.certs));
                i = 0;
              case 12:
                if (!(i < localCerts.length)) {
                  _context56.next = 27;
                  break;
                }
                j = 0;
              case 14:
                if (!(j < localCerts.length)) {
                  _context56.next = 24;
                  break;
                }
                if (!(i === j)) {
                  _context56.next = 17;
                  break;
                }
                return _context56.abrupt("continue", 21);
              case 17:
                if (!BufferSourceConverter.isEqual(localCerts[i].tbsView, localCerts[j].tbsView)) {
                  _context56.next = 21;
                  break;
                }
                localCerts.splice(j, 1);
                i = 0;
                return _context56.abrupt("break", 24);
              case 21:
                j++;
                _context56.next = 14;
                break;
              case 24:
                i++;
                _context56.next = 12;
                break;
              case 27:
                leafCert = localCerts[localCerts.length - 1];
                certificatePath = [leafCert];
                _context56.next = 31;
                return _buildPath(leafCert, crypto);
              case 31:
                result = _context56.sent;
                if (!(result.length === 0)) {
                  _context56.next = 34;
                  break;
                }
                throw new ChainValidationError(ChainValidationCode.noPath, "Unable to find certificate path");
              case 34:
                _i33 = result.length - 1;
              case 35:
                if (!(_i33 >= 0)) {
                  _context56.next = 57;
                  break;
                }
                found = false;
                _j = 0;
              case 38:
                if (!(_j < result[_i33].length)) {
                  _context56.next = 53;
                  break;
                }
                certificate = result[_i33][_j];
                k = 0;
              case 41:
                if (!(k < this.trustedCerts.length)) {
                  _context56.next = 48;
                  break;
                }
                if (!BufferSourceConverter.isEqual(certificate.tbsView, this.trustedCerts[k].tbsView)) {
                  _context56.next = 45;
                  break;
                }
                found = true;
                return _context56.abrupt("break", 48);
              case 45:
                k++;
                _context56.next = 41;
                break;
              case 48:
                if (!found) {
                  _context56.next = 50;
                  break;
                }
                return _context56.abrupt("break", 53);
              case 50:
                _j++;
                _context56.next = 38;
                break;
              case 53:
                if (!found) {
                  result.splice(_i33, 1);
                }
              case 54:
                _i33--;
                _context56.next = 35;
                break;
              case 57:
                if (!(result.length === 0)) {
                  _context56.next = 59;
                  break;
                }
                throw new ChainValidationError(ChainValidationCode.noValidPath, "No valid certificate paths found");
              case 59:
                shortestLength = result[0].length;
                shortestIndex = 0;
                for (_i34 = 0; _i34 < result.length; _i34++) {
                  if (result[_i34].length < shortestLength) {
                    shortestLength = result[_i34].length;
                    shortestIndex = _i34;
                  }
                }
                for (_i35 = 0; _i35 < result[shortestIndex].length; _i35++) certificatePath.push(result[shortestIndex][_i35]);
                _context56.next = 65;
                return basicCheck(certificatePath, this.checkDate);
              case 65:
                result = _context56.sent;
                if (!(result.result === false)) {
                  _context56.next = 68;
                  break;
                }
                throw result;
              case 68:
                return _context56.abrupt("return", certificatePath);
              case 69:
              case "end":
                return _context56.stop();
            }
          }, _callee56, this);
        }));
        function sort() {
          return _sort.apply(this, arguments);
        }
        return sort;
      }()
    }, {
      key: "verify",
      value: function () {
        var _verify5 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee57() {
          var parameters,
            crypto,
            compareDNSName,
            compareRFC822Name,
            compareUniformResourceIdentifier,
            compareIPAddress,
            compareDirectoryName,
            passedWhenNotRevValues,
            initialPolicySet,
            initialExplicitPolicy,
            initialPolicyMappingInhibit,
            initialInhibitPolicy,
            initialPermittedSubtreesSet,
            initialExcludedSubtreesSet,
            initialRequiredNameForms,
            explicitPolicyIndicator,
            policyMappingInhibitIndicator,
            inhibitAnyPolicyIndicator,
            pendingConstraints,
            explicitPolicyPending,
            policyMappingInhibitPending,
            inhibitAnyPolicyPending,
            permittedSubtrees,
            excludedSubtrees,
            requiredNameForms,
            allPolicies,
            policiesAndCerts,
            anyPolicyArray,
            ii,
            policyMappings,
            certPolicies,
            explicitPolicyStart,
            i,
            cert,
            j,
            extension,
            s,
            k,
            policyIndex,
            policyId,
            _s,
            certArray,
            _policyIndex,
            searchAnyPolicy,
            _i39,
            _k,
            issuerDomainPolicyIndex,
            subjectDomainPolicyIndex,
            n,
            _j3,
            m,
            _i40,
            _j4,
            authConstrPolicies,
            _i41,
            found,
            _j5,
            anyPolicyFound,
            _k2,
            userConstrPolicies,
            _i42,
            _j6,
            policyResult,
            _i43,
            _cert,
            subjectAltNames,
            certPermittedSubtrees,
            certExcludedSubtrees,
            _j7,
            _extension2,
            formFound,
            _j8,
            _k3,
            constrGroups,
            _j9,
            p,
            groupPermitted,
            valueExists,
            group,
            _j10,
            _k4,
            _k5,
            _k6,
            _k7,
            _k8,
            excluded,
            _j11,
            _k9,
            _k10,
            _k11,
            _k12,
            _k13,
            _args57 = arguments;
          return _regeneratorRuntime().wrap(function _callee57$(_context57) {
            while (1) switch (_context57.prev = _context57.next) {
              case 0:
                compareDirectoryName = function _compareDirectoryName(name, constraint) {
                  if (name.typesAndValues.length === 0 || constraint.typesAndValues.length === 0) return true;
                  if (name.typesAndValues.length < constraint.typesAndValues.length) return false;
                  var result = true;
                  var nameStart = 0;
                  for (var i = 0; i < constraint.typesAndValues.length; i++) {
                    var localResult = false;
                    for (var j = nameStart; j < name.typesAndValues.length; j++) {
                      localResult = name.typesAndValues[j].isEqual(constraint.typesAndValues[i]);
                      if (name.typesAndValues[j].type === constraint.typesAndValues[i].type) result = result && localResult;
                      if (localResult === true) {
                        if (nameStart === 0 || nameStart === j) {
                          nameStart = j + 1;
                          break;
                        } else return false;
                      }
                    }
                    if (localResult === false) return false;
                  }
                  return nameStart === 0 ? false : result;
                };
                compareIPAddress = function _compareIPAddress(name, constraint) {
                  var nameView = name.valueBlock.valueHexView;
                  var constraintView = constraint.valueBlock.valueHexView;
                  if (nameView.length === 4 && constraintView.length === 8) {
                    for (var i = 0; i < 4; i++) {
                      if ((nameView[i] ^ constraintView[i]) & constraintView[i + 4]) return false;
                    }
                    return true;
                  }
                  if (nameView.length === 16 && constraintView.length === 32) {
                    for (var _i38 = 0; _i38 < 16; _i38++) {
                      if ((nameView[_i38] ^ constraintView[_i38]) & constraintView[_i38 + 16]) return false;
                    }
                    return true;
                  }
                  return false;
                };
                compareUniformResourceIdentifier = function _compareUniformResour(name, constraint) {
                  var namePrepared = stringPrep(name);
                  var constraintPrepared = stringPrep(constraint);
                  var ns = namePrepared.split("/");
                  var cs = constraintPrepared.split("/");
                  if (cs.length > 1) return false;
                  if (ns.length > 1) {
                    for (var i = 0; i < ns.length; i++) {
                      if (ns[i].length > 0 && ns[i].charAt(ns[i].length - 1) !== ":") {
                        var nsPort = ns[i].split(":");
                        namePrepared = nsPort[0];
                        break;
                      }
                    }
                  }
                  var result = compareDNSName(namePrepared, constraintPrepared);
                  if (result) {
                    var nameSplitted = namePrepared.split(".");
                    var constraintSplitted = constraintPrepared.split(".");
                    if (constraintSplitted[0].length === 0) return true;
                    return nameSplitted.length === constraintSplitted.length;
                  }
                  return false;
                };
                compareRFC822Name = function _compareRFC822Name(name, constraint) {
                  var namePrepared = stringPrep(name);
                  var constraintPrepared = stringPrep(constraint);
                  var nameSplitted = namePrepared.split("@");
                  var constraintSplitted = constraintPrepared.split("@");
                  if (nameSplitted.length === 0 || constraintSplitted.length === 0 || nameSplitted.length < constraintSplitted.length) return false;
                  if (constraintSplitted.length === 1) {
                    var _result9 = compareDNSName(nameSplitted[1], constraintSplitted[0]);
                    if (_result9) {
                      var ns = nameSplitted[1].split(".");
                      var cs = constraintSplitted[0].split(".");
                      if (cs[0].length === 0) return true;
                      return ns.length === cs.length;
                    }
                    return false;
                  }
                  return namePrepared.localeCompare(constraintPrepared) === 0;
                };
                compareDNSName = function _compareDNSName(name, constraint) {
                  var namePrepared = stringPrep(name);
                  var constraintPrepared = stringPrep(constraint);
                  var nameSplitted = namePrepared.split(".");
                  var constraintSplitted = constraintPrepared.split(".");
                  var nameLen = nameSplitted.length;
                  var constrLen = constraintSplitted.length;
                  if (nameLen === 0 || constrLen === 0 || nameLen < constrLen) {
                    return false;
                  }
                  for (var i = 0; i < nameLen; i++) {
                    if (nameSplitted[i].length === 0) {
                      return false;
                    }
                  }
                  for (var _i36 = 0; _i36 < constrLen; _i36++) {
                    if (constraintSplitted[_i36].length === 0) {
                      if (_i36 === 0) {
                        if (constrLen === 1) {
                          return false;
                        }
                        continue;
                      }
                      return false;
                    }
                  }
                  for (var _i37 = 0; _i37 < constrLen; _i37++) {
                    if (constraintSplitted[constrLen - 1 - _i37].length === 0) {
                      continue;
                    }
                    if (nameSplitted[nameLen - 1 - _i37].localeCompare(constraintSplitted[constrLen - 1 - _i37]) !== 0) {
                      return false;
                    }
                  }
                  return true;
                };
                parameters = _args57.length > 0 && _args57[0] !== undefined ? _args57[0] : {};
                crypto = _args57.length > 1 && _args57[1] !== undefined ? _args57[1] : getCrypto(true);
                _context57.prev = 7;
                if (!(this.certs.length === 0)) {
                  _context57.next = 10;
                  break;
                }
                throw new Error("Empty certificate array");
              case 10:
                passedWhenNotRevValues = parameters.passedWhenNotRevValues || false;
                initialPolicySet = parameters.initialPolicySet || [id_AnyPolicy];
                initialExplicitPolicy = parameters.initialExplicitPolicy || false;
                initialPolicyMappingInhibit = parameters.initialPolicyMappingInhibit || false;
                initialInhibitPolicy = parameters.initialInhibitPolicy || false;
                initialPermittedSubtreesSet = parameters.initialPermittedSubtreesSet || [];
                initialExcludedSubtreesSet = parameters.initialExcludedSubtreesSet || [];
                initialRequiredNameForms = parameters.initialRequiredNameForms || [];
                explicitPolicyIndicator = initialExplicitPolicy;
                policyMappingInhibitIndicator = initialPolicyMappingInhibit;
                inhibitAnyPolicyIndicator = initialInhibitPolicy;
                pendingConstraints = [false, false, false];
                explicitPolicyPending = 0;
                policyMappingInhibitPending = 0;
                inhibitAnyPolicyPending = 0;
                permittedSubtrees = initialPermittedSubtreesSet;
                excludedSubtrees = initialExcludedSubtreesSet;
                requiredNameForms = initialRequiredNameForms;
                _context57.next = 31;
                return this.sort(passedWhenNotRevValues, crypto);
              case 31:
                this.certs = _context57.sent;
                allPolicies = [];
                allPolicies.push(id_AnyPolicy);
                policiesAndCerts = [];
                anyPolicyArray = new Array(this.certs.length - 1);
                for (ii = 0; ii < this.certs.length - 1; ii++) anyPolicyArray[ii] = true;
                policiesAndCerts.push(anyPolicyArray);
                policyMappings = new Array(this.certs.length - 1);
                certPolicies = new Array(this.certs.length - 1);
                explicitPolicyStart = explicitPolicyIndicator ? this.certs.length - 1 : -1;
                i = this.certs.length - 2;
              case 42:
                if (!(i >= 0)) {
                  _context57.next = 100;
                  break;
                }
                cert = this.certs[i];
                if (!cert.extensions) {
                  _context57.next = 97;
                  break;
                }
                j = 0;
              case 46:
                if (!(j < cert.extensions.length)) {
                  _context57.next = 83;
                  break;
                }
                extension = cert.extensions[j];
                if (!(extension.extnID === id_CertificatePolicies)) {
                  _context57.next = 74;
                  break;
                }
                certPolicies[i] = extension.parsedValue;
                s = 0;
              case 51:
                if (!(s < allPolicies.length)) {
                  _context57.next = 58;
                  break;
                }
                if (!(allPolicies[s] === id_AnyPolicy)) {
                  _context57.next = 55;
                  break;
                }
                delete policiesAndCerts[s][i];
                return _context57.abrupt("break", 58);
              case 55:
                s++;
                _context57.next = 51;
                break;
              case 58:
                k = 0;
              case 59:
                if (!(k < extension.parsedValue.certificatePolicies.length)) {
                  _context57.next = 74;
                  break;
                }
                policyIndex = -1;
                policyId = extension.parsedValue.certificatePolicies[k].policyIdentifier;
                _s = 0;
              case 63:
                if (!(_s < allPolicies.length)) {
                  _context57.next = 70;
                  break;
                }
                if (!(policyId === allPolicies[_s])) {
                  _context57.next = 67;
                  break;
                }
                policyIndex = _s;
                return _context57.abrupt("break", 70);
              case 67:
                _s++;
                _context57.next = 63;
                break;
              case 70:
                if (policyIndex === -1) {
                  allPolicies.push(policyId);
                  certArray = new Array(this.certs.length - 1);
                  certArray[i] = true;
                  policiesAndCerts.push(certArray);
                } else policiesAndCerts[policyIndex][i] = true;
              case 71:
                k++;
                _context57.next = 59;
                break;
              case 74:
                if (!(extension.extnID === id_PolicyMappings)) {
                  _context57.next = 78;
                  break;
                }
                if (!policyMappingInhibitIndicator) {
                  _context57.next = 77;
                  break;
                }
                return _context57.abrupt("return", {
                  result: false,
                  resultCode: 98,
                  resultMessage: "Policy mapping prohibited"
                });
              case 77:
                policyMappings[i] = extension.parsedValue;
              case 78:
                if (extension.extnID === id_PolicyConstraints) {
                  if (explicitPolicyIndicator === false) {
                    if (extension.parsedValue.requireExplicitPolicy === 0) {
                      explicitPolicyIndicator = true;
                      explicitPolicyStart = i;
                    } else {
                      if (pendingConstraints[0] === false) {
                        pendingConstraints[0] = true;
                        explicitPolicyPending = extension.parsedValue.requireExplicitPolicy;
                      } else explicitPolicyPending = explicitPolicyPending > extension.parsedValue.requireExplicitPolicy ? extension.parsedValue.requireExplicitPolicy : explicitPolicyPending;
                    }
                    if (extension.parsedValue.inhibitPolicyMapping === 0) policyMappingInhibitIndicator = true;else {
                      if (pendingConstraints[1] === false) {
                        pendingConstraints[1] = true;
                        policyMappingInhibitPending = extension.parsedValue.inhibitPolicyMapping + 1;
                      } else policyMappingInhibitPending = policyMappingInhibitPending > extension.parsedValue.inhibitPolicyMapping + 1 ? extension.parsedValue.inhibitPolicyMapping + 1 : policyMappingInhibitPending;
                    }
                  }
                }
                if (extension.extnID === id_InhibitAnyPolicy) {
                  if (inhibitAnyPolicyIndicator === false) {
                    if (extension.parsedValue.valueBlock.valueDec === 0) inhibitAnyPolicyIndicator = true;else {
                      if (pendingConstraints[2] === false) {
                        pendingConstraints[2] = true;
                        inhibitAnyPolicyPending = extension.parsedValue.valueBlock.valueDec;
                      } else inhibitAnyPolicyPending = inhibitAnyPolicyPending > extension.parsedValue.valueBlock.valueDec ? extension.parsedValue.valueBlock.valueDec : inhibitAnyPolicyPending;
                    }
                  }
                }
              case 80:
                j++;
                _context57.next = 46;
                break;
              case 83:
                if (!(inhibitAnyPolicyIndicator === true)) {
                  _context57.next = 94;
                  break;
                }
                _policyIndex = -1;
                searchAnyPolicy = 0;
              case 86:
                if (!(searchAnyPolicy < allPolicies.length)) {
                  _context57.next = 93;
                  break;
                }
                if (!(allPolicies[searchAnyPolicy] === id_AnyPolicy)) {
                  _context57.next = 90;
                  break;
                }
                _policyIndex = searchAnyPolicy;
                return _context57.abrupt("break", 93);
              case 90:
                searchAnyPolicy++;
                _context57.next = 86;
                break;
              case 93:
                if (_policyIndex !== -1) delete policiesAndCerts[0][i];
              case 94:
                if (explicitPolicyIndicator === false) {
                  if (pendingConstraints[0] === true) {
                    explicitPolicyPending--;
                    if (explicitPolicyPending === 0) {
                      explicitPolicyIndicator = true;
                      explicitPolicyStart = i;
                      pendingConstraints[0] = false;
                    }
                  }
                }
                if (policyMappingInhibitIndicator === false) {
                  if (pendingConstraints[1] === true) {
                    policyMappingInhibitPending--;
                    if (policyMappingInhibitPending === 0) {
                      policyMappingInhibitIndicator = true;
                      pendingConstraints[1] = false;
                    }
                  }
                }
                if (inhibitAnyPolicyIndicator === false) {
                  if (pendingConstraints[2] === true) {
                    inhibitAnyPolicyPending--;
                    if (inhibitAnyPolicyPending === 0) {
                      inhibitAnyPolicyIndicator = true;
                      pendingConstraints[2] = false;
                    }
                  }
                }
              case 97:
                i--;
                _context57.next = 42;
                break;
              case 100:
                _i39 = 0;
              case 101:
                if (!(_i39 < this.certs.length - 1)) {
                  _context57.next = 118;
                  break;
                }
                if (!(_i39 < this.certs.length - 2 && typeof policyMappings[_i39 + 1] !== "undefined")) {
                  _context57.next = 115;
                  break;
                }
                _k = 0;
              case 104:
                if (!(_k < policyMappings[_i39 + 1].mappings.length)) {
                  _context57.next = 115;
                  break;
                }
                if (!(policyMappings[_i39 + 1].mappings[_k].issuerDomainPolicy === id_AnyPolicy || policyMappings[_i39 + 1].mappings[_k].subjectDomainPolicy === id_AnyPolicy)) {
                  _context57.next = 107;
                  break;
                }
                return _context57.abrupt("return", {
                  result: false,
                  resultCode: 99,
                  resultMessage: "The \"anyPolicy\" should not be a part of policy mapping scheme"
                });
              case 107:
                issuerDomainPolicyIndex = -1;
                subjectDomainPolicyIndex = -1;
                for (n = 0; n < allPolicies.length; n++) {
                  if (allPolicies[n] === policyMappings[_i39 + 1].mappings[_k].issuerDomainPolicy) issuerDomainPolicyIndex = n;
                  if (allPolicies[n] === policyMappings[_i39 + 1].mappings[_k].subjectDomainPolicy) subjectDomainPolicyIndex = n;
                }
                if (typeof policiesAndCerts[issuerDomainPolicyIndex][_i39] !== "undefined") delete policiesAndCerts[issuerDomainPolicyIndex][_i39];
                for (_j3 = 0; _j3 < certPolicies[_i39].certificatePolicies.length; _j3++) {
                  if (policyMappings[_i39 + 1].mappings[_k].subjectDomainPolicy === certPolicies[_i39].certificatePolicies[_j3].policyIdentifier) {
                    if (issuerDomainPolicyIndex !== -1 && subjectDomainPolicyIndex !== -1) {
                      for (m = 0; m <= _i39; m++) {
                        if (typeof policiesAndCerts[subjectDomainPolicyIndex][m] !== "undefined") {
                          policiesAndCerts[issuerDomainPolicyIndex][m] = true;
                          delete policiesAndCerts[subjectDomainPolicyIndex][m];
                        }
                      }
                    }
                  }
                }
              case 112:
                _k++;
                _context57.next = 104;
                break;
              case 115:
                _i39++;
                _context57.next = 101;
                break;
              case 118:
                for (_i40 = 0; _i40 < allPolicies.length; _i40++) {
                  if (allPolicies[_i40] === id_AnyPolicy) {
                    for (_j4 = 0; _j4 < explicitPolicyStart; _j4++) delete policiesAndCerts[_i40][_j4];
                  }
                }
                authConstrPolicies = [];
                _i41 = 0;
              case 121:
                if (!(_i41 < policiesAndCerts.length)) {
                  _context57.next = 149;
                  break;
                }
                found = true;
                _j5 = 0;
              case 124:
                if (!(_j5 < this.certs.length - 1)) {
                  _context57.next = 145;
                  break;
                }
                anyPolicyFound = false;
                if (!(_j5 < explicitPolicyStart && allPolicies[_i41] === id_AnyPolicy && allPolicies.length > 1)) {
                  _context57.next = 129;
                  break;
                }
                found = false;
                return _context57.abrupt("break", 145);
              case 129:
                if (!(typeof policiesAndCerts[_i41][_j5] === "undefined")) {
                  _context57.next = 142;
                  break;
                }
                if (!(_j5 >= explicitPolicyStart)) {
                  _context57.next = 139;
                  break;
                }
                _k2 = 0;
              case 132:
                if (!(_k2 < allPolicies.length)) {
                  _context57.next = 139;
                  break;
                }
                if (!(allPolicies[_k2] === id_AnyPolicy)) {
                  _context57.next = 136;
                  break;
                }
                if (policiesAndCerts[_k2][_j5] === true) anyPolicyFound = true;
                return _context57.abrupt("break", 139);
              case 136:
                _k2++;
                _context57.next = 132;
                break;
              case 139:
                if (anyPolicyFound) {
                  _context57.next = 142;
                  break;
                }
                found = false;
                return _context57.abrupt("break", 145);
              case 142:
                _j5++;
                _context57.next = 124;
                break;
              case 145:
                if (found === true) authConstrPolicies.push(allPolicies[_i41]);
              case 146:
                _i41++;
                _context57.next = 121;
                break;
              case 149:
                userConstrPolicies = [];
                if (!(initialPolicySet.length === 1 && initialPolicySet[0] === id_AnyPolicy && explicitPolicyIndicator === false)) {
                  _context57.next = 154;
                  break;
                }
                userConstrPolicies = initialPolicySet;
                _context57.next = 171;
                break;
              case 154:
                if (!(authConstrPolicies.length === 1 && authConstrPolicies[0] === id_AnyPolicy)) {
                  _context57.next = 158;
                  break;
                }
                userConstrPolicies = initialPolicySet;
                _context57.next = 171;
                break;
              case 158:
                _i42 = 0;
              case 159:
                if (!(_i42 < authConstrPolicies.length)) {
                  _context57.next = 171;
                  break;
                }
                _j6 = 0;
              case 161:
                if (!(_j6 < initialPolicySet.length)) {
                  _context57.next = 168;
                  break;
                }
                if (!(initialPolicySet[_j6] === authConstrPolicies[_i42] || initialPolicySet[_j6] === id_AnyPolicy)) {
                  _context57.next = 165;
                  break;
                }
                userConstrPolicies.push(authConstrPolicies[_i42]);
                return _context57.abrupt("break", 168);
              case 165:
                _j6++;
                _context57.next = 161;
                break;
              case 168:
                _i42++;
                _context57.next = 159;
                break;
              case 171:
                policyResult = {
                  result: userConstrPolicies.length > 0,
                  resultCode: 0,
                  resultMessage: userConstrPolicies.length > 0 ? EMPTY_STRING : "Zero \"userConstrPolicies\" array, no intersections with \"authConstrPolicies\"",
                  authConstrPolicies: authConstrPolicies,
                  userConstrPolicies: userConstrPolicies,
                  explicitPolicyIndicator: explicitPolicyIndicator,
                  policyMappings: policyMappings,
                  certificatePath: this.certs
                };
                if (!(userConstrPolicies.length === 0)) {
                  _context57.next = 174;
                  break;
                }
                return _context57.abrupt("return", policyResult);
              case 174:
                if (!(policyResult.result === false)) {
                  _context57.next = 176;
                  break;
                }
                return _context57.abrupt("return", policyResult);
              case 176:
                _i43 = this.certs.length - 2;
              case 178:
                if (!(_i43 >= 0)) {
                  _context57.next = 296;
                  break;
                }
                _cert = this.certs[_i43];
                subjectAltNames = [];
                certPermittedSubtrees = [];
                certExcludedSubtrees = [];
                if (_cert.extensions) {
                  for (_j7 = 0; _j7 < _cert.extensions.length; _j7++) {
                    _extension2 = _cert.extensions[_j7];
                    if (_extension2.extnID === id_NameConstraints) {
                      if ("permittedSubtrees" in _extension2.parsedValue) certPermittedSubtrees = certPermittedSubtrees.concat(_extension2.parsedValue.permittedSubtrees);
                      if ("excludedSubtrees" in _extension2.parsedValue) certExcludedSubtrees = certExcludedSubtrees.concat(_extension2.parsedValue.excludedSubtrees);
                    }
                    if (_extension2.extnID === id_SubjectAltName) subjectAltNames = subjectAltNames.concat(_extension2.parsedValue.altNames);
                  }
                }
                formFound = requiredNameForms.length <= 0;
                _j8 = 0;
              case 186:
                if (!(_j8 < requiredNameForms.length)) {
                  _context57.next = 207;
                  break;
                }
                _context57.t0 = requiredNameForms[_j8].base.type;
                _context57.next = _context57.t0 === 4 ? 190 : 204;
                break;
              case 190:
                if (!(requiredNameForms[_j8].base.value.typesAndValues.length !== _cert.subject.typesAndValues.length)) {
                  _context57.next = 192;
                  break;
                }
                return _context57.abrupt("continue", 204);
              case 192:
                formFound = true;
                _k3 = 0;
              case 194:
                if (!(_k3 < _cert.subject.typesAndValues.length)) {
                  _context57.next = 201;
                  break;
                }
                if (!(_cert.subject.typesAndValues[_k3].type !== requiredNameForms[_j8].base.value.typesAndValues[_k3].type)) {
                  _context57.next = 198;
                  break;
                }
                formFound = false;
                return _context57.abrupt("break", 201);
              case 198:
                _k3++;
                _context57.next = 194;
                break;
              case 201:
                if (!(formFound === true)) {
                  _context57.next = 203;
                  break;
                }
                return _context57.abrupt("break", 204);
              case 203:
                return _context57.abrupt("break", 204);
              case 204:
                _j8++;
                _context57.next = 186;
                break;
              case 207:
                if (!(formFound === false)) {
                  _context57.next = 212;
                  break;
                }
                policyResult.result = false;
                policyResult.resultCode = 21;
                policyResult.resultMessage = "No necessary name form found";
                throw policyResult;
              case 212:
                constrGroups = [[], [], [], [], []];
                _j9 = 0;
              case 214:
                if (!(_j9 < permittedSubtrees.length)) {
                  _context57.next = 231;
                  break;
                }
                _context57.t1 = permittedSubtrees[_j9].base.type;
                _context57.next = _context57.t1 === 1 ? 218 : _context57.t1 === 2 ? 220 : _context57.t1 === 4 ? 222 : _context57.t1 === 6 ? 224 : _context57.t1 === 7 ? 226 : 228;
                break;
              case 218:
                constrGroups[0].push(permittedSubtrees[_j9]);
                return _context57.abrupt("break", 228);
              case 220:
                constrGroups[1].push(permittedSubtrees[_j9]);
                return _context57.abrupt("break", 228);
              case 222:
                constrGroups[2].push(permittedSubtrees[_j9]);
                return _context57.abrupt("break", 228);
              case 224:
                constrGroups[3].push(permittedSubtrees[_j9]);
                return _context57.abrupt("break", 228);
              case 226:
                constrGroups[4].push(permittedSubtrees[_j9]);
                return _context57.abrupt("break", 228);
              case 228:
                _j9++;
                _context57.next = 214;
                break;
              case 231:
                p = 0;
              case 232:
                if (!(p < 5)) {
                  _context57.next = 265;
                  break;
                }
                groupPermitted = false;
                valueExists = false;
                group = constrGroups[p];
                _j10 = 0;
              case 237:
                if (!(_j10 < group.length)) {
                  _context57.next = 257;
                  break;
                }
                _context57.t2 = p;
                _context57.next = _context57.t2 === 0 ? 241 : _context57.t2 === 1 ? 243 : _context57.t2 === 2 ? 245 : _context57.t2 === 3 ? 248 : _context57.t2 === 4 ? 250 : 252;
                break;
              case 241:
                if (subjectAltNames.length > 0) {
                  for (_k4 = 0; _k4 < subjectAltNames.length; _k4++) {
                    if (subjectAltNames[_k4].type === 1) {
                      valueExists = true;
                      groupPermitted = groupPermitted || compareRFC822Name(subjectAltNames[_k4].value, group[_j10].base.value);
                    }
                  }
                } else {
                  for (_k5 = 0; _k5 < _cert.subject.typesAndValues.length; _k5++) {
                    if (_cert.subject.typesAndValues[_k5].type === "1.2.840.113549.1.9.1" || _cert.subject.typesAndValues[_k5].type === "0.9.2342.19200300.100.1.3") {
                      valueExists = true;
                      groupPermitted = groupPermitted || compareRFC822Name(_cert.subject.typesAndValues[_k5].value.valueBlock.value, group[_j10].base.value);
                    }
                  }
                }
                return _context57.abrupt("break", 252);
              case 243:
                if (subjectAltNames.length > 0) {
                  for (_k6 = 0; _k6 < subjectAltNames.length; _k6++) {
                    if (subjectAltNames[_k6].type === 2) {
                      valueExists = true;
                      groupPermitted = groupPermitted || compareDNSName(subjectAltNames[_k6].value, group[_j10].base.value);
                    }
                  }
                }
                return _context57.abrupt("break", 252);
              case 245:
                valueExists = true;
                groupPermitted = compareDirectoryName(_cert.subject, group[_j10].base.value);
                return _context57.abrupt("break", 252);
              case 248:
                if (subjectAltNames.length > 0) {
                  for (_k7 = 0; _k7 < subjectAltNames.length; _k7++) {
                    if (subjectAltNames[_k7].type === 6) {
                      valueExists = true;
                      groupPermitted = groupPermitted || compareUniformResourceIdentifier(subjectAltNames[_k7].value, group[_j10].base.value);
                    }
                  }
                }
                return _context57.abrupt("break", 252);
              case 250:
                if (subjectAltNames.length > 0) {
                  for (_k8 = 0; _k8 < subjectAltNames.length; _k8++) {
                    if (subjectAltNames[_k8].type === 7) {
                      valueExists = true;
                      groupPermitted = groupPermitted || compareIPAddress(subjectAltNames[_k8].value, group[_j10].base.value);
                    }
                  }
                }
                return _context57.abrupt("break", 252);
              case 252:
                if (!groupPermitted) {
                  _context57.next = 254;
                  break;
                }
                return _context57.abrupt("break", 257);
              case 254:
                _j10++;
                _context57.next = 237;
                break;
              case 257:
                if (!(groupPermitted === false && group.length > 0 && valueExists)) {
                  _context57.next = 262;
                  break;
                }
                policyResult.result = false;
                policyResult.resultCode = 41;
                policyResult.resultMessage = "Failed to meet \"permitted sub-trees\" name constraint";
                throw policyResult;
              case 262:
                p++;
                _context57.next = 232;
                break;
              case 265:
                excluded = false;
                _j11 = 0;
              case 267:
                if (!(_j11 < excludedSubtrees.length)) {
                  _context57.next = 286;
                  break;
                }
                _context57.t3 = excludedSubtrees[_j11].base.type;
                _context57.next = _context57.t3 === 1 ? 271 : _context57.t3 === 2 ? 273 : _context57.t3 === 4 ? 275 : _context57.t3 === 6 ? 277 : _context57.t3 === 7 ? 279 : 281;
                break;
              case 271:
                if (subjectAltNames.length >= 0) {
                  for (_k9 = 0; _k9 < subjectAltNames.length; _k9++) {
                    if (subjectAltNames[_k9].type === 1) excluded = excluded || compareRFC822Name(subjectAltNames[_k9].value, excludedSubtrees[_j11].base.value);
                  }
                } else {
                  for (_k10 = 0; _k10 < _cert.subject.typesAndValues.length; _k10++) {
                    if (_cert.subject.typesAndValues[_k10].type === "1.2.840.113549.1.9.1" || _cert.subject.typesAndValues[_k10].type === "0.9.2342.19200300.100.1.3") excluded = excluded || compareRFC822Name(_cert.subject.typesAndValues[_k10].value.valueBlock.value, excludedSubtrees[_j11].base.value);
                  }
                }
                return _context57.abrupt("break", 281);
              case 273:
                if (subjectAltNames.length > 0) {
                  for (_k11 = 0; _k11 < subjectAltNames.length; _k11++) {
                    if (subjectAltNames[_k11].type === 2) excluded = excluded || compareDNSName(subjectAltNames[_k11].value, excludedSubtrees[_j11].base.value);
                  }
                }
                return _context57.abrupt("break", 281);
              case 275:
                excluded = excluded || compareDirectoryName(_cert.subject, excludedSubtrees[_j11].base.value);
                return _context57.abrupt("break", 281);
              case 277:
                if (subjectAltNames.length > 0) {
                  for (_k12 = 0; _k12 < subjectAltNames.length; _k12++) {
                    if (subjectAltNames[_k12].type === 6) excluded = excluded || compareUniformResourceIdentifier(subjectAltNames[_k12].value, excludedSubtrees[_j11].base.value);
                  }
                }
                return _context57.abrupt("break", 281);
              case 279:
                if (subjectAltNames.length > 0) {
                  for (_k13 = 0; _k13 < subjectAltNames.length; _k13++) {
                    if (subjectAltNames[_k13].type === 7) excluded = excluded || compareIPAddress(subjectAltNames[_k13].value, excludedSubtrees[_j11].base.value);
                  }
                }
                return _context57.abrupt("break", 281);
              case 281:
                if (!excluded) {
                  _context57.next = 283;
                  break;
                }
                return _context57.abrupt("break", 286);
              case 283:
                _j11++;
                _context57.next = 267;
                break;
              case 286:
                if (!(excluded === true)) {
                  _context57.next = 291;
                  break;
                }
                policyResult.result = false;
                policyResult.resultCode = 42;
                policyResult.resultMessage = "Failed to meet \"excluded sub-trees\" name constraint";
                throw policyResult;
              case 291:
                permittedSubtrees = permittedSubtrees.concat(certPermittedSubtrees);
                excludedSubtrees = excludedSubtrees.concat(certExcludedSubtrees);
              case 293:
                _i43--;
                _context57.next = 178;
                break;
              case 296:
                return _context57.abrupt("return", policyResult);
              case 299:
                _context57.prev = 299;
                _context57.t4 = _context57["catch"](7);
                if (!(_context57.t4 instanceof Error)) {
                  _context57.next = 305;
                  break;
                }
                if (!(_context57.t4 instanceof ChainValidationError)) {
                  _context57.next = 304;
                  break;
                }
                return _context57.abrupt("return", {
                  result: false,
                  resultCode: _context57.t4.code,
                  resultMessage: _context57.t4.message,
                  error: _context57.t4
                });
              case 304:
                return _context57.abrupt("return", {
                  result: false,
                  resultCode: ChainValidationCode.unknown,
                  resultMessage: _context57.t4.message,
                  error: _context57.t4
                });
              case 305:
                if (!(_context57.t4 && _typeof(_context57.t4) === "object" && "resultMessage" in _context57.t4)) {
                  _context57.next = 307;
                  break;
                }
                return _context57.abrupt("return", _context57.t4);
              case 307:
                return _context57.abrupt("return", {
                  result: false,
                  resultCode: -1,
                  resultMessage: "".concat(_context57.t4)
                });
              case 308:
              case "end":
                return _context57.stop();
            }
          }, _callee57, this, [[7, 299]]);
        }));
        function verify() {
          return _verify5.apply(this, arguments);
        }
        return verify;
      }()
    }], [{
      key: "defaultFindOrigin",
      value: function defaultFindOrigin(certificate, validationEngine) {
        if (certificate.tbsView.byteLength === 0) {
          certificate.tbsView = new Uint8Array(certificate.encodeTBS().toBER());
        }
        var _iterator32 = _createForOfIteratorHelper(validationEngine.certs),
          _step32;
        try {
          for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {
            var localCert = _step32.value;
            if (localCert.tbsView.byteLength === 0) {
              localCert.tbsView = new Uint8Array(localCert.encodeTBS().toBER());
            }
            if (BufferSourceConverter.isEqual(certificate.tbsView, localCert.tbsView)) return "Intermediate Certificates";
          }
        } catch (err) {
          _iterator32.e(err);
        } finally {
          _iterator32.f();
        }
        var _iterator33 = _createForOfIteratorHelper(validationEngine.trustedCerts),
          _step33;
        try {
          for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {
            var trustedCert = _step33.value;
            if (trustedCert.tbsView.byteLength === 0) trustedCert.tbsView = new Uint8Array(trustedCert.encodeTBS().toBER());
            if (BufferSourceConverter.isEqual(certificate.tbsView, trustedCert.tbsView)) return "Trusted Certificates";
          }
        } catch (err) {
          _iterator33.e(err);
        } finally {
          _iterator33.f();
        }
        return "Unknown";
      }
    }]);
  }();
  var TBS_RESPONSE_DATA = "tbsResponseData";
  var SIGNATURE_ALGORITHM$3 = "signatureAlgorithm";
  var SIGNATURE$2 = "signature";
  var CERTS$1 = "certs";
  var BASIC_OCSP_RESPONSE = "BasicOCSPResponse";
  var BASIC_OCSP_RESPONSE_TBS_RESPONSE_DATA = "".concat(BASIC_OCSP_RESPONSE, ".").concat(TBS_RESPONSE_DATA);
  var BASIC_OCSP_RESPONSE_SIGNATURE_ALGORITHM = "".concat(BASIC_OCSP_RESPONSE, ".").concat(SIGNATURE_ALGORITHM$3);
  var BASIC_OCSP_RESPONSE_SIGNATURE = "".concat(BASIC_OCSP_RESPONSE, ".").concat(SIGNATURE$2);
  var BASIC_OCSP_RESPONSE_CERTS = "".concat(BASIC_OCSP_RESPONSE, ".").concat(CERTS$1);
  var CLEAR_PROPS$g = [BASIC_OCSP_RESPONSE_TBS_RESPONSE_DATA, BASIC_OCSP_RESPONSE_SIGNATURE_ALGORITHM, BASIC_OCSP_RESPONSE_SIGNATURE, BASIC_OCSP_RESPONSE_CERTS];
  var BasicOCSPResponse = function (_PkiObject95) {
    function BasicOCSPResponse() {
      var _this158;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, BasicOCSPResponse);
      _this158 = _callSuper(this, BasicOCSPResponse);
      _this158.tbsResponseData = getParametersValue(parameters, TBS_RESPONSE_DATA, BasicOCSPResponse.defaultValues(TBS_RESPONSE_DATA));
      _this158.signatureAlgorithm = getParametersValue(parameters, SIGNATURE_ALGORITHM$3, BasicOCSPResponse.defaultValues(SIGNATURE_ALGORITHM$3));
      _this158.signature = getParametersValue(parameters, SIGNATURE$2, BasicOCSPResponse.defaultValues(SIGNATURE$2));
      if (CERTS$1 in parameters) {
        _this158.certs = getParametersValue(parameters, CERTS$1, BasicOCSPResponse.defaultValues(CERTS$1));
      }
      if (parameters.schema) {
        _this158.fromSchema(parameters.schema);
      }
      return _this158;
    }
    _inherits(BasicOCSPResponse, _PkiObject95);
    return _createClass(BasicOCSPResponse, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$g);
        var asn1 = compareSchema(schema, schema, BasicOCSPResponse.schema());
        AsnError.assertSchema(asn1, this.className);
        this.tbsResponseData = new ResponseData({
          schema: asn1.result[BASIC_OCSP_RESPONSE_TBS_RESPONSE_DATA]
        });
        this.signatureAlgorithm = new AlgorithmIdentifier({
          schema: asn1.result[BASIC_OCSP_RESPONSE_SIGNATURE_ALGORITHM]
        });
        this.signature = asn1.result[BASIC_OCSP_RESPONSE_SIGNATURE];
        if (BASIC_OCSP_RESPONSE_CERTS in asn1.result) {
          this.certs = Array.from(asn1.result[BASIC_OCSP_RESPONSE_CERTS], function (element) {
            return new Certificate({
              schema: element
            });
          });
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        outputArray.push(this.tbsResponseData.toSchema());
        outputArray.push(this.signatureAlgorithm.toSchema());
        outputArray.push(this.signature);
        if (this.certs) {
          outputArray.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [new Sequence({
              value: Array.from(this.certs, function (o) {
                return o.toSchema();
              })
            })]
          }));
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          tbsResponseData: this.tbsResponseData.toJSON(),
          signatureAlgorithm: this.signatureAlgorithm.toJSON(),
          signature: this.signature.toJSON()
        };
        if (this.certs) {
          res.certs = Array.from(this.certs, function (o) {
            return o.toJSON();
          });
        }
        return res;
      }
    }, {
      key: "getCertificateStatus",
      value: function () {
        var _getCertificateStatus = _asyncToGenerator(_regeneratorRuntime().mark(function _callee58(certificate, issuerCertificate) {
          var crypto,
            result,
            hashesObject,
            certIDs,
            _iterator34,
            _step34,
            response,
            hashAlgorithm,
            certID,
            _iterator35,
            _step35,
            _response,
            _iterator36,
            _step36,
            id,
            _args58 = arguments;
          return _regeneratorRuntime().wrap(function _callee58$(_context58) {
            while (1) switch (_context58.prev = _context58.next) {
              case 0:
                crypto = _args58.length > 2 && _args58[2] !== undefined ? _args58[2] : getCrypto(true);
                result = {
                  isForCertificate: false,
                  status: 2
                };
                hashesObject = {};
                certIDs = [];
                _iterator34 = _createForOfIteratorHelper(this.tbsResponseData.responses);
                _context58.prev = 5;
                _iterator34.s();
              case 7:
                if ((_step34 = _iterator34.n()).done) {
                  _context58.next = 18;
                  break;
                }
                response = _step34.value;
                hashAlgorithm = crypto.getAlgorithmByOID(response.certID.hashAlgorithm.algorithmId, true, "CertID.hashAlgorithm");
                if (hashesObject[hashAlgorithm.name]) {
                  _context58.next = 16;
                  break;
                }
                hashesObject[hashAlgorithm.name] = 1;
                certID = new CertID();
                certIDs.push(certID);
                _context58.next = 16;
                return certID.createForCertificate(certificate, {
                  hashAlgorithm: hashAlgorithm.name,
                  issuerCertificate: issuerCertificate
                }, crypto);
              case 16:
                _context58.next = 7;
                break;
              case 18:
                _context58.next = 23;
                break;
              case 20:
                _context58.prev = 20;
                _context58.t0 = _context58["catch"](5);
                _iterator34.e(_context58.t0);
              case 23:
                _context58.prev = 23;
                _iterator34.f();
                return _context58.finish(23);
              case 26:
                _iterator35 = _createForOfIteratorHelper(this.tbsResponseData.responses);
                _context58.prev = 27;
                _iterator35.s();
              case 29:
                if ((_step35 = _iterator35.n()).done) {
                  _context58.next = 69;
                  break;
                }
                _response = _step35.value;
                _iterator36 = _createForOfIteratorHelper(certIDs);
                _context58.prev = 32;
                _iterator36.s();
              case 34:
                if ((_step36 = _iterator36.n()).done) {
                  _context58.next = 59;
                  break;
                }
                id = _step36.value;
                if (!_response.certID.isEqual(id)) {
                  _context58.next = 57;
                  break;
                }
                result.isForCertificate = true;
                _context58.prev = 38;
                _context58.t1 = _response.certStatus.idBlock.isConstructed;
                _context58.next = _context58.t1 === true ? 42 : _context58.t1 === false ? 44 : 52;
                break;
              case 42:
                if (_response.certStatus.idBlock.tagNumber === 1) result.status = 1;
                return _context58.abrupt("break", 52);
              case 44:
                _context58.t2 = _response.certStatus.idBlock.tagNumber;
                _context58.next = _context58.t2 === 0 ? 47 : _context58.t2 === 2 ? 49 : 51;
                break;
              case 47:
                result.status = 0;
                return _context58.abrupt("break", 51);
              case 49:
                result.status = 2;
                return _context58.abrupt("break", 51);
              case 51:
                return _context58.abrupt("break", 52);
              case 52:
                _context58.next = 56;
                break;
              case 54:
                _context58.prev = 54;
                _context58.t3 = _context58["catch"](38);
              case 56:
                return _context58.abrupt("return", result);
              case 57:
                _context58.next = 34;
                break;
              case 59:
                _context58.next = 64;
                break;
              case 61:
                _context58.prev = 61;
                _context58.t4 = _context58["catch"](32);
                _iterator36.e(_context58.t4);
              case 64:
                _context58.prev = 64;
                _iterator36.f();
                return _context58.finish(64);
              case 67:
                _context58.next = 29;
                break;
              case 69:
                _context58.next = 74;
                break;
              case 71:
                _context58.prev = 71;
                _context58.t5 = _context58["catch"](27);
                _iterator35.e(_context58.t5);
              case 74:
                _context58.prev = 74;
                _iterator35.f();
                return _context58.finish(74);
              case 77:
                return _context58.abrupt("return", result);
              case 78:
              case "end":
                return _context58.stop();
            }
          }, _callee58, this, [[5, 20, 23, 26], [27, 71, 74, 77], [32, 61, 64, 67], [38, 54]]);
        }));
        function getCertificateStatus(_x86, _x87) {
          return _getCertificateStatus.apply(this, arguments);
        }
        return getCertificateStatus;
      }()
    }, {
      key: "sign",
      value: function () {
        var _sign3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee59(privateKey) {
          var hashAlgorithm,
            crypto,
            signatureParams,
            algorithm,
            signature,
            _args59 = arguments;
          return _regeneratorRuntime().wrap(function _callee59$(_context59) {
            while (1) switch (_context59.prev = _context59.next) {
              case 0:
                hashAlgorithm = _args59.length > 1 && _args59[1] !== undefined ? _args59[1] : "SHA-1";
                crypto = _args59.length > 2 && _args59[2] !== undefined ? _args59[2] : getCrypto(true);
                if (privateKey) {
                  _context59.next = 4;
                  break;
                }
                throw new Error("Need to provide a private key for signing");
              case 4:
                _context59.next = 6;
                return crypto.getSignatureParameters(privateKey, hashAlgorithm);
              case 6:
                signatureParams = _context59.sent;
                algorithm = signatureParams.parameters.algorithm;
                if ("name" in algorithm) {
                  _context59.next = 10;
                  break;
                }
                throw new Error("Empty algorithm");
              case 10:
                this.signatureAlgorithm = signatureParams.signatureAlgorithm;
                this.tbsResponseData.tbsView = new Uint8Array(this.tbsResponseData.toSchema(true).toBER());
                _context59.next = 14;
                return crypto.signWithPrivateKey(this.tbsResponseData.tbsView, privateKey, {
                  algorithm: algorithm
                });
              case 14:
                signature = _context59.sent;
                this.signature = new BitString({
                  valueHex: signature
                });
              case 16:
              case "end":
                return _context59.stop();
            }
          }, _callee59, this);
        }));
        function sign(_x88) {
          return _sign3.apply(this, arguments);
        }
        return sign;
      }()
    }, {
      key: "verify",
      value: function () {
        var _verify6 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee60() {
          var params,
            crypto,
            signerCert,
            certIndex,
            trustedCerts,
            _iterator37,
            _step37,
            _step37$value,
            index,
            certificate,
            _iterator38,
            _step38,
            _step38$value,
            _index,
            cert,
            hash,
            additionalCerts,
            _iterator39,
            _step39,
            _cert2,
            caCert,
            certChain,
            verificationResult,
            _args60 = arguments;
          return _regeneratorRuntime().wrap(function _callee60$(_context60) {
            while (1) switch (_context60.prev = _context60.next) {
              case 0:
                params = _args60.length > 0 && _args60[0] !== undefined ? _args60[0] : {};
                crypto = _args60.length > 1 && _args60[1] !== undefined ? _args60[1] : getCrypto(true);
                signerCert = null;
                certIndex = -1;
                trustedCerts = params.trustedCerts || [];
                if (this.certs) {
                  _context60.next = 7;
                  break;
                }
                throw new Error("No certificates attached to the BasicOCSPResponse");
              case 7:
                _context60.t0 = true;
                _context60.next = _context60.t0 === this.tbsResponseData.responderID instanceof RelativeDistinguishedNames ? 10 : _context60.t0 === this.tbsResponseData.responderID instanceof OctetString ? 29 : 51;
                break;
              case 10:
                _iterator37 = _createForOfIteratorHelper(this.certs.entries());
                _context60.prev = 11;
                _iterator37.s();
              case 13:
                if ((_step37 = _iterator37.n()).done) {
                  _context60.next = 20;
                  break;
                }
                _step37$value = _slicedToArray(_step37.value, 2), index = _step37$value[0], certificate = _step37$value[1];
                if (!certificate.subject.isEqual(this.tbsResponseData.responderID)) {
                  _context60.next = 18;
                  break;
                }
                certIndex = index;
                return _context60.abrupt("break", 20);
              case 18:
                _context60.next = 13;
                break;
              case 20:
                _context60.next = 25;
                break;
              case 22:
                _context60.prev = 22;
                _context60.t1 = _context60["catch"](11);
                _iterator37.e(_context60.t1);
              case 25:
                _context60.prev = 25;
                _iterator37.f();
                return _context60.finish(25);
              case 28:
                return _context60.abrupt("break", 52);
              case 29:
                _iterator38 = _createForOfIteratorHelper(this.certs.entries());
                _context60.prev = 30;
                _iterator38.s();
              case 32:
                if ((_step38 = _iterator38.n()).done) {
                  _context60.next = 42;
                  break;
                }
                _step38$value = _slicedToArray(_step38.value, 2), _index = _step38$value[0], cert = _step38$value[1];
                _context60.next = 36;
                return crypto.digest({
                  name: "sha-1"
                }, cert.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView);
              case 36:
                hash = _context60.sent;
                if (!isEqualBuffer(hash, this.tbsResponseData.responderID.valueBlock.valueHex)) {
                  _context60.next = 40;
                  break;
                }
                certIndex = _index;
                return _context60.abrupt("break", 42);
              case 40:
                _context60.next = 32;
                break;
              case 42:
                _context60.next = 47;
                break;
              case 44:
                _context60.prev = 44;
                _context60.t2 = _context60["catch"](30);
                _iterator38.e(_context60.t2);
              case 47:
                _context60.prev = 47;
                _iterator38.f();
                return _context60.finish(47);
              case 50:
                return _context60.abrupt("break", 52);
              case 51:
                throw new Error("Wrong value for responderID");
              case 52:
                if (!(certIndex === -1)) {
                  _context60.next = 54;
                  break;
                }
                throw new Error("Correct certificate was not found in OCSP response");
              case 54:
                signerCert = this.certs[certIndex];
                additionalCerts = [signerCert];
                _iterator39 = _createForOfIteratorHelper(this.certs);
                _context60.prev = 57;
                _iterator39.s();
              case 59:
                if ((_step39 = _iterator39.n()).done) {
                  _context60.next = 67;
                  break;
                }
                _cert2 = _step39.value;
                _context60.next = 63;
                return checkCA(_cert2, signerCert);
              case 63:
                caCert = _context60.sent;
                if (caCert) {
                  additionalCerts.push(caCert);
                }
              case 65:
                _context60.next = 59;
                break;
              case 67:
                _context60.next = 72;
                break;
              case 69:
                _context60.prev = 69;
                _context60.t3 = _context60["catch"](57);
                _iterator39.e(_context60.t3);
              case 72:
                _context60.prev = 72;
                _iterator39.f();
                return _context60.finish(72);
              case 75:
                certChain = new CertificateChainValidationEngine({
                  certs: additionalCerts,
                  trustedCerts: trustedCerts
                });
                _context60.next = 78;
                return certChain.verify({}, crypto);
              case 78:
                verificationResult = _context60.sent;
                if (verificationResult.result) {
                  _context60.next = 81;
                  break;
                }
                throw new Error("Validation of signer's certificate failed");
              case 81:
                return _context60.abrupt("return", crypto.verifyWithPublicKey(this.tbsResponseData.tbsView, this.signature, this.certs[certIndex].subjectPublicKeyInfo, this.signatureAlgorithm));
              case 82:
              case "end":
                return _context60.stop();
            }
          }, _callee60, this, [[11, 22, 25, 28], [30, 44, 47, 50], [57, 69, 72, 75]]);
        }));
        function verify() {
          return _verify6.apply(this, arguments);
        }
        return verify;
      }()
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case TBS_RESPONSE_DATA:
            return new ResponseData();
          case SIGNATURE_ALGORITHM$3:
            return new AlgorithmIdentifier();
          case SIGNATURE$2:
            return new BitString();
          case CERTS$1:
            return [];
          default:
            return _superPropGet(BasicOCSPResponse, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case "type":
            {
              var comparisonResult = ResponseData.compareWithDefault("tbs", memberValue.tbs) && ResponseData.compareWithDefault("responderID", memberValue.responderID) && ResponseData.compareWithDefault("producedAt", memberValue.producedAt) && ResponseData.compareWithDefault("responses", memberValue.responses);
              if ("responseExtensions" in memberValue) comparisonResult = comparisonResult && ResponseData.compareWithDefault("responseExtensions", memberValue.responseExtensions);
              return comparisonResult;
            }
          case SIGNATURE_ALGORITHM$3:
            return memberValue.algorithmId === EMPTY_STRING && "algorithmParams" in memberValue === false;
          case SIGNATURE$2:
            return memberValue.isEqual(BasicOCSPResponse.defaultValues(memberName));
          case CERTS$1:
            return memberValue.length === 0;
          default:
            return _superPropGet(BasicOCSPResponse, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || BASIC_OCSP_RESPONSE,
          value: [ResponseData.schema(names.tbsResponseData || {
            names: {
              blockName: BASIC_OCSP_RESPONSE_TBS_RESPONSE_DATA
            }
          }), AlgorithmIdentifier.schema(names.signatureAlgorithm || {
            names: {
              blockName: BASIC_OCSP_RESPONSE_SIGNATURE_ALGORITHM
            }
          }), new BitString({
            name: names.signature || BASIC_OCSP_RESPONSE_SIGNATURE
          }), new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [new Sequence({
              value: [new Repeated({
                name: BASIC_OCSP_RESPONSE_CERTS,
                value: Certificate.schema(names.certs || {})
              })]
            })]
          })]
        });
      }
    }]);
  }(PkiObject);
  BasicOCSPResponse.CLASS_NAME = "BasicOCSPResponse";
  var TBS$1 = "tbs";
  var VERSION$6 = "version";
  var SUBJECT = "subject";
  var SPKI = "subjectPublicKeyInfo";
  var ATTRIBUTES$1 = "attributes";
  var SIGNATURE_ALGORITHM$2 = "signatureAlgorithm";
  var SIGNATURE_VALUE = "signatureValue";
  var CSR_INFO = "CertificationRequestInfo";
  var CSR_INFO_VERSION = "".concat(CSR_INFO, ".version");
  var CSR_INFO_SUBJECT = "".concat(CSR_INFO, ".subject");
  var CSR_INFO_SPKI = "".concat(CSR_INFO, ".subjectPublicKeyInfo");
  var CSR_INFO_ATTRS = "".concat(CSR_INFO, ".attributes");
  var CLEAR_PROPS$f = [CSR_INFO, CSR_INFO_VERSION, CSR_INFO_SUBJECT, CSR_INFO_SPKI, CSR_INFO_ATTRS, SIGNATURE_ALGORITHM$2, SIGNATURE_VALUE];
  function CertificationRequestInfo() {
    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var names = getParametersValue(parameters, "names", {});
    return new Sequence({
      name: names.CertificationRequestInfo || CSR_INFO,
      value: [new Integer({
        name: names.CertificationRequestInfoVersion || CSR_INFO_VERSION
      }), RelativeDistinguishedNames.schema(names.subject || {
        names: {
          blockName: CSR_INFO_SUBJECT
        }
      }), PublicKeyInfo.schema({
        names: {
          blockName: CSR_INFO_SPKI
        }
      }), new Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: [new Repeated({
          optional: true,
          name: names.CertificationRequestInfoAttributes || CSR_INFO_ATTRS,
          value: Attribute.schema(names.attributes || {})
        })]
      })]
    });
  }
  var CertificationRequest = function (_PkiObject96) {
    function CertificationRequest() {
      var _this159;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, CertificationRequest);
      _this159 = _callSuper(this, CertificationRequest);
      _this159.tbsView = new Uint8Array(getParametersValue(parameters, TBS$1, CertificationRequest.defaultValues(TBS$1)));
      _this159.version = getParametersValue(parameters, VERSION$6, CertificationRequest.defaultValues(VERSION$6));
      _this159.subject = getParametersValue(parameters, SUBJECT, CertificationRequest.defaultValues(SUBJECT));
      _this159.subjectPublicKeyInfo = getParametersValue(parameters, SPKI, CertificationRequest.defaultValues(SPKI));
      if (ATTRIBUTES$1 in parameters) {
        _this159.attributes = getParametersValue(parameters, ATTRIBUTES$1, CertificationRequest.defaultValues(ATTRIBUTES$1));
      }
      _this159.signatureAlgorithm = getParametersValue(parameters, SIGNATURE_ALGORITHM$2, CertificationRequest.defaultValues(SIGNATURE_ALGORITHM$2));
      _this159.signatureValue = getParametersValue(parameters, SIGNATURE_VALUE, CertificationRequest.defaultValues(SIGNATURE_VALUE));
      if (parameters.schema) {
        _this159.fromSchema(parameters.schema);
      }
      return _this159;
    }
    _inherits(CertificationRequest, _PkiObject96);
    return _createClass(CertificationRequest, [{
      key: "tbs",
      get: function get() {
        return BufferSourceConverter.toArrayBuffer(this.tbsView);
      },
      set: function set(value) {
        this.tbsView = new Uint8Array(value);
      }
    }, {
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$f);
        var asn1 = compareSchema(schema, schema, CertificationRequest.schema());
        AsnError.assertSchema(asn1, this.className);
        this.tbsView = asn1.result.CertificationRequestInfo.valueBeforeDecodeView;
        this.version = asn1.result[CSR_INFO_VERSION].valueBlock.valueDec;
        this.subject = new RelativeDistinguishedNames({
          schema: asn1.result[CSR_INFO_SUBJECT]
        });
        this.subjectPublicKeyInfo = new PublicKeyInfo({
          schema: asn1.result[CSR_INFO_SPKI]
        });
        if (CSR_INFO_ATTRS in asn1.result) {
          this.attributes = Array.from(asn1.result[CSR_INFO_ATTRS], function (element) {
            return new Attribute({
              schema: element
            });
          });
        }
        this.signatureAlgorithm = new AlgorithmIdentifier({
          schema: asn1.result.signatureAlgorithm
        });
        this.signatureValue = asn1.result.signatureValue;
      }
    }, {
      key: "encodeTBS",
      value: function encodeTBS() {
        var outputArray = [new Integer({
          value: this.version
        }), this.subject.toSchema(), this.subjectPublicKeyInfo.toSchema()];
        if (ATTRIBUTES$1 in this) {
          outputArray.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: Array.from(this.attributes || [], function (o) {
              return o.toSchema();
            })
          }));
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var encodeFlag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var tbsSchema;
        if (encodeFlag === false) {
          if (this.tbsView.byteLength === 0) {
            return CertificationRequest.schema();
          }
          var asn1 = _fromBER(this.tbsView);
          AsnError.assert(asn1, "PKCS#10 Certificate Request");
          tbsSchema = asn1.result;
        } else {
          tbsSchema = this.encodeTBS();
        }
        return new Sequence({
          value: [tbsSchema, this.signatureAlgorithm.toSchema(), this.signatureValue]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var object = {
          tbs: Convert.ToHex(this.tbsView),
          version: this.version,
          subject: this.subject.toJSON(),
          subjectPublicKeyInfo: this.subjectPublicKeyInfo.toJSON(),
          signatureAlgorithm: this.signatureAlgorithm.toJSON(),
          signatureValue: this.signatureValue.toJSON()
        };
        if (ATTRIBUTES$1 in this) {
          object.attributes = Array.from(this.attributes || [], function (o) {
            return o.toJSON();
          });
        }
        return object;
      }
    }, {
      key: "sign",
      value: function () {
        var _sign4 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee61(privateKey) {
          var hashAlgorithm,
            crypto,
            signatureParams,
            parameters,
            signature,
            _args61 = arguments;
          return _regeneratorRuntime().wrap(function _callee61$(_context61) {
            while (1) switch (_context61.prev = _context61.next) {
              case 0:
                hashAlgorithm = _args61.length > 1 && _args61[1] !== undefined ? _args61[1] : "SHA-1";
                crypto = _args61.length > 2 && _args61[2] !== undefined ? _args61[2] : getCrypto(true);
                if (privateKey) {
                  _context61.next = 4;
                  break;
                }
                throw new Error("Need to provide a private key for signing");
              case 4:
                _context61.next = 6;
                return crypto.getSignatureParameters(privateKey, hashAlgorithm);
              case 6:
                signatureParams = _context61.sent;
                parameters = signatureParams.parameters;
                this.signatureAlgorithm = signatureParams.signatureAlgorithm;
                this.tbsView = new Uint8Array(this.encodeTBS().toBER());
                _context61.next = 12;
                return crypto.signWithPrivateKey(this.tbsView, privateKey, parameters);
              case 12:
                signature = _context61.sent;
                this.signatureValue = new BitString({
                  valueHex: signature
                });
              case 14:
              case "end":
                return _context61.stop();
            }
          }, _callee61, this);
        }));
        function sign(_x89) {
          return _sign4.apply(this, arguments);
        }
        return sign;
      }()
    }, {
      key: "verify",
      value: function () {
        var _verify7 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee62() {
          var crypto,
            _args62 = arguments;
          return _regeneratorRuntime().wrap(function _callee62$(_context62) {
            while (1) switch (_context62.prev = _context62.next) {
              case 0:
                crypto = _args62.length > 0 && _args62[0] !== undefined ? _args62[0] : getCrypto(true);
                return _context62.abrupt("return", crypto.verifyWithPublicKey(this.tbsView, this.signatureValue, this.subjectPublicKeyInfo, this.signatureAlgorithm));
              case 2:
              case "end":
                return _context62.stop();
            }
          }, _callee62, this);
        }));
        function verify() {
          return _verify7.apply(this, arguments);
        }
        return verify;
      }()
    }, {
      key: "getPublicKey",
      value: function () {
        var _getPublicKey3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee63(parameters) {
          var crypto,
            _args63 = arguments;
          return _regeneratorRuntime().wrap(function _callee63$(_context63) {
            while (1) switch (_context63.prev = _context63.next) {
              case 0:
                crypto = _args63.length > 1 && _args63[1] !== undefined ? _args63[1] : getCrypto(true);
                return _context63.abrupt("return", crypto.getPublicKey(this.subjectPublicKeyInfo, this.signatureAlgorithm, parameters));
              case 2:
              case "end":
                return _context63.stop();
            }
          }, _callee63, this);
        }));
        function getPublicKey(_x90) {
          return _getPublicKey3.apply(this, arguments);
        }
        return getPublicKey;
      }()
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case TBS$1:
            return EMPTY_BUFFER;
          case VERSION$6:
            return 0;
          case SUBJECT:
            return new RelativeDistinguishedNames();
          case SPKI:
            return new PublicKeyInfo();
          case ATTRIBUTES$1:
            return [];
          case SIGNATURE_ALGORITHM$2:
            return new AlgorithmIdentifier();
          case SIGNATURE_VALUE:
            return new BitString();
          default:
            return _superPropGet(CertificationRequest, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          value: [CertificationRequestInfo(names.certificationRequestInfo || {}), new Sequence({
            name: names.signatureAlgorithm || SIGNATURE_ALGORITHM$2,
            value: [new ObjectIdentifier(), new Any({
              optional: true
            })]
          }), new BitString({
            name: names.signatureValue || SIGNATURE_VALUE
          })]
        });
      }
    }]);
  }(PkiObject);
  CertificationRequest.CLASS_NAME = "CertificationRequest";
  var DIGEST_ALGORITHM$1 = "digestAlgorithm";
  var DIGEST = "digest";
  var CLEAR_PROPS$e = [DIGEST_ALGORITHM$1, DIGEST];
  var DigestInfo = function (_PkiObject97) {
    function DigestInfo() {
      var _this160;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, DigestInfo);
      _this160 = _callSuper(this, DigestInfo);
      _this160.digestAlgorithm = getParametersValue(parameters, DIGEST_ALGORITHM$1, DigestInfo.defaultValues(DIGEST_ALGORITHM$1));
      _this160.digest = getParametersValue(parameters, DIGEST, DigestInfo.defaultValues(DIGEST));
      if (parameters.schema) {
        _this160.fromSchema(parameters.schema);
      }
      return _this160;
    }
    _inherits(DigestInfo, _PkiObject97);
    return _createClass(DigestInfo, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$e);
        var asn1 = compareSchema(schema, schema, DigestInfo.schema({
          names: {
            digestAlgorithm: {
              names: {
                blockName: DIGEST_ALGORITHM$1
              }
            },
            digest: DIGEST
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.digestAlgorithm = new AlgorithmIdentifier({
          schema: asn1.result.digestAlgorithm
        });
        this.digest = asn1.result.digest;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: [this.digestAlgorithm.toSchema(), this.digest]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          digestAlgorithm: this.digestAlgorithm.toJSON(),
          digest: this.digest.toJSON()
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case DIGEST_ALGORITHM$1:
            return new AlgorithmIdentifier();
          case DIGEST:
            return new OctetString();
          default:
            return _superPropGet(DigestInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case DIGEST_ALGORITHM$1:
            return AlgorithmIdentifier.compareWithDefault("algorithmId", memberValue.algorithmId) && "algorithmParams" in memberValue === false;
          case DIGEST:
            return memberValue.isEqual(DigestInfo.defaultValues(memberName));
          default:
            return _superPropGet(DigestInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [AlgorithmIdentifier.schema(names.digestAlgorithm || {
            names: {
              blockName: DIGEST_ALGORITHM$1
            }
          }), new OctetString({
            name: names.digest || DIGEST
          })]
        });
      }
    }]);
  }(PkiObject);
  DigestInfo.CLASS_NAME = "DigestInfo";
  var E_CONTENT_TYPE = "eContentType";
  var E_CONTENT = "eContent";
  var CLEAR_PROPS$d = [E_CONTENT_TYPE, E_CONTENT];
  var EncapsulatedContentInfo = function (_PkiObject98) {
    function EncapsulatedContentInfo() {
      var _this161;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, EncapsulatedContentInfo);
      _this161 = _callSuper(this, EncapsulatedContentInfo);
      _this161.eContentType = getParametersValue(parameters, E_CONTENT_TYPE, EncapsulatedContentInfo.defaultValues(E_CONTENT_TYPE));
      if (E_CONTENT in parameters) {
        _this161.eContent = getParametersValue(parameters, E_CONTENT, EncapsulatedContentInfo.defaultValues(E_CONTENT));
        if (_this161.eContent.idBlock.tagClass === 1 && _this161.eContent.idBlock.tagNumber === 4) {
          if (_this161.eContent.idBlock.isConstructed === false) {
            var constrString = new OctetString({
              idBlock: {
                isConstructed: true
              },
              isConstructed: true
            });
            var offset = 0;
            var viewHex = _this161.eContent.valueBlock.valueHexView.slice().buffer;
            var length = viewHex.byteLength;
            while (length > 0) {
              var pieceView = new Uint8Array(viewHex, offset, offset + 65536 > viewHex.byteLength ? viewHex.byteLength - offset : 65536);
              var _array = new ArrayBuffer(pieceView.length);
              var _view = new Uint8Array(_array);
              for (var i = 0; i < _view.length; i++) {
                _view[i] = pieceView[i];
              }
              constrString.valueBlock.value.push(new OctetString({
                valueHex: _array
              }));
              length -= pieceView.length;
              offset += pieceView.length;
            }
            _this161.eContent = constrString;
          }
        }
      }
      if (parameters.schema) {
        _this161.fromSchema(parameters.schema);
      }
      return _this161;
    }
    _inherits(EncapsulatedContentInfo, _PkiObject98);
    return _createClass(EncapsulatedContentInfo, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$d);
        var asn1 = compareSchema(schema, schema, EncapsulatedContentInfo.schema({
          names: {
            eContentType: E_CONTENT_TYPE,
            eContent: E_CONTENT
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.eContentType = asn1.result.eContentType.valueBlock.toString();
        if (E_CONTENT in asn1.result) this.eContent = asn1.result.eContent;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        outputArray.push(new ObjectIdentifier({
          value: this.eContentType
        }));
        if (this.eContent) {
          if (EncapsulatedContentInfo.compareWithDefault(E_CONTENT, this.eContent) === false) {
            outputArray.push(new Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [this.eContent]
            }));
          }
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          eContentType: this.eContentType
        };
        if (this.eContent && EncapsulatedContentInfo.compareWithDefault(E_CONTENT, this.eContent) === false) {
          res.eContent = this.eContent.toJSON();
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case E_CONTENT_TYPE:
            return EMPTY_STRING;
          case E_CONTENT:
            return new OctetString();
          default:
            return _superPropGet(EncapsulatedContentInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case E_CONTENT_TYPE:
            return memberValue === EMPTY_STRING;
          case E_CONTENT:
            {
              if (memberValue.idBlock.tagClass === 1 && memberValue.idBlock.tagNumber === 4) return memberValue.isEqual(EncapsulatedContentInfo.defaultValues(E_CONTENT));
              return false;
            }
          default:
            return _superPropGet(EncapsulatedContentInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new ObjectIdentifier({
            name: names.eContentType || EMPTY_STRING
          }), new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [new Any({
              name: names.eContent || EMPTY_STRING
            })]
          })]
        });
      }
    }]);
  }(PkiObject);
  EncapsulatedContentInfo.CLASS_NAME = "EncapsulatedContentInfo";
  var MAC = "mac";
  var MAC_SALT = "macSalt";
  var ITERATIONS = "iterations";
  var CLEAR_PROPS$c = [MAC, MAC_SALT, ITERATIONS];
  var MacData = function (_PkiObject99) {
    function MacData() {
      var _this162;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, MacData);
      _this162 = _callSuper(this, MacData);
      _this162.mac = getParametersValue(parameters, MAC, MacData.defaultValues(MAC));
      _this162.macSalt = getParametersValue(parameters, MAC_SALT, MacData.defaultValues(MAC_SALT));
      if (ITERATIONS in parameters) {
        _this162.iterations = getParametersValue(parameters, ITERATIONS, MacData.defaultValues(ITERATIONS));
      }
      if (parameters.schema) {
        _this162.fromSchema(parameters.schema);
      }
      return _this162;
    }
    _inherits(MacData, _PkiObject99);
    return _createClass(MacData, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$c);
        var asn1 = compareSchema(schema, schema, MacData.schema({
          names: {
            mac: {
              names: {
                blockName: MAC
              }
            },
            macSalt: MAC_SALT,
            iterations: ITERATIONS
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.mac = new DigestInfo({
          schema: asn1.result.mac
        });
        this.macSalt = asn1.result.macSalt;
        if (ITERATIONS in asn1.result) this.iterations = asn1.result.iterations.valueBlock.valueDec;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [this.mac.toSchema(), this.macSalt];
        if (this.iterations !== undefined) {
          outputArray.push(new Integer({
            value: this.iterations
          }));
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          mac: this.mac.toJSON(),
          macSalt: this.macSalt.toJSON()
        };
        if (this.iterations !== undefined) {
          res.iterations = this.iterations;
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case MAC:
            return new DigestInfo();
          case MAC_SALT:
            return new OctetString();
          case ITERATIONS:
            return 1;
          default:
            return _superPropGet(MacData, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case MAC:
            return DigestInfo.compareWithDefault("digestAlgorithm", memberValue.digestAlgorithm) && DigestInfo.compareWithDefault("digest", memberValue.digest);
          case MAC_SALT:
            return memberValue.isEqual(MacData.defaultValues(memberName));
          case ITERATIONS:
            return memberValue === MacData.defaultValues(memberName);
          default:
            return _superPropGet(MacData, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          optional: names.optional || true,
          value: [DigestInfo.schema(names.mac || {
            names: {
              blockName: MAC
            }
          }), new OctetString({
            name: names.macSalt || MAC_SALT
          }), new Integer({
            optional: true,
            name: names.iterations || ITERATIONS
          })]
        });
      }
    }]);
  }(PkiObject);
  MacData.CLASS_NAME = "MacData";
  var HASH_ALGORITHM = "hashAlgorithm";
  var HASHED_MESSAGE = "hashedMessage";
  var CLEAR_PROPS$b = [HASH_ALGORITHM, HASHED_MESSAGE];
  var MessageImprint = function (_PkiObject100) {
    function MessageImprint() {
      var _this163;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, MessageImprint);
      _this163 = _callSuper(this, MessageImprint);
      _this163.hashAlgorithm = getParametersValue(parameters, HASH_ALGORITHM, MessageImprint.defaultValues(HASH_ALGORITHM));
      _this163.hashedMessage = getParametersValue(parameters, HASHED_MESSAGE, MessageImprint.defaultValues(HASHED_MESSAGE));
      if (parameters.schema) {
        _this163.fromSchema(parameters.schema);
      }
      return _this163;
    }
    _inherits(MessageImprint, _PkiObject100);
    return _createClass(MessageImprint, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$b);
        var asn1 = compareSchema(schema, schema, MessageImprint.schema({
          names: {
            hashAlgorithm: {
              names: {
                blockName: HASH_ALGORITHM
              }
            },
            hashedMessage: HASHED_MESSAGE
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.hashAlgorithm = new AlgorithmIdentifier({
          schema: asn1.result.hashAlgorithm
        });
        this.hashedMessage = asn1.result.hashedMessage;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: [this.hashAlgorithm.toSchema(), this.hashedMessage]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          hashAlgorithm: this.hashAlgorithm.toJSON(),
          hashedMessage: this.hashedMessage.toJSON()
        };
      }
    }], [{
      key: "create",
      value: function () {
        var _create2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee64(hashAlgorithm, message) {
          var crypto,
            hashAlgorithmOID,
            hashedMessage,
            res,
            _args64 = arguments;
          return _regeneratorRuntime().wrap(function _callee64$(_context64) {
            while (1) switch (_context64.prev = _context64.next) {
              case 0:
                crypto = _args64.length > 2 && _args64[2] !== undefined ? _args64[2] : getCrypto(true);
                hashAlgorithmOID = crypto.getOIDByAlgorithm({
                  name: hashAlgorithm
                }, true, "hashAlgorithm");
                _context64.next = 4;
                return crypto.digest(hashAlgorithm, message);
              case 4:
                hashedMessage = _context64.sent;
                res = new MessageImprint({
                  hashAlgorithm: new AlgorithmIdentifier({
                    algorithmId: hashAlgorithmOID,
                    algorithmParams: new Null()
                  }),
                  hashedMessage: new OctetString({
                    valueHex: hashedMessage
                  })
                });
                return _context64.abrupt("return", res);
              case 7:
              case "end":
                return _context64.stop();
            }
          }, _callee64);
        }));
        function create(_x91, _x92) {
          return _create2.apply(this, arguments);
        }
        return create;
      }()
    }, {
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case HASH_ALGORITHM:
            return new AlgorithmIdentifier();
          case HASHED_MESSAGE:
            return new OctetString();
          default:
            return _superPropGet(MessageImprint, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case HASH_ALGORITHM:
            return memberValue.algorithmId === EMPTY_STRING && "algorithmParams" in memberValue === false;
          case HASHED_MESSAGE:
            return memberValue.isEqual(MessageImprint.defaultValues(memberName)) === 0;
          default:
            return _superPropGet(MessageImprint, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [AlgorithmIdentifier.schema(names.hashAlgorithm || {}), new OctetString({
            name: names.hashedMessage || EMPTY_STRING
          })]
        });
      }
    }]);
  }(PkiObject);
  MessageImprint.CLASS_NAME = "MessageImprint";
  var REQ_CERT = "reqCert";
  var SINGLE_REQUEST_EXTENSIONS = "singleRequestExtensions";
  var CLEAR_PROPS$a = [REQ_CERT, SINGLE_REQUEST_EXTENSIONS];
  var Request = function (_PkiObject101) {
    function Request() {
      var _this164;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Request);
      _this164 = _callSuper(this, Request);
      _this164.reqCert = getParametersValue(parameters, REQ_CERT, Request.defaultValues(REQ_CERT));
      if (SINGLE_REQUEST_EXTENSIONS in parameters) {
        _this164.singleRequestExtensions = getParametersValue(parameters, SINGLE_REQUEST_EXTENSIONS, Request.defaultValues(SINGLE_REQUEST_EXTENSIONS));
      }
      if (parameters.schema) {
        _this164.fromSchema(parameters.schema);
      }
      return _this164;
    }
    _inherits(Request, _PkiObject101);
    return _createClass(Request, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$a);
        var asn1 = compareSchema(schema, schema, Request.schema({
          names: {
            reqCert: {
              names: {
                blockName: REQ_CERT
              }
            },
            extensions: {
              names: {
                blockName: SINGLE_REQUEST_EXTENSIONS
              }
            }
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.reqCert = new CertID({
          schema: asn1.result.reqCert
        });
        if (SINGLE_REQUEST_EXTENSIONS in asn1.result) {
          this.singleRequestExtensions = Array.from(asn1.result.singleRequestExtensions.valueBlock.value, function (element) {
            return new Extension({
              schema: element
            });
          });
        }
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        outputArray.push(this.reqCert.toSchema());
        if (this.singleRequestExtensions) {
          outputArray.push(new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [new Sequence({
              value: Array.from(this.singleRequestExtensions, function (o) {
                return o.toSchema();
              })
            })]
          }));
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          reqCert: this.reqCert.toJSON()
        };
        if (this.singleRequestExtensions) {
          res.singleRequestExtensions = Array.from(this.singleRequestExtensions, function (o) {
            return o.toJSON();
          });
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case REQ_CERT:
            return new CertID();
          case SINGLE_REQUEST_EXTENSIONS:
            return [];
          default:
            return _superPropGet(Request, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case REQ_CERT:
            return memberValue.isEqual(Request.defaultValues(memberName));
          case SINGLE_REQUEST_EXTENSIONS:
            return memberValue.length === 0;
          default:
            return _superPropGet(Request, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [CertID.schema(names.reqCert || {}), new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [Extension.schema(names.extensions || {
              names: {
                blockName: names.singleRequestExtensions || EMPTY_STRING
              }
            })]
          })]
        });
      }
    }]);
  }(PkiObject);
  Request.CLASS_NAME = "Request";
  var TBS = "tbs";
  var VERSION$5 = "version";
  var REQUESTOR_NAME = "requestorName";
  var REQUEST_LIST = "requestList";
  var REQUEST_EXTENSIONS = "requestExtensions";
  var TBS_REQUEST$1 = "TBSRequest";
  var TBS_REQUEST_VERSION = "".concat(TBS_REQUEST$1, ".").concat(VERSION$5);
  var TBS_REQUEST_REQUESTOR_NAME = "".concat(TBS_REQUEST$1, ".").concat(REQUESTOR_NAME);
  var TBS_REQUEST_REQUESTS = "".concat(TBS_REQUEST$1, ".requests");
  var TBS_REQUEST_REQUEST_EXTENSIONS = "".concat(TBS_REQUEST$1, ".").concat(REQUEST_EXTENSIONS);
  var CLEAR_PROPS$9 = [TBS_REQUEST$1, TBS_REQUEST_VERSION, TBS_REQUEST_REQUESTOR_NAME, TBS_REQUEST_REQUESTS, TBS_REQUEST_REQUEST_EXTENSIONS];
  var TBSRequest = function (_PkiObject102) {
    function TBSRequest() {
      var _this165;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, TBSRequest);
      _this165 = _callSuper(this, TBSRequest);
      _this165.tbsView = new Uint8Array(getParametersValue(parameters, TBS, TBSRequest.defaultValues(TBS)));
      if (VERSION$5 in parameters) {
        _this165.version = getParametersValue(parameters, VERSION$5, TBSRequest.defaultValues(VERSION$5));
      }
      if (REQUESTOR_NAME in parameters) {
        _this165.requestorName = getParametersValue(parameters, REQUESTOR_NAME, TBSRequest.defaultValues(REQUESTOR_NAME));
      }
      _this165.requestList = getParametersValue(parameters, REQUEST_LIST, TBSRequest.defaultValues(REQUEST_LIST));
      if (REQUEST_EXTENSIONS in parameters) {
        _this165.requestExtensions = getParametersValue(parameters, REQUEST_EXTENSIONS, TBSRequest.defaultValues(REQUEST_EXTENSIONS));
      }
      if (parameters.schema) {
        _this165.fromSchema(parameters.schema);
      }
      return _this165;
    }
    _inherits(TBSRequest, _PkiObject102);
    return _createClass(TBSRequest, [{
      key: "tbs",
      get: function get() {
        return BufferSourceConverter.toArrayBuffer(this.tbsView);
      },
      set: function set(value) {
        this.tbsView = new Uint8Array(value);
      }
    }, {
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$9);
        var asn1 = compareSchema(schema, schema, TBSRequest.schema());
        AsnError.assertSchema(asn1, this.className);
        this.tbsView = asn1.result.TBSRequest.valueBeforeDecodeView;
        if (TBS_REQUEST_VERSION in asn1.result) this.version = asn1.result[TBS_REQUEST_VERSION].valueBlock.valueDec;
        if (TBS_REQUEST_REQUESTOR_NAME in asn1.result) this.requestorName = new GeneralName({
          schema: asn1.result[TBS_REQUEST_REQUESTOR_NAME]
        });
        this.requestList = Array.from(asn1.result[TBS_REQUEST_REQUESTS], function (element) {
          return new Request({
            schema: element
          });
        });
        if (TBS_REQUEST_REQUEST_EXTENSIONS in asn1.result) this.requestExtensions = Array.from(asn1.result[TBS_REQUEST_REQUEST_EXTENSIONS].valueBlock.value, function (element) {
          return new Extension({
            schema: element
          });
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var encodeFlag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var tbsSchema;
        if (encodeFlag === false) {
          if (this.tbsView.byteLength === 0) return TBSRequest.schema();
          var asn1 = _fromBER(this.tbsView);
          AsnError.assert(asn1, "TBS Request");
          if (!(asn1.result instanceof Sequence)) {
            throw new Error("ASN.1 result should be SEQUENCE");
          }
          tbsSchema = asn1.result;
        } else {
          var outputArray = [];
          if (this.version !== undefined) {
            outputArray.push(new Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [new Integer({
                value: this.version
              })]
            }));
          }
          if (this.requestorName) {
            outputArray.push(new Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: [this.requestorName.toSchema()]
            }));
          }
          outputArray.push(new Sequence({
            value: Array.from(this.requestList, function (o) {
              return o.toSchema();
            })
          }));
          if (this.requestExtensions) {
            outputArray.push(new Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 2
              },
              value: [new Sequence({
                value: Array.from(this.requestExtensions, function (o) {
                  return o.toSchema();
                })
              })]
            }));
          }
          tbsSchema = new Sequence({
            value: outputArray
          });
        }
        return tbsSchema;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {};
        if (this.version != undefined) res.version = this.version;
        if (this.requestorName) {
          res.requestorName = this.requestorName.toJSON();
        }
        res.requestList = Array.from(this.requestList, function (o) {
          return o.toJSON();
        });
        if (this.requestExtensions) {
          res.requestExtensions = Array.from(this.requestExtensions, function (o) {
            return o.toJSON();
          });
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case TBS:
            return EMPTY_BUFFER;
          case VERSION$5:
            return 0;
          case REQUESTOR_NAME:
            return new GeneralName();
          case REQUEST_LIST:
          case REQUEST_EXTENSIONS:
            return [];
          default:
            return _superPropGet(TBSRequest, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case TBS:
            return memberValue.byteLength === 0;
          case VERSION$5:
            return memberValue === TBSRequest.defaultValues(memberName);
          case REQUESTOR_NAME:
            return memberValue.type === GeneralName.defaultValues("type") && Object.keys(memberValue.value).length === 0;
          case REQUEST_LIST:
          case REQUEST_EXTENSIONS:
            return memberValue.length === 0;
          default:
            return _superPropGet(TBSRequest, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || TBS_REQUEST$1,
          value: [new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [new Integer({
              name: names.TBSRequestVersion || TBS_REQUEST_VERSION
            })]
          }), new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: [GeneralName.schema(names.requestorName || {
              names: {
                blockName: TBS_REQUEST_REQUESTOR_NAME
              }
            })]
          }), new Sequence({
            name: names.requestList || "TBSRequest.requestList",
            value: [new Repeated({
              name: names.requests || TBS_REQUEST_REQUESTS,
              value: Request.schema(names.requestNames || {})
            })]
          }), new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 2
            },
            value: [Extensions.schema(names.extensions || {
              names: {
                blockName: names.requestExtensions || TBS_REQUEST_REQUEST_EXTENSIONS
              }
            })]
          })]
        });
      }
    }]);
  }(PkiObject);
  TBSRequest.CLASS_NAME = "TBSRequest";
  var SIGNATURE_ALGORITHM$1 = "signatureAlgorithm";
  var SIGNATURE$1 = "signature";
  var CERTS = "certs";
  var Signature$1 = function (_PkiObject103) {
    function Signature() {
      var _this166;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Signature);
      _this166 = _callSuper(this, Signature);
      _this166.signatureAlgorithm = getParametersValue(parameters, SIGNATURE_ALGORITHM$1, Signature.defaultValues(SIGNATURE_ALGORITHM$1));
      _this166.signature = getParametersValue(parameters, SIGNATURE$1, Signature.defaultValues(SIGNATURE$1));
      if (CERTS in parameters) {
        _this166.certs = getParametersValue(parameters, CERTS, Signature.defaultValues(CERTS));
      }
      if (parameters.schema) {
        _this166.fromSchema(parameters.schema);
      }
      return _this166;
    }
    _inherits(Signature, _PkiObject103);
    return _createClass(Signature, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, [SIGNATURE_ALGORITHM$1, SIGNATURE$1, CERTS]);
        var asn1 = compareSchema(schema, schema, Signature.schema({
          names: {
            signatureAlgorithm: {
              names: {
                blockName: SIGNATURE_ALGORITHM$1
              }
            },
            signature: SIGNATURE$1,
            certs: CERTS
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.signatureAlgorithm = new AlgorithmIdentifier({
          schema: asn1.result.signatureAlgorithm
        });
        this.signature = asn1.result.signature;
        if (CERTS in asn1.result) this.certs = Array.from(asn1.result.certs, function (element) {
          return new Certificate({
            schema: element
          });
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        outputArray.push(this.signatureAlgorithm.toSchema());
        outputArray.push(this.signature);
        if (this.certs) {
          outputArray.push(new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [new Sequence({
              value: Array.from(this.certs, function (o) {
                return o.toSchema();
              })
            })]
          }));
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          signatureAlgorithm: this.signatureAlgorithm.toJSON(),
          signature: this.signature.toJSON()
        };
        if (this.certs) {
          res.certs = Array.from(this.certs, function (o) {
            return o.toJSON();
          });
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case SIGNATURE_ALGORITHM$1:
            return new AlgorithmIdentifier();
          case SIGNATURE$1:
            return new BitString();
          case CERTS:
            return [];
          default:
            return _superPropGet(Signature, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case SIGNATURE_ALGORITHM$1:
            return memberValue.algorithmId === EMPTY_STRING && "algorithmParams" in memberValue === false;
          case SIGNATURE$1:
            return memberValue.isEqual(Signature.defaultValues(memberName));
          case CERTS:
            return memberValue.length === 0;
          default:
            return _superPropGet(Signature, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [AlgorithmIdentifier.schema(names.signatureAlgorithm || {}), new BitString({
            name: names.signature || EMPTY_STRING
          }), new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [new Sequence({
              value: [new Repeated({
                name: names.certs || EMPTY_STRING,
                value: Certificate.schema({})
              })]
            })]
          })]
        });
      }
    }]);
  }(PkiObject);
  Signature$1.CLASS_NAME = "Signature";
  var TBS_REQUEST = "tbsRequest";
  var OPTIONAL_SIGNATURE = "optionalSignature";
  var CLEAR_PROPS$8 = [TBS_REQUEST, OPTIONAL_SIGNATURE];
  var OCSPRequest = function (_PkiObject104) {
    function OCSPRequest() {
      var _this167;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, OCSPRequest);
      _this167 = _callSuper(this, OCSPRequest);
      _this167.tbsRequest = getParametersValue(parameters, TBS_REQUEST, OCSPRequest.defaultValues(TBS_REQUEST));
      if (OPTIONAL_SIGNATURE in parameters) {
        _this167.optionalSignature = getParametersValue(parameters, OPTIONAL_SIGNATURE, OCSPRequest.defaultValues(OPTIONAL_SIGNATURE));
      }
      if (parameters.schema) {
        _this167.fromSchema(parameters.schema);
      }
      return _this167;
    }
    _inherits(OCSPRequest, _PkiObject104);
    return _createClass(OCSPRequest, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$8);
        var asn1 = compareSchema(schema, schema, OCSPRequest.schema());
        AsnError.assertSchema(asn1, this.className);
        this.tbsRequest = new TBSRequest({
          schema: asn1.result.tbsRequest
        });
        if (OPTIONAL_SIGNATURE in asn1.result) this.optionalSignature = new Signature$1({
          schema: asn1.result.optionalSignature
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var encodeFlag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var outputArray = [];
        outputArray.push(this.tbsRequest.toSchema(encodeFlag));
        if (this.optionalSignature) outputArray.push(new Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [this.optionalSignature.toSchema()]
        }));
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          tbsRequest: this.tbsRequest.toJSON()
        };
        if (this.optionalSignature) {
          res.optionalSignature = this.optionalSignature.toJSON();
        }
        return res;
      }
    }, {
      key: "createForCertificate",
      value: function () {
        var _createForCertificate2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee65(certificate, parameters) {
          var crypto,
            certID,
            _args65 = arguments;
          return _regeneratorRuntime().wrap(function _callee65$(_context65) {
            while (1) switch (_context65.prev = _context65.next) {
              case 0:
                crypto = _args65.length > 2 && _args65[2] !== undefined ? _args65[2] : getCrypto(true);
                certID = new CertID();
                _context65.next = 4;
                return certID.createForCertificate(certificate, parameters, crypto);
              case 4:
                this.tbsRequest.requestList.push(new Request({
                  reqCert: certID
                }));
              case 5:
              case "end":
                return _context65.stop();
            }
          }, _callee65, this);
        }));
        function createForCertificate(_x93, _x94) {
          return _createForCertificate2.apply(this, arguments);
        }
        return createForCertificate;
      }()
    }, {
      key: "sign",
      value: function () {
        var _sign5 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee66(privateKey) {
          var hashAlgorithm,
            crypto,
            signatureParams,
            parameters,
            tbs,
            signature,
            _args66 = arguments;
          return _regeneratorRuntime().wrap(function _callee66$(_context66) {
            while (1) switch (_context66.prev = _context66.next) {
              case 0:
                hashAlgorithm = _args66.length > 1 && _args66[1] !== undefined ? _args66[1] : "SHA-1";
                crypto = _args66.length > 2 && _args66[2] !== undefined ? _args66[2] : getCrypto(true);
                ParameterError.assertEmpty(privateKey, "privateKey", "OCSPRequest.sign method");
                if (this.optionalSignature) {
                  _context66.next = 5;
                  break;
                }
                throw new Error("Need to create \"optionalSignature\" field before signing");
              case 5:
                _context66.next = 7;
                return crypto.getSignatureParameters(privateKey, hashAlgorithm);
              case 7:
                signatureParams = _context66.sent;
                parameters = signatureParams.parameters;
                this.optionalSignature.signatureAlgorithm = signatureParams.signatureAlgorithm;
                tbs = this.tbsRequest.toSchema(true).toBER(false);
                _context66.next = 13;
                return crypto.signWithPrivateKey(tbs, privateKey, parameters);
              case 13:
                signature = _context66.sent;
                this.optionalSignature.signature = new BitString({
                  valueHex: signature
                });
              case 15:
              case "end":
                return _context66.stop();
            }
          }, _callee66, this);
        }));
        function sign(_x95) {
          return _sign5.apply(this, arguments);
        }
        return sign;
      }()
    }, {
      key: "verify",
      value: function verify() {}
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case TBS_REQUEST:
            return new TBSRequest();
          case OPTIONAL_SIGNATURE:
            return new Signature$1();
          default:
            return _superPropGet(OCSPRequest, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case TBS_REQUEST:
            return TBSRequest.compareWithDefault("tbs", memberValue.tbs) && TBSRequest.compareWithDefault("version", memberValue.version) && TBSRequest.compareWithDefault("requestorName", memberValue.requestorName) && TBSRequest.compareWithDefault("requestList", memberValue.requestList) && TBSRequest.compareWithDefault("requestExtensions", memberValue.requestExtensions);
          case OPTIONAL_SIGNATURE:
            return Signature$1.compareWithDefault("signatureAlgorithm", memberValue.signatureAlgorithm) && Signature$1.compareWithDefault("signature", memberValue.signature) && Signature$1.compareWithDefault("certs", memberValue.certs);
          default:
            return _superPropGet(OCSPRequest, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || "OCSPRequest",
          value: [TBSRequest.schema(names.tbsRequest || {
            names: {
              blockName: TBS_REQUEST
            }
          }), new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [Signature$1.schema(names.optionalSignature || {
              names: {
                blockName: OPTIONAL_SIGNATURE
              }
            })]
          })]
        });
      }
    }]);
  }(PkiObject);
  OCSPRequest.CLASS_NAME = "OCSPRequest";
  var RESPONSE_TYPE = "responseType";
  var RESPONSE = "response";
  var CLEAR_PROPS$7 = [RESPONSE_TYPE, RESPONSE];
  var ResponseBytes = function (_PkiObject105) {
    function ResponseBytes() {
      var _this168;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, ResponseBytes);
      _this168 = _callSuper(this, ResponseBytes);
      _this168.responseType = getParametersValue(parameters, RESPONSE_TYPE, ResponseBytes.defaultValues(RESPONSE_TYPE));
      _this168.response = getParametersValue(parameters, RESPONSE, ResponseBytes.defaultValues(RESPONSE));
      if (parameters.schema) {
        _this168.fromSchema(parameters.schema);
      }
      return _this168;
    }
    _inherits(ResponseBytes, _PkiObject105);
    return _createClass(ResponseBytes, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$7);
        var asn1 = compareSchema(schema, schema, ResponseBytes.schema({
          names: {
            responseType: RESPONSE_TYPE,
            response: RESPONSE
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.responseType = asn1.result.responseType.valueBlock.toString();
        this.response = asn1.result.response;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        return new Sequence({
          value: [new ObjectIdentifier({
            value: this.responseType
          }), this.response]
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          responseType: this.responseType,
          response: this.response.toJSON()
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case RESPONSE_TYPE:
            return EMPTY_STRING;
          case RESPONSE:
            return new OctetString();
          default:
            return _superPropGet(ResponseBytes, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case RESPONSE_TYPE:
            return memberValue === EMPTY_STRING;
          case RESPONSE:
            return memberValue.isEqual(ResponseBytes.defaultValues(memberName));
          default:
            return _superPropGet(ResponseBytes, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new ObjectIdentifier({
            name: names.responseType || EMPTY_STRING
          }), new OctetString({
            name: names.response || EMPTY_STRING
          })]
        });
      }
    }]);
  }(PkiObject);
  ResponseBytes.CLASS_NAME = "ResponseBytes";
  var RESPONSE_STATUS = "responseStatus";
  var RESPONSE_BYTES = "responseBytes";
  var OCSPResponse = function (_PkiObject106) {
    function OCSPResponse() {
      var _this169;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, OCSPResponse);
      _this169 = _callSuper(this, OCSPResponse);
      _this169.responseStatus = getParametersValue(parameters, RESPONSE_STATUS, OCSPResponse.defaultValues(RESPONSE_STATUS));
      if (RESPONSE_BYTES in parameters) {
        _this169.responseBytes = getParametersValue(parameters, RESPONSE_BYTES, OCSPResponse.defaultValues(RESPONSE_BYTES));
      }
      if (parameters.schema) {
        _this169.fromSchema(parameters.schema);
      }
      return _this169;
    }
    _inherits(OCSPResponse, _PkiObject106);
    return _createClass(OCSPResponse, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, [RESPONSE_STATUS, RESPONSE_BYTES]);
        var asn1 = compareSchema(schema, schema, OCSPResponse.schema());
        AsnError.assertSchema(asn1, this.className);
        this.responseStatus = asn1.result.responseStatus;
        if (RESPONSE_BYTES in asn1.result) this.responseBytes = new ResponseBytes({
          schema: asn1.result.responseBytes
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        outputArray.push(this.responseStatus);
        if (this.responseBytes) {
          outputArray.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [this.responseBytes.toSchema()]
          }));
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          responseStatus: this.responseStatus.toJSON()
        };
        if (this.responseBytes) {
          res.responseBytes = this.responseBytes.toJSON();
        }
        return res;
      }
    }, {
      key: "getCertificateStatus",
      value: function () {
        var _getCertificateStatus2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee67(certificate, issuerCertificate) {
          var crypto,
            basicResponse,
            result,
            asn1Basic,
            _args67 = arguments;
          return _regeneratorRuntime().wrap(function _callee67$(_context67) {
            while (1) switch (_context67.prev = _context67.next) {
              case 0:
                crypto = _args67.length > 2 && _args67[2] !== undefined ? _args67[2] : getCrypto(true);
                result = {
                  isForCertificate: false,
                  status: 2
                };
                if (this.responseBytes) {
                  _context67.next = 4;
                  break;
                }
                return _context67.abrupt("return", result);
              case 4:
                if (!(this.responseBytes.responseType !== id_PKIX_OCSP_Basic)) {
                  _context67.next = 6;
                  break;
                }
                return _context67.abrupt("return", result);
              case 6:
                _context67.prev = 6;
                asn1Basic = _fromBER(this.responseBytes.response.valueBlock.valueHexView);
                AsnError.assert(asn1Basic, "Basic OCSP response");
                basicResponse = new BasicOCSPResponse({
                  schema: asn1Basic.result
                });
                _context67.next = 15;
                break;
              case 12:
                _context67.prev = 12;
                _context67.t0 = _context67["catch"](6);
                return _context67.abrupt("return", result);
              case 15:
                return _context67.abrupt("return", basicResponse.getCertificateStatus(certificate, issuerCertificate, crypto));
              case 16:
              case "end":
                return _context67.stop();
            }
          }, _callee67, this, [[6, 12]]);
        }));
        function getCertificateStatus(_x96, _x97) {
          return _getCertificateStatus2.apply(this, arguments);
        }
        return getCertificateStatus;
      }()
    }, {
      key: "sign",
      value: function () {
        var _sign6 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee68(privateKey, hashAlgorithm) {
          var crypto,
            _a,
            basicResponse,
            _args68 = arguments;
          return _regeneratorRuntime().wrap(function _callee68$(_context68) {
            while (1) switch (_context68.prev = _context68.next) {
              case 0:
                crypto = _args68.length > 2 && _args68[2] !== undefined ? _args68[2] : getCrypto(true);
                if (!(this.responseBytes && this.responseBytes.responseType === id_PKIX_OCSP_Basic)) {
                  _context68.next = 4;
                  break;
                }
                basicResponse = BasicOCSPResponse.fromBER(this.responseBytes.response.valueBlock.valueHexView);
                return _context68.abrupt("return", basicResponse.sign(privateKey, hashAlgorithm, crypto));
              case 4:
                throw new Error("Unknown ResponseBytes type: ".concat(((_a = this.responseBytes) === null || _a === void 0 ? void 0 : _a.responseType) || "Unknown"));
              case 5:
              case "end":
                return _context68.stop();
            }
          }, _callee68, this);
        }));
        function sign(_x98, _x99) {
          return _sign6.apply(this, arguments);
        }
        return sign;
      }()
    }, {
      key: "verify",
      value: function () {
        var _verify8 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee69() {
          var issuerCertificate,
            crypto,
            _a,
            basicResponse,
            _args69 = arguments;
          return _regeneratorRuntime().wrap(function _callee69$(_context69) {
            while (1) switch (_context69.prev = _context69.next) {
              case 0:
                issuerCertificate = _args69.length > 0 && _args69[0] !== undefined ? _args69[0] : null;
                crypto = _args69.length > 1 && _args69[1] !== undefined ? _args69[1] : getCrypto(true);
                if (!(RESPONSE_BYTES in this === false)) {
                  _context69.next = 4;
                  break;
                }
                throw new Error("Empty ResponseBytes field");
              case 4:
                if (!(this.responseBytes && this.responseBytes.responseType === id_PKIX_OCSP_Basic)) {
                  _context69.next = 8;
                  break;
                }
                basicResponse = BasicOCSPResponse.fromBER(this.responseBytes.response.valueBlock.valueHexView);
                if (issuerCertificate !== null) {
                  if (!basicResponse.certs) {
                    basicResponse.certs = [];
                  }
                  basicResponse.certs.push(issuerCertificate);
                }
                return _context69.abrupt("return", basicResponse.verify({}, crypto));
              case 8:
                throw new Error("Unknown ResponseBytes type: ".concat(((_a = this.responseBytes) === null || _a === void 0 ? void 0 : _a.responseType) || "Unknown"));
              case 9:
              case "end":
                return _context69.stop();
            }
          }, _callee69, this);
        }));
        function verify() {
          return _verify8.apply(this, arguments);
        }
        return verify;
      }()
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case RESPONSE_STATUS:
            return new Enumerated();
          case RESPONSE_BYTES:
            return new ResponseBytes();
          default:
            return _superPropGet(OCSPResponse, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case RESPONSE_STATUS:
            return memberValue.isEqual(OCSPResponse.defaultValues(memberName));
          case RESPONSE_BYTES:
            return ResponseBytes.compareWithDefault("responseType", memberValue.responseType) && ResponseBytes.compareWithDefault("response", memberValue.response);
          default:
            return _superPropGet(OCSPResponse, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || "OCSPResponse",
          value: [new Enumerated({
            name: names.responseStatus || RESPONSE_STATUS
          }), new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [ResponseBytes.schema(names.responseBytes || {
              names: {
                blockName: RESPONSE_BYTES
              }
            })]
          })]
        });
      }
    }]);
  }(PkiObject);
  OCSPResponse.CLASS_NAME = "OCSPResponse";
  var TYPE = "type";
  var ATTRIBUTES = "attributes";
  var ENCODED_VALUE = "encodedValue";
  var CLEAR_PROPS$6 = [ATTRIBUTES];
  var SignedAndUnsignedAttributes = function (_PkiObject107) {
    function SignedAndUnsignedAttributes() {
      var _this170;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, SignedAndUnsignedAttributes);
      _this170 = _callSuper(this, SignedAndUnsignedAttributes);
      _this170.type = getParametersValue(parameters, TYPE, SignedAndUnsignedAttributes.defaultValues(TYPE));
      _this170.attributes = getParametersValue(parameters, ATTRIBUTES, SignedAndUnsignedAttributes.defaultValues(ATTRIBUTES));
      _this170.encodedValue = getParametersValue(parameters, ENCODED_VALUE, SignedAndUnsignedAttributes.defaultValues(ENCODED_VALUE));
      if (parameters.schema) {
        _this170.fromSchema(parameters.schema);
      }
      return _this170;
    }
    _inherits(SignedAndUnsignedAttributes, _PkiObject107);
    return _createClass(SignedAndUnsignedAttributes, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$6);
        var asn1 = compareSchema(schema, schema, SignedAndUnsignedAttributes.schema({
          names: {
            tagNumber: this.type,
            attributes: ATTRIBUTES
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.type = asn1.result.idBlock.tagNumber;
        this.encodedValue = BufferSourceConverter.toArrayBuffer(asn1.result.valueBeforeDecodeView);
        var encodedView = new Uint8Array(this.encodedValue);
        encodedView[0] = 0x31;
        if (ATTRIBUTES in asn1.result === false) {
          if (this.type === 0) throw new Error("Wrong structure of SignedUnsignedAttributes");else return;
        }
        this.attributes = Array.from(asn1.result.attributes, function (element) {
          return new Attribute({
            schema: element
          });
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        if (SignedAndUnsignedAttributes.compareWithDefault(TYPE, this.type) || SignedAndUnsignedAttributes.compareWithDefault(ATTRIBUTES, this.attributes)) throw new Error("Incorrectly initialized \"SignedAndUnsignedAttributes\" class");
        return new Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: this.type
          },
          value: Array.from(this.attributes, function (o) {
            return o.toSchema();
          })
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        if (SignedAndUnsignedAttributes.compareWithDefault(TYPE, this.type) || SignedAndUnsignedAttributes.compareWithDefault(ATTRIBUTES, this.attributes)) throw new Error("Incorrectly initialized \"SignedAndUnsignedAttributes\" class");
        return {
          type: this.type,
          attributes: Array.from(this.attributes, function (o) {
            return o.toJSON();
          })
        };
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case TYPE:
            return -1;
          case ATTRIBUTES:
            return [];
          case ENCODED_VALUE:
            return EMPTY_BUFFER;
          default:
            return _superPropGet(SignedAndUnsignedAttributes, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case TYPE:
            return memberValue === SignedAndUnsignedAttributes.defaultValues(TYPE);
          case ATTRIBUTES:
            return memberValue.length === 0;
          case ENCODED_VALUE:
            return memberValue.byteLength === 0;
          default:
            return _superPropGet(SignedAndUnsignedAttributes, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Constructed({
          name: names.blockName || EMPTY_STRING,
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: names.tagNumber || 0
          },
          value: [new Repeated({
            name: names.attributes || EMPTY_STRING,
            value: Attribute.schema()
          })]
        });
      }
    }]);
  }(PkiObject);
  SignedAndUnsignedAttributes.CLASS_NAME = "SignedAndUnsignedAttributes";
  var VERSION$4 = "version";
  var SID = "sid";
  var DIGEST_ALGORITHM = "digestAlgorithm";
  var SIGNED_ATTRS = "signedAttrs";
  var SIGNATURE_ALGORITHM = "signatureAlgorithm";
  var SIGNATURE = "signature";
  var UNSIGNED_ATTRS = "unsignedAttrs";
  var SIGNER_INFO = "SignerInfo";
  var SIGNER_INFO_VERSION = "".concat(SIGNER_INFO, ".").concat(VERSION$4);
  var SIGNER_INFO_SID = "".concat(SIGNER_INFO, ".").concat(SID);
  var SIGNER_INFO_DIGEST_ALGORITHM = "".concat(SIGNER_INFO, ".").concat(DIGEST_ALGORITHM);
  var SIGNER_INFO_SIGNED_ATTRS = "".concat(SIGNER_INFO, ".").concat(SIGNED_ATTRS);
  var SIGNER_INFO_SIGNATURE_ALGORITHM = "".concat(SIGNER_INFO, ".").concat(SIGNATURE_ALGORITHM);
  var SIGNER_INFO_SIGNATURE = "".concat(SIGNER_INFO, ".").concat(SIGNATURE);
  var SIGNER_INFO_UNSIGNED_ATTRS = "".concat(SIGNER_INFO, ".").concat(UNSIGNED_ATTRS);
  var CLEAR_PROPS$5 = [SIGNER_INFO_VERSION, SIGNER_INFO_SID, SIGNER_INFO_DIGEST_ALGORITHM, SIGNER_INFO_SIGNED_ATTRS, SIGNER_INFO_SIGNATURE_ALGORITHM, SIGNER_INFO_SIGNATURE, SIGNER_INFO_UNSIGNED_ATTRS];
  var SignerInfo = function (_PkiObject108) {
    function SignerInfo() {
      var _this171;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, SignerInfo);
      _this171 = _callSuper(this, SignerInfo);
      _this171.version = getParametersValue(parameters, VERSION$4, SignerInfo.defaultValues(VERSION$4));
      _this171.sid = getParametersValue(parameters, SID, SignerInfo.defaultValues(SID));
      _this171.digestAlgorithm = getParametersValue(parameters, DIGEST_ALGORITHM, SignerInfo.defaultValues(DIGEST_ALGORITHM));
      if (SIGNED_ATTRS in parameters) {
        _this171.signedAttrs = getParametersValue(parameters, SIGNED_ATTRS, SignerInfo.defaultValues(SIGNED_ATTRS));
      }
      _this171.signatureAlgorithm = getParametersValue(parameters, SIGNATURE_ALGORITHM, SignerInfo.defaultValues(SIGNATURE_ALGORITHM));
      _this171.signature = getParametersValue(parameters, SIGNATURE, SignerInfo.defaultValues(SIGNATURE));
      if (UNSIGNED_ATTRS in parameters) {
        _this171.unsignedAttrs = getParametersValue(parameters, UNSIGNED_ATTRS, SignerInfo.defaultValues(UNSIGNED_ATTRS));
      }
      if (parameters.schema) {
        _this171.fromSchema(parameters.schema);
      }
      return _this171;
    }
    _inherits(SignerInfo, _PkiObject108);
    return _createClass(SignerInfo, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$5);
        var asn1 = compareSchema(schema, schema, SignerInfo.schema());
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result[SIGNER_INFO_VERSION].valueBlock.valueDec;
        var currentSid = asn1.result[SIGNER_INFO_SID];
        if (currentSid.idBlock.tagClass === 1) this.sid = new IssuerAndSerialNumber({
          schema: currentSid
        });else this.sid = currentSid;
        this.digestAlgorithm = new AlgorithmIdentifier({
          schema: asn1.result[SIGNER_INFO_DIGEST_ALGORITHM]
        });
        if (SIGNER_INFO_SIGNED_ATTRS in asn1.result) this.signedAttrs = new SignedAndUnsignedAttributes({
          type: 0,
          schema: asn1.result[SIGNER_INFO_SIGNED_ATTRS]
        });
        this.signatureAlgorithm = new AlgorithmIdentifier({
          schema: asn1.result[SIGNER_INFO_SIGNATURE_ALGORITHM]
        });
        this.signature = asn1.result[SIGNER_INFO_SIGNATURE];
        if (SIGNER_INFO_UNSIGNED_ATTRS in asn1.result) this.unsignedAttrs = new SignedAndUnsignedAttributes({
          type: 1,
          schema: asn1.result[SIGNER_INFO_UNSIGNED_ATTRS]
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        if (SignerInfo.compareWithDefault(SID, this.sid)) throw new Error("Incorrectly initialized \"SignerInfo\" class");
        var outputArray = [];
        outputArray.push(new Integer({
          value: this.version
        }));
        if (this.sid instanceof IssuerAndSerialNumber) outputArray.push(this.sid.toSchema());else outputArray.push(this.sid);
        outputArray.push(this.digestAlgorithm.toSchema());
        if (this.signedAttrs) {
          if (SignerInfo.compareWithDefault(SIGNED_ATTRS, this.signedAttrs) === false) outputArray.push(this.signedAttrs.toSchema());
        }
        outputArray.push(this.signatureAlgorithm.toSchema());
        outputArray.push(this.signature);
        if (this.unsignedAttrs) {
          if (SignerInfo.compareWithDefault(UNSIGNED_ATTRS, this.unsignedAttrs) === false) outputArray.push(this.unsignedAttrs.toSchema());
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        if (SignerInfo.compareWithDefault(SID, this.sid)) {
          throw new Error("Incorrectly initialized \"SignerInfo\" class");
        }
        var res = {
          version: this.version,
          digestAlgorithm: this.digestAlgorithm.toJSON(),
          signatureAlgorithm: this.signatureAlgorithm.toJSON(),
          signature: this.signature.toJSON()
        };
        if (!(this.sid instanceof Any)) res.sid = this.sid.toJSON();
        if (this.signedAttrs && SignerInfo.compareWithDefault(SIGNED_ATTRS, this.signedAttrs) === false) {
          res.signedAttrs = this.signedAttrs.toJSON();
        }
        if (this.unsignedAttrs && SignerInfo.compareWithDefault(UNSIGNED_ATTRS, this.unsignedAttrs) === false) {
          res.unsignedAttrs = this.unsignedAttrs.toJSON();
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case VERSION$4:
            return 0;
          case SID:
            return new Any();
          case DIGEST_ALGORITHM:
            return new AlgorithmIdentifier();
          case SIGNED_ATTRS:
            return new SignedAndUnsignedAttributes({
              type: 0
            });
          case SIGNATURE_ALGORITHM:
            return new AlgorithmIdentifier();
          case SIGNATURE:
            return new OctetString();
          case UNSIGNED_ATTRS:
            return new SignedAndUnsignedAttributes({
              type: 1
            });
          default:
            return _superPropGet(SignerInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VERSION$4:
            return SignerInfo.defaultValues(VERSION$4) === memberValue;
          case SID:
            return memberValue instanceof Any;
          case DIGEST_ALGORITHM:
            if (memberValue instanceof AlgorithmIdentifier === false) return false;
            return memberValue.isEqual(SignerInfo.defaultValues(DIGEST_ALGORITHM));
          case SIGNED_ATTRS:
            return SignedAndUnsignedAttributes.compareWithDefault("type", memberValue.type) && SignedAndUnsignedAttributes.compareWithDefault("attributes", memberValue.attributes) && SignedAndUnsignedAttributes.compareWithDefault("encodedValue", memberValue.encodedValue);
          case SIGNATURE_ALGORITHM:
            if (memberValue instanceof AlgorithmIdentifier === false) return false;
            return memberValue.isEqual(SignerInfo.defaultValues(SIGNATURE_ALGORITHM));
          case SIGNATURE:
          case UNSIGNED_ATTRS:
            return SignedAndUnsignedAttributes.compareWithDefault("type", memberValue.type) && SignedAndUnsignedAttributes.compareWithDefault("attributes", memberValue.attributes) && SignedAndUnsignedAttributes.compareWithDefault("encodedValue", memberValue.encodedValue);
          default:
            return _superPropGet(SignerInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: SIGNER_INFO,
          value: [new Integer({
            name: names.version || SIGNER_INFO_VERSION
          }), new Choice({
            value: [IssuerAndSerialNumber.schema(names.sidSchema || {
              names: {
                blockName: SIGNER_INFO_SID
              }
            }), new Choice({
              value: [new Constructed({
                optional: true,
                name: names.sid || SIGNER_INFO_SID,
                idBlock: {
                  tagClass: 3,
                  tagNumber: 0
                },
                value: [new OctetString()]
              }), new Primitive({
                optional: true,
                name: names.sid || SIGNER_INFO_SID,
                idBlock: {
                  tagClass: 3,
                  tagNumber: 0
                }
              })]
            })]
          }), AlgorithmIdentifier.schema(names.digestAlgorithm || {
            names: {
              blockName: SIGNER_INFO_DIGEST_ALGORITHM
            }
          }), SignedAndUnsignedAttributes.schema(names.signedAttrs || {
            names: {
              blockName: SIGNER_INFO_SIGNED_ATTRS,
              tagNumber: 0
            }
          }), AlgorithmIdentifier.schema(names.signatureAlgorithm || {
            names: {
              blockName: SIGNER_INFO_SIGNATURE_ALGORITHM
            }
          }), new OctetString({
            name: names.signature || SIGNER_INFO_SIGNATURE
          }), SignedAndUnsignedAttributes.schema(names.unsignedAttrs || {
            names: {
              blockName: SIGNER_INFO_UNSIGNED_ATTRS,
              tagNumber: 1
            }
          })]
        });
      }
    }]);
  }(PkiObject);
  SignerInfo.CLASS_NAME = "SignerInfo";
  var VERSION$3 = "version";
  var POLICY = "policy";
  var MESSAGE_IMPRINT$1 = "messageImprint";
  var SERIAL_NUMBER = "serialNumber";
  var GEN_TIME = "genTime";
  var ORDERING = "ordering";
  var NONCE$1 = "nonce";
  var ACCURACY = "accuracy";
  var TSA = "tsa";
  var EXTENSIONS$1 = "extensions";
  var TST_INFO = "TSTInfo";
  var TST_INFO_VERSION = "".concat(TST_INFO, ".").concat(VERSION$3);
  var TST_INFO_POLICY = "".concat(TST_INFO, ".").concat(POLICY);
  var TST_INFO_MESSAGE_IMPRINT = "".concat(TST_INFO, ".").concat(MESSAGE_IMPRINT$1);
  var TST_INFO_SERIAL_NUMBER = "".concat(TST_INFO, ".").concat(SERIAL_NUMBER);
  var TST_INFO_GEN_TIME = "".concat(TST_INFO, ".").concat(GEN_TIME);
  var TST_INFO_ACCURACY = "".concat(TST_INFO, ".").concat(ACCURACY);
  var TST_INFO_ORDERING = "".concat(TST_INFO, ".").concat(ORDERING);
  var TST_INFO_NONCE = "".concat(TST_INFO, ".").concat(NONCE$1);
  var TST_INFO_TSA = "".concat(TST_INFO, ".").concat(TSA);
  var TST_INFO_EXTENSIONS = "".concat(TST_INFO, ".").concat(EXTENSIONS$1);
  var CLEAR_PROPS$4 = [TST_INFO_VERSION, TST_INFO_POLICY, TST_INFO_MESSAGE_IMPRINT, TST_INFO_SERIAL_NUMBER, TST_INFO_GEN_TIME, TST_INFO_ACCURACY, TST_INFO_ORDERING, TST_INFO_NONCE, TST_INFO_TSA, TST_INFO_EXTENSIONS];
  var TSTInfo = function (_PkiObject109) {
    function TSTInfo() {
      var _this172;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, TSTInfo);
      _this172 = _callSuper(this, TSTInfo);
      _this172.version = getParametersValue(parameters, VERSION$3, TSTInfo.defaultValues(VERSION$3));
      _this172.policy = getParametersValue(parameters, POLICY, TSTInfo.defaultValues(POLICY));
      _this172.messageImprint = getParametersValue(parameters, MESSAGE_IMPRINT$1, TSTInfo.defaultValues(MESSAGE_IMPRINT$1));
      _this172.serialNumber = getParametersValue(parameters, SERIAL_NUMBER, TSTInfo.defaultValues(SERIAL_NUMBER));
      _this172.genTime = getParametersValue(parameters, GEN_TIME, TSTInfo.defaultValues(GEN_TIME));
      if (ACCURACY in parameters) {
        _this172.accuracy = getParametersValue(parameters, ACCURACY, TSTInfo.defaultValues(ACCURACY));
      }
      if (ORDERING in parameters) {
        _this172.ordering = getParametersValue(parameters, ORDERING, TSTInfo.defaultValues(ORDERING));
      }
      if (NONCE$1 in parameters) {
        _this172.nonce = getParametersValue(parameters, NONCE$1, TSTInfo.defaultValues(NONCE$1));
      }
      if (TSA in parameters) {
        _this172.tsa = getParametersValue(parameters, TSA, TSTInfo.defaultValues(TSA));
      }
      if (EXTENSIONS$1 in parameters) {
        _this172.extensions = getParametersValue(parameters, EXTENSIONS$1, TSTInfo.defaultValues(EXTENSIONS$1));
      }
      if (parameters.schema) {
        _this172.fromSchema(parameters.schema);
      }
      return _this172;
    }
    _inherits(TSTInfo, _PkiObject109);
    return _createClass(TSTInfo, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$4);
        var asn1 = compareSchema(schema, schema, TSTInfo.schema());
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result[TST_INFO_VERSION].valueBlock.valueDec;
        this.policy = asn1.result[TST_INFO_POLICY].valueBlock.toString();
        this.messageImprint = new MessageImprint({
          schema: asn1.result[TST_INFO_MESSAGE_IMPRINT]
        });
        this.serialNumber = asn1.result[TST_INFO_SERIAL_NUMBER];
        this.genTime = asn1.result[TST_INFO_GEN_TIME].toDate();
        if (TST_INFO_ACCURACY in asn1.result) this.accuracy = new Accuracy({
          schema: asn1.result[TST_INFO_ACCURACY]
        });
        if (TST_INFO_ORDERING in asn1.result) this.ordering = asn1.result[TST_INFO_ORDERING].valueBlock.value;
        if (TST_INFO_NONCE in asn1.result) this.nonce = asn1.result[TST_INFO_NONCE];
        if (TST_INFO_TSA in asn1.result) this.tsa = new GeneralName({
          schema: asn1.result[TST_INFO_TSA]
        });
        if (TST_INFO_EXTENSIONS in asn1.result) this.extensions = Array.from(asn1.result[TST_INFO_EXTENSIONS], function (element) {
          return new Extension({
            schema: element
          });
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        outputArray.push(new Integer({
          value: this.version
        }));
        outputArray.push(new ObjectIdentifier({
          value: this.policy
        }));
        outputArray.push(this.messageImprint.toSchema());
        outputArray.push(this.serialNumber);
        outputArray.push(new GeneralizedTime({
          valueDate: this.genTime
        }));
        if (this.accuracy) outputArray.push(this.accuracy.toSchema());
        if (this.ordering !== undefined) outputArray.push(new Boolean$1({
          value: this.ordering
        }));
        if (this.nonce) outputArray.push(this.nonce);
        if (this.tsa) {
          outputArray.push(new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [this.tsa.toSchema()]
          }));
        }
        if (this.extensions) {
          outputArray.push(new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: Array.from(this.extensions, function (o) {
              return o.toSchema();
            })
          }));
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          version: this.version,
          policy: this.policy,
          messageImprint: this.messageImprint.toJSON(),
          serialNumber: this.serialNumber.toJSON(),
          genTime: this.genTime
        };
        if (this.accuracy) res.accuracy = this.accuracy.toJSON();
        if (this.ordering !== undefined) res.ordering = this.ordering;
        if (this.nonce) res.nonce = this.nonce.toJSON();
        if (this.tsa) res.tsa = this.tsa.toJSON();
        if (this.extensions) res.extensions = Array.from(this.extensions, function (o) {
          return o.toJSON();
        });
        return res;
      }
    }, {
      key: "verify",
      value: function () {
        var _verify9 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee70(params) {
          var crypto,
            data,
            shaAlgorithm,
            hash,
            _args70 = arguments;
          return _regeneratorRuntime().wrap(function _callee70$(_context70) {
            while (1) switch (_context70.prev = _context70.next) {
              case 0:
                crypto = _args70.length > 1 && _args70[1] !== undefined ? _args70[1] : getCrypto(true);
                if (params.data) {
                  _context70.next = 3;
                  break;
                }
                throw new Error("\"data\" is a mandatory attribute for TST_INFO verification");
              case 3:
                data = params.data;
                if (!params.notBefore) {
                  _context70.next = 7;
                  break;
                }
                if (!(this.genTime < params.notBefore)) {
                  _context70.next = 7;
                  break;
                }
                throw new Error("Generation time for TSTInfo object is less than notBefore value");
              case 7:
                if (!params.notAfter) {
                  _context70.next = 10;
                  break;
                }
                if (!(this.genTime > params.notAfter)) {
                  _context70.next = 10;
                  break;
                }
                throw new Error("Generation time for TSTInfo object is more than notAfter value");
              case 10:
                shaAlgorithm = crypto.getAlgorithmByOID(this.messageImprint.hashAlgorithm.algorithmId, true, "MessageImprint.hashAlgorithm");
                _context70.next = 13;
                return crypto.digest(shaAlgorithm.name, new Uint8Array(data));
              case 13:
                hash = _context70.sent;
                return _context70.abrupt("return", BufferSourceConverter.isEqual(hash, this.messageImprint.hashedMessage.valueBlock.valueHexView));
              case 15:
              case "end":
                return _context70.stop();
            }
          }, _callee70, this);
        }));
        function verify(_x100) {
          return _verify9.apply(this, arguments);
        }
        return verify;
      }()
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case VERSION$3:
            return 0;
          case POLICY:
            return EMPTY_STRING;
          case MESSAGE_IMPRINT$1:
            return new MessageImprint();
          case SERIAL_NUMBER:
            return new Integer();
          case GEN_TIME:
            return new Date(0, 0, 0);
          case ACCURACY:
            return new Accuracy();
          case ORDERING:
            return false;
          case NONCE$1:
            return new Integer();
          case TSA:
            return new GeneralName();
          case EXTENSIONS$1:
            return [];
          default:
            return _superPropGet(TSTInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VERSION$3:
          case POLICY:
          case GEN_TIME:
          case ORDERING:
            return memberValue === TSTInfo.defaultValues(ORDERING);
          case MESSAGE_IMPRINT$1:
            return MessageImprint.compareWithDefault(HASH_ALGORITHM, memberValue.hashAlgorithm) && MessageImprint.compareWithDefault(HASHED_MESSAGE, memberValue.hashedMessage);
          case SERIAL_NUMBER:
          case NONCE$1:
            return memberValue.isEqual(TSTInfo.defaultValues(NONCE$1));
          case ACCURACY:
            return Accuracy.compareWithDefault(SECONDS, memberValue.seconds) && Accuracy.compareWithDefault(MILLIS, memberValue.millis) && Accuracy.compareWithDefault(MICROS, memberValue.micros);
          case TSA:
            return GeneralName.compareWithDefault(TYPE$4, memberValue.type) && GeneralName.compareWithDefault(VALUE$5, memberValue.value);
          case EXTENSIONS$1:
            return memberValue.length === 0;
          default:
            return _superPropGet(TSTInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || TST_INFO,
          value: [new Integer({
            name: names.version || TST_INFO_VERSION
          }), new ObjectIdentifier({
            name: names.policy || TST_INFO_POLICY
          }), MessageImprint.schema(names.messageImprint || {
            names: {
              blockName: TST_INFO_MESSAGE_IMPRINT
            }
          }), new Integer({
            name: names.serialNumber || TST_INFO_SERIAL_NUMBER
          }), new GeneralizedTime({
            name: names.genTime || TST_INFO_GEN_TIME
          }), Accuracy.schema(names.accuracy || {
            names: {
              blockName: TST_INFO_ACCURACY
            }
          }), new Boolean$1({
            name: names.ordering || TST_INFO_ORDERING,
            optional: true
          }), new Integer({
            name: names.nonce || TST_INFO_NONCE,
            optional: true
          }), new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [GeneralName.schema(names.tsa || {
              names: {
                blockName: TST_INFO_TSA
              }
            })]
          }), new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: [new Repeated({
              name: names.extensions || TST_INFO_EXTENSIONS,
              value: Extension.schema(names.extension || {})
            })]
          })]
        });
      }
    }]);
  }(PkiObject);
  TSTInfo.CLASS_NAME = "TSTInfo";
  var VERSION$2 = "version";
  var DIGEST_ALGORITHMS = "digestAlgorithms";
  var ENCAP_CONTENT_INFO = "encapContentInfo";
  var CERTIFICATES = "certificates";
  var CRLS = "crls";
  var SIGNER_INFOS = "signerInfos";
  var OCSPS = "ocsps";
  var SIGNED_DATA = "SignedData";
  var SIGNED_DATA_VERSION = "".concat(SIGNED_DATA, ".").concat(VERSION$2);
  var SIGNED_DATA_DIGEST_ALGORITHMS = "".concat(SIGNED_DATA, ".").concat(DIGEST_ALGORITHMS);
  var SIGNED_DATA_ENCAP_CONTENT_INFO = "".concat(SIGNED_DATA, ".").concat(ENCAP_CONTENT_INFO);
  var SIGNED_DATA_CERTIFICATES = "".concat(SIGNED_DATA, ".").concat(CERTIFICATES);
  var SIGNED_DATA_CRLS = "".concat(SIGNED_DATA, ".").concat(CRLS);
  var SIGNED_DATA_SIGNER_INFOS = "".concat(SIGNED_DATA, ".").concat(SIGNER_INFOS);
  var CLEAR_PROPS$3 = [SIGNED_DATA_VERSION, SIGNED_DATA_DIGEST_ALGORITHMS, SIGNED_DATA_ENCAP_CONTENT_INFO, SIGNED_DATA_CERTIFICATES, SIGNED_DATA_CRLS, SIGNED_DATA_SIGNER_INFOS];
  var SignedDataVerifyError = function (_Error3) {
    function SignedDataVerifyError(_ref44) {
      var _this173;
      var message = _ref44.message,
        _ref44$code = _ref44.code,
        code = _ref44$code === void 0 ? 0 : _ref44$code,
        _ref44$date = _ref44.date,
        date = _ref44$date === void 0 ? new Date() : _ref44$date,
        _ref44$signatureVerif = _ref44.signatureVerified,
        signatureVerified = _ref44$signatureVerif === void 0 ? null : _ref44$signatureVerif,
        _ref44$signerCertific = _ref44.signerCertificate,
        signerCertificate = _ref44$signerCertific === void 0 ? null : _ref44$signerCertific,
        _ref44$signerCertific2 = _ref44.signerCertificateVerified,
        signerCertificateVerified = _ref44$signerCertific2 === void 0 ? null : _ref44$signerCertific2,
        _ref44$timestampSeria = _ref44.timestampSerial,
        timestampSerial = _ref44$timestampSeria === void 0 ? null : _ref44$timestampSeria,
        _ref44$certificatePat = _ref44.certificatePath,
        certificatePath = _ref44$certificatePat === void 0 ? [] : _ref44$certificatePat;
      _classCallCheck(this, SignedDataVerifyError);
      _this173 = _callSuper(this, SignedDataVerifyError, [message]);
      _this173.name = "SignedDataVerifyError";
      _this173.date = date;
      _this173.code = code;
      _this173.timestampSerial = timestampSerial;
      _this173.signatureVerified = signatureVerified;
      _this173.signerCertificate = signerCertificate;
      _this173.signerCertificateVerified = signerCertificateVerified;
      _this173.certificatePath = certificatePath;
      return _this173;
    }
    _inherits(SignedDataVerifyError, _Error3);
    return _createClass(SignedDataVerifyError);
  }(_wrapNativeSuper(Error));
  var SignedData = function (_PkiObject110) {
    function SignedData() {
      var _this174;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, SignedData);
      _this174 = _callSuper(this, SignedData);
      _this174.version = getParametersValue(parameters, VERSION$2, SignedData.defaultValues(VERSION$2));
      _this174.digestAlgorithms = getParametersValue(parameters, DIGEST_ALGORITHMS, SignedData.defaultValues(DIGEST_ALGORITHMS));
      _this174.encapContentInfo = getParametersValue(parameters, ENCAP_CONTENT_INFO, SignedData.defaultValues(ENCAP_CONTENT_INFO));
      if (CERTIFICATES in parameters) {
        _this174.certificates = getParametersValue(parameters, CERTIFICATES, SignedData.defaultValues(CERTIFICATES));
      }
      if (CRLS in parameters) {
        _this174.crls = getParametersValue(parameters, CRLS, SignedData.defaultValues(CRLS));
      }
      if (OCSPS in parameters) {
        _this174.ocsps = getParametersValue(parameters, OCSPS, SignedData.defaultValues(OCSPS));
      }
      _this174.signerInfos = getParametersValue(parameters, SIGNER_INFOS, SignedData.defaultValues(SIGNER_INFOS));
      if (parameters.schema) {
        _this174.fromSchema(parameters.schema);
      }
      return _this174;
    }
    _inherits(SignedData, _PkiObject110);
    return _createClass(SignedData, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$3);
        var asn1 = compareSchema(schema, schema, SignedData.schema());
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result[SIGNED_DATA_VERSION].valueBlock.valueDec;
        if (SIGNED_DATA_DIGEST_ALGORITHMS in asn1.result) this.digestAlgorithms = Array.from(asn1.result[SIGNED_DATA_DIGEST_ALGORITHMS], function (algorithm) {
          return new AlgorithmIdentifier({
            schema: algorithm
          });
        });
        this.encapContentInfo = new EncapsulatedContentInfo({
          schema: asn1.result[SIGNED_DATA_ENCAP_CONTENT_INFO]
        });
        if (SIGNED_DATA_CERTIFICATES in asn1.result) {
          var certificateSet = new CertificateSet({
            schema: new Set({
              value: asn1.result[SIGNED_DATA_CERTIFICATES].valueBlock.value
            })
          });
          this.certificates = certificateSet.certificates.slice(0);
        }
        if (SIGNED_DATA_CRLS in asn1.result) {
          this.crls = Array.from(asn1.result[SIGNED_DATA_CRLS], function (crl) {
            if (crl.idBlock.tagClass === 1) return new CertificateRevocationList({
              schema: crl
            });
            crl.idBlock.tagClass = 1;
            crl.idBlock.tagNumber = 16;
            return new OtherRevocationInfoFormat({
              schema: crl
            });
          });
        }
        if (SIGNED_DATA_SIGNER_INFOS in asn1.result) this.signerInfos = Array.from(asn1.result[SIGNED_DATA_SIGNER_INFOS], function (signerInfoSchema) {
          return new SignerInfo({
            schema: signerInfoSchema
          });
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var encodeFlag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var outputArray = [];
        if (this.certificates && this.certificates.length && this.certificates.some(function (o) {
          return o instanceof OtherCertificateFormat;
        }) || this.crls && this.crls.length && this.crls.some(function (o) {
          return o instanceof OtherRevocationInfoFormat;
        })) {
          this.version = 5;
        } else if (this.certificates && this.certificates.length && this.certificates.some(function (o) {
          return o instanceof AttributeCertificateV2;
        })) {
          this.version = 4;
        } else if (this.certificates && this.certificates.length && this.certificates.some(function (o) {
          return o instanceof AttributeCertificateV1;
        }) || this.signerInfos.some(function (o) {
          return o.version === 3;
        }) || this.encapContentInfo.eContentType !== SignedData.ID_DATA) {
          this.version = 3;
        } else {
          this.version = 1;
        }
        outputArray.push(new Integer({
          value: this.version
        }));
        outputArray.push(new Set({
          value: Array.from(this.digestAlgorithms, function (algorithm) {
            return algorithm.toSchema();
          })
        }));
        outputArray.push(this.encapContentInfo.toSchema());
        if (this.certificates) {
          var certificateSet = new CertificateSet({
            certificates: this.certificates
          });
          var certificateSetSchema = certificateSet.toSchema();
          outputArray.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: certificateSetSchema.valueBlock.value
          }));
        }
        if (this.crls) {
          outputArray.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: Array.from(this.crls, function (crl) {
              if (crl instanceof OtherRevocationInfoFormat) {
                var crlSchema = crl.toSchema();
                crlSchema.idBlock.tagClass = 3;
                crlSchema.idBlock.tagNumber = 1;
                return crlSchema;
              }
              return crl.toSchema(encodeFlag);
            })
          }));
        }
        outputArray.push(new Set({
          value: Array.from(this.signerInfos, function (signerInfo) {
            return signerInfo.toSchema();
          })
        }));
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          version: this.version,
          digestAlgorithms: Array.from(this.digestAlgorithms, function (algorithm) {
            return algorithm.toJSON();
          }),
          encapContentInfo: this.encapContentInfo.toJSON(),
          signerInfos: Array.from(this.signerInfos, function (signerInfo) {
            return signerInfo.toJSON();
          })
        };
        if (this.certificates) {
          res.certificates = Array.from(this.certificates, function (certificate) {
            return certificate.toJSON();
          });
        }
        if (this.crls) {
          res.crls = Array.from(this.crls, function (crl) {
            return crl.toJSON();
          });
        }
        return res;
      }
    }, {
      key: "verify",
      value: function () {
        var _verify10 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee71() {
          var _ref45,
            _ref45$signer,
            signer,
            _ref45$data,
            data,
            _ref45$trustedCerts,
            trustedCerts,
            _ref45$checkDate,
            checkDate,
            _ref45$checkChain,
            checkChain,
            _ref45$passedWhenNotR,
            passedWhenNotRevValues,
            _ref45$extendedMode,
            extendedMode,
            _ref45$findOrigin,
            findOrigin,
            _ref45$findIssuer,
            findIssuer,
            crypto,
            signerCert,
            timestampSerial,
            messageDigestValue,
            shaAlgorithm,
            certificatePath,
            signerInfo,
            _iterator40,
            _step40,
            certificate,
            sid,
            keyId,
            _iterator41,
            _step41,
            _certificate,
            digest,
            tstInfo,
            certs,
            chainParams,
            chainEngine,
            _iterator42,
            _step42,
            crl,
            _chainEngine$ocsps,
            verificationResult,
            signerInfoHashAlgorithm,
            eContent,
            foundContentType,
            foundMessageDigest,
            _iterator43,
            _step43,
            attribute,
            messageDigest,
            verifyResult,
            _args71 = arguments;
          return _regeneratorRuntime().wrap(function _callee71$(_context71) {
            while (1) switch (_context71.prev = _context71.next) {
              case 0:
                _ref45 = _args71.length > 0 && _args71[0] !== undefined ? _args71[0] : {}, _ref45$signer = _ref45.signer, signer = _ref45$signer === void 0 ? -1 : _ref45$signer, _ref45$data = _ref45.data, data = _ref45$data === void 0 ? EMPTY_BUFFER : _ref45$data, _ref45$trustedCerts = _ref45.trustedCerts, trustedCerts = _ref45$trustedCerts === void 0 ? [] : _ref45$trustedCerts, _ref45$checkDate = _ref45.checkDate, checkDate = _ref45$checkDate === void 0 ? new Date() : _ref45$checkDate, _ref45$checkChain = _ref45.checkChain, checkChain = _ref45$checkChain === void 0 ? false : _ref45$checkChain, _ref45$passedWhenNotR = _ref45.passedWhenNotRevValues, passedWhenNotRevValues = _ref45$passedWhenNotR === void 0 ? false : _ref45$passedWhenNotR, _ref45$extendedMode = _ref45.extendedMode, extendedMode = _ref45$extendedMode === void 0 ? false : _ref45$extendedMode, _ref45$findOrigin = _ref45.findOrigin, findOrigin = _ref45$findOrigin === void 0 ? null : _ref45$findOrigin, _ref45$findIssuer = _ref45.findIssuer, findIssuer = _ref45$findIssuer === void 0 ? null : _ref45$findIssuer;
                crypto = _args71.length > 1 && _args71[1] !== undefined ? _args71[1] : getCrypto(true);
                signerCert = null;
                timestampSerial = null;
                _context71.prev = 4;
                messageDigestValue = EMPTY_BUFFER;
                shaAlgorithm = EMPTY_STRING;
                certificatePath = [];
                signerInfo = this.signerInfos[signer];
                if (signerInfo) {
                  _context71.next = 11;
                  break;
                }
                throw new SignedDataVerifyError({
                  date: checkDate,
                  code: 1,
                  message: "Unable to get signer by supplied index"
                });
              case 11:
                if (this.certificates) {
                  _context71.next = 13;
                  break;
                }
                throw new SignedDataVerifyError({
                  date: checkDate,
                  code: 2,
                  message: "No certificates attached to this signed data"
                });
              case 13:
                if (!(signerInfo.sid instanceof IssuerAndSerialNumber)) {
                  _context71.next = 36;
                  break;
                }
                _iterator40 = _createForOfIteratorHelper(this.certificates);
                _context71.prev = 15;
                _iterator40.s();
              case 17:
                if ((_step40 = _iterator40.n()).done) {
                  _context71.next = 26;
                  break;
                }
                certificate = _step40.value;
                if (certificate instanceof Certificate) {
                  _context71.next = 21;
                  break;
                }
                return _context71.abrupt("continue", 24);
              case 21:
                if (!(certificate.issuer.isEqual(signerInfo.sid.issuer) && certificate.serialNumber.isEqual(signerInfo.sid.serialNumber))) {
                  _context71.next = 24;
                  break;
                }
                signerCert = certificate;
                return _context71.abrupt("break", 26);
              case 24:
                _context71.next = 17;
                break;
              case 26:
                _context71.next = 31;
                break;
              case 28:
                _context71.prev = 28;
                _context71.t0 = _context71["catch"](15);
                _iterator40.e(_context71.t0);
              case 31:
                _context71.prev = 31;
                _iterator40.f();
                return _context71.finish(31);
              case 34:
                _context71.next = 61;
                break;
              case 36:
                sid = signerInfo.sid;
                keyId = sid.idBlock.isConstructed ? sid.valueBlock.value[0].valueBlock.valueHex : sid.valueBlock.valueHex;
                _iterator41 = _createForOfIteratorHelper(this.certificates);
                _context71.prev = 39;
                _iterator41.s();
              case 41:
                if ((_step41 = _iterator41.n()).done) {
                  _context71.next = 53;
                  break;
                }
                _certificate = _step41.value;
                if (_certificate instanceof Certificate) {
                  _context71.next = 45;
                  break;
                }
                return _context71.abrupt("continue", 51);
              case 45:
                _context71.next = 47;
                return crypto.digest({
                  name: "sha-1"
                }, _certificate.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView);
              case 47:
                digest = _context71.sent;
                if (!isEqualBuffer(digest, keyId)) {
                  _context71.next = 51;
                  break;
                }
                signerCert = _certificate;
                return _context71.abrupt("break", 53);
              case 51:
                _context71.next = 41;
                break;
              case 53:
                _context71.next = 58;
                break;
              case 55:
                _context71.prev = 55;
                _context71.t1 = _context71["catch"](39);
                _iterator41.e(_context71.t1);
              case 58:
                _context71.prev = 58;
                _iterator41.f();
                return _context71.finish(58);
              case 61:
                if (signerCert) {
                  _context71.next = 63;
                  break;
                }
                throw new SignedDataVerifyError({
                  date: checkDate,
                  code: 3,
                  message: "Unable to find signer certificate"
                });
              case 63:
                if (!(this.encapContentInfo.eContentType === id_eContentType_TSTInfo)) {
                  _context71.next = 81;
                  break;
                }
                if (this.encapContentInfo.eContent) {
                  _context71.next = 66;
                  break;
                }
                throw new SignedDataVerifyError({
                  date: checkDate,
                  code: 15,
                  message: "Error during verification: TSTInfo eContent is empty",
                  signatureVerified: null,
                  signerCertificate: signerCert,
                  timestampSerial: timestampSerial,
                  signerCertificateVerified: true
                });
              case 66:
                _context71.prev = 66;
                tstInfo = TSTInfo.fromBER(this.encapContentInfo.eContent.valueBlock.valueHexView);
                _context71.next = 73;
                break;
              case 70:
                _context71.prev = 70;
                _context71.t2 = _context71["catch"](66);
                throw new SignedDataVerifyError({
                  date: checkDate,
                  code: 15,
                  message: "Error during verification: TSTInfo wrong ASN.1 schema ",
                  signatureVerified: null,
                  signerCertificate: signerCert,
                  timestampSerial: timestampSerial,
                  signerCertificateVerified: true
                });
              case 73:
                checkDate = tstInfo.genTime;
                timestampSerial = tstInfo.serialNumber.valueBlock.valueHexView.slice();
                if (!(data.byteLength === 0)) {
                  _context71.next = 77;
                  break;
                }
                throw new SignedDataVerifyError({
                  date: checkDate,
                  code: 4,
                  message: "Missed detached data input array"
                });
              case 77:
                _context71.next = 79;
                return tstInfo.verify({
                  data: data
                }, crypto);
              case 79:
                if (_context71.sent) {
                  _context71.next = 81;
                  break;
                }
                throw new SignedDataVerifyError({
                  date: checkDate,
                  code: 15,
                  message: "Error during verification: TSTInfo verification is failed",
                  signatureVerified: false,
                  signerCertificate: signerCert,
                  timestampSerial: timestampSerial,
                  signerCertificateVerified: true
                });
              case 81:
                if (!checkChain) {
                  _context71.next = 96;
                  break;
                }
                certs = this.certificates.filter(function (certificate) {
                  return certificate instanceof Certificate && !!checkCA(certificate, signerCert);
                });
                chainParams = {
                  checkDate: checkDate,
                  certs: certs,
                  trustedCerts: trustedCerts
                };
                if (findIssuer) {
                  chainParams.findIssuer = findIssuer;
                }
                if (findOrigin) {
                  chainParams.findOrigin = findOrigin;
                }
                chainEngine = new CertificateChainValidationEngine(chainParams);
                chainEngine.certs.push(signerCert);
                if (this.crls) {
                  _iterator42 = _createForOfIteratorHelper(this.crls);
                  try {
                    for (_iterator42.s(); !(_step42 = _iterator42.n()).done;) {
                      crl = _step42.value;
                      if ("thisUpdate" in crl) chainEngine.crls.push(crl);else {
                        if (crl.otherRevInfoFormat === id_PKIX_OCSP_Basic) chainEngine.ocsps.push(new BasicOCSPResponse({
                          schema: crl.otherRevInfo
                        }));
                      }
                    }
                  } catch (err) {
                    _iterator42.e(err);
                  } finally {
                    _iterator42.f();
                  }
                }
                if (this.ocsps) {
                  (_chainEngine$ocsps = chainEngine.ocsps).push.apply(_chainEngine$ocsps, _toConsumableArray(this.ocsps));
                }
                _context71.next = 92;
                return chainEngine.verify({
                  passedWhenNotRevValues: passedWhenNotRevValues
                }, crypto).catch(function (e) {
                  throw new SignedDataVerifyError({
                    date: checkDate,
                    code: 5,
                    message: "Validation of signer's certificate failed with error: ".concat(e instanceof Object ? e.resultMessage : e),
                    signerCertificate: signerCert,
                    signerCertificateVerified: false
                  });
                });
              case 92:
                verificationResult = _context71.sent;
                if (verificationResult.certificatePath) {
                  certificatePath = verificationResult.certificatePath;
                }
                if (verificationResult.result) {
                  _context71.next = 96;
                  break;
                }
                throw new SignedDataVerifyError({
                  date: checkDate,
                  code: 5,
                  message: "Validation of signer's certificate failed: ".concat(verificationResult.resultMessage),
                  signerCertificate: signerCert,
                  signerCertificateVerified: false
                });
              case 96:
                signerInfoHashAlgorithm = crypto.getAlgorithmByOID(signerInfo.digestAlgorithm.algorithmId);
                if ("name" in signerInfoHashAlgorithm) {
                  _context71.next = 99;
                  break;
                }
                throw new SignedDataVerifyError({
                  date: checkDate,
                  code: 7,
                  message: "Unsupported signature algorithm: ".concat(signerInfo.digestAlgorithm.algorithmId),
                  signerCertificate: signerCert,
                  signerCertificateVerified: true
                });
              case 99:
                shaAlgorithm = signerInfoHashAlgorithm.name;
                eContent = this.encapContentInfo.eContent;
                if (!eContent) {
                  _context71.next = 105;
                  break;
                }
                if (eContent.idBlock.tagClass === 1 && eContent.idBlock.tagNumber === 4) {
                  data = eContent.getValue();
                } else data = eContent.valueBlock.valueBeforeDecodeView;
                _context71.next = 107;
                break;
              case 105:
                if (!(data.byteLength === 0)) {
                  _context71.next = 107;
                  break;
                }
                throw new SignedDataVerifyError({
                  date: checkDate,
                  code: 8,
                  message: "Missed detached data input array",
                  signerCertificate: signerCert,
                  signerCertificateVerified: true
                });
              case 107:
                if (!signerInfo.signedAttrs) {
                  _context71.next = 133;
                  break;
                }
                foundContentType = false;
                foundMessageDigest = false;
                _iterator43 = _createForOfIteratorHelper(signerInfo.signedAttrs.attributes);
                _context71.prev = 111;
                _iterator43.s();
              case 113:
                if ((_step43 = _iterator43.n()).done) {
                  _context71.next = 121;
                  break;
                }
                attribute = _step43.value;
                if (attribute.type === "1.2.840.113549.1.9.3") foundContentType = true;
                if (attribute.type === "1.2.840.113549.1.9.4") {
                  foundMessageDigest = true;
                  messageDigestValue = attribute.values[0].valueBlock.valueHex;
                }
                if (!(foundContentType && foundMessageDigest)) {
                  _context71.next = 119;
                  break;
                }
                return _context71.abrupt("break", 121);
              case 119:
                _context71.next = 113;
                break;
              case 121:
                _context71.next = 126;
                break;
              case 123:
                _context71.prev = 123;
                _context71.t3 = _context71["catch"](111);
                _iterator43.e(_context71.t3);
              case 126:
                _context71.prev = 126;
                _iterator43.f();
                return _context71.finish(126);
              case 129:
                if (!(foundContentType === false)) {
                  _context71.next = 131;
                  break;
                }
                throw new SignedDataVerifyError({
                  date: checkDate,
                  code: 9,
                  message: "Attribute \"content-type\" is a mandatory attribute for \"signed attributes\"",
                  signerCertificate: signerCert,
                  signerCertificateVerified: true
                });
              case 131:
                if (!(foundMessageDigest === false)) {
                  _context71.next = 133;
                  break;
                }
                throw new SignedDataVerifyError({
                  date: checkDate,
                  code: 10,
                  message: "Attribute \"message-digest\" is a mandatory attribute for \"signed attributes\"",
                  signatureVerified: null,
                  signerCertificate: signerCert,
                  signerCertificateVerified: true
                });
              case 133:
                if (!signerInfo.signedAttrs) {
                  _context71.next = 140;
                  break;
                }
                _context71.next = 136;
                return crypto.digest(shaAlgorithm, new Uint8Array(data));
              case 136:
                messageDigest = _context71.sent;
                if (isEqualBuffer(messageDigest, messageDigestValue)) {
                  _context71.next = 139;
                  break;
                }
                throw new SignedDataVerifyError({
                  date: checkDate,
                  code: 15,
                  message: "Error during verification: Message digest doesn't match",
                  signatureVerified: null,
                  signerCertificate: signerCert,
                  timestampSerial: timestampSerial,
                  signerCertificateVerified: true
                });
              case 139:
                data = signerInfo.signedAttrs.encodedValue;
              case 140:
                if (!(signerInfo.signatureAlgorithm.algorithmId === "1.2.840.113549.1.1.1")) {
                  _context71.next = 146;
                  break;
                }
                _context71.next = 143;
                return crypto.verifyWithPublicKey(data, signerInfo.signature, signerCert.subjectPublicKeyInfo, signerInfo.signatureAlgorithm, shaAlgorithm);
              case 143:
                _context71.t4 = _context71.sent;
                _context71.next = 149;
                break;
              case 146:
                _context71.next = 148;
                return crypto.verifyWithPublicKey(data, signerInfo.signature, signerCert.subjectPublicKeyInfo, signerInfo.signatureAlgorithm);
              case 148:
                _context71.t4 = _context71.sent;
              case 149:
                verifyResult = _context71.t4;
                if (!extendedMode) {
                  _context71.next = 154;
                  break;
                }
                return _context71.abrupt("return", {
                  date: checkDate,
                  code: 14,
                  message: EMPTY_STRING,
                  signatureVerified: verifyResult,
                  signerCertificate: signerCert,
                  timestampSerial: timestampSerial,
                  signerCertificateVerified: true,
                  certificatePath: certificatePath
                });
              case 154:
                return _context71.abrupt("return", verifyResult);
              case 155:
                _context71.next = 162;
                break;
              case 157:
                _context71.prev = 157;
                _context71.t5 = _context71["catch"](4);
                if (!(_context71.t5 instanceof SignedDataVerifyError)) {
                  _context71.next = 161;
                  break;
                }
                throw _context71.t5;
              case 161:
                throw new SignedDataVerifyError({
                  date: checkDate,
                  code: 15,
                  message: "Error during verification: ".concat(_context71.t5 instanceof Error ? _context71.t5.message : _context71.t5),
                  signatureVerified: null,
                  signerCertificate: signerCert,
                  timestampSerial: timestampSerial,
                  signerCertificateVerified: true
                });
              case 162:
              case "end":
                return _context71.stop();
            }
          }, _callee71, this, [[4, 157], [15, 28, 31, 34], [39, 55, 58, 61], [66, 70], [111, 123, 126, 129]]);
        }));
        function verify() {
          return _verify10.apply(this, arguments);
        }
        return verify;
      }()
    }, {
      key: "sign",
      value: function () {
        var _sign7 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee72(privateKey, signerIndex) {
          var hashAlgorithm,
            data,
            crypto,
            _a,
            signerInfo,
            hashAlgorithmOID,
            signatureParams,
            parameters,
            view,
            eContent,
            signature,
            _args72 = arguments;
          return _regeneratorRuntime().wrap(function _callee72$(_context72) {
            while (1) switch (_context72.prev = _context72.next) {
              case 0:
                hashAlgorithm = _args72.length > 2 && _args72[2] !== undefined ? _args72[2] : "SHA-1";
                data = _args72.length > 3 && _args72[3] !== undefined ? _args72[3] : EMPTY_BUFFER;
                crypto = _args72.length > 4 && _args72[4] !== undefined ? _args72[4] : getCrypto(true);
                if (privateKey) {
                  _context72.next = 5;
                  break;
                }
                throw new Error("Need to provide a private key for signing");
              case 5:
                signerInfo = this.signerInfos[signerIndex];
                if (signerInfo) {
                  _context72.next = 8;
                  break;
                }
                throw new RangeError("SignerInfo index is out of range");
              case 8:
                if (!((_a = signerInfo.signedAttrs) === null || _a === void 0 ? void 0 : _a.attributes.length) && "hash" in privateKey.algorithm && "hash" in privateKey.algorithm && privateKey.algorithm.hash) {
                  hashAlgorithm = privateKey.algorithm.hash.name;
                }
                hashAlgorithmOID = crypto.getOIDByAlgorithm({
                  name: hashAlgorithm
                }, true, "hashAlgorithm");
                if (this.digestAlgorithms.filter(function (algorithm) {
                  return algorithm.algorithmId === hashAlgorithmOID;
                }).length === 0) {
                  this.digestAlgorithms.push(new AlgorithmIdentifier({
                    algorithmId: hashAlgorithmOID,
                    algorithmParams: new Null()
                  }));
                }
                signerInfo.digestAlgorithm = new AlgorithmIdentifier({
                  algorithmId: hashAlgorithmOID,
                  algorithmParams: new Null()
                });
                _context72.next = 14;
                return crypto.getSignatureParameters(privateKey, hashAlgorithm);
              case 14:
                signatureParams = _context72.sent;
                parameters = signatureParams.parameters;
                signerInfo.signatureAlgorithm = signatureParams.signatureAlgorithm;
                if (!signerInfo.signedAttrs) {
                  _context72.next = 21;
                  break;
                }
                if (signerInfo.signedAttrs.encodedValue.byteLength !== 0) data = signerInfo.signedAttrs.encodedValue;else {
                  data = signerInfo.signedAttrs.toSchema().toBER();
                  view = BufferSourceConverter.toUint8Array(data);
                  view[0] = 0x31;
                }
                _context72.next = 28;
                break;
              case 21:
                eContent = this.encapContentInfo.eContent;
                if (!eContent) {
                  _context72.next = 26;
                  break;
                }
                if (eContent.idBlock.tagClass === 1 && eContent.idBlock.tagNumber === 4) {
                  data = eContent.getValue();
                } else data = eContent.valueBlock.valueBeforeDecodeView;
                _context72.next = 28;
                break;
              case 26:
                if (!(data.byteLength === 0)) {
                  _context72.next = 28;
                  break;
                }
                throw new Error("Missed detached data input array");
              case 28:
                _context72.next = 30;
                return crypto.signWithPrivateKey(data, privateKey, parameters);
              case 30:
                signature = _context72.sent;
                signerInfo.signature = new OctetString({
                  valueHex: signature
                });
              case 32:
              case "end":
                return _context72.stop();
            }
          }, _callee72, this);
        }));
        function sign(_x101, _x102) {
          return _sign7.apply(this, arguments);
        }
        return sign;
      }()
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case VERSION$2:
            return 0;
          case DIGEST_ALGORITHMS:
            return [];
          case ENCAP_CONTENT_INFO:
            return new EncapsulatedContentInfo();
          case CERTIFICATES:
            return [];
          case CRLS:
            return [];
          case OCSPS:
            return [];
          case SIGNER_INFOS:
            return [];
          default:
            return _superPropGet(SignedData, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VERSION$2:
            return memberValue === SignedData.defaultValues(VERSION$2);
          case ENCAP_CONTENT_INFO:
            return EncapsulatedContentInfo.compareWithDefault("eContentType", memberValue.eContentType) && EncapsulatedContentInfo.compareWithDefault("eContent", memberValue.eContent);
          case DIGEST_ALGORITHMS:
          case CERTIFICATES:
          case CRLS:
          case OCSPS:
          case SIGNER_INFOS:
            return memberValue.length === 0;
          default:
            return _superPropGet(SignedData, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        if (names.optional === undefined) {
          names.optional = false;
        }
        return new Sequence({
          name: names.blockName || SIGNED_DATA,
          optional: names.optional,
          value: [new Integer({
            name: names.version || SIGNED_DATA_VERSION
          }), new Set({
            value: [new Repeated({
              name: names.digestAlgorithms || SIGNED_DATA_DIGEST_ALGORITHMS,
              value: AlgorithmIdentifier.schema()
            })]
          }), EncapsulatedContentInfo.schema(names.encapContentInfo || {
            names: {
              blockName: SIGNED_DATA_ENCAP_CONTENT_INFO
            }
          }), new Constructed({
            name: names.certificates || SIGNED_DATA_CERTIFICATES,
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: CertificateSet.schema().valueBlock.value
          }), new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: RevocationInfoChoices.schema(names.crls || {
              names: {
                crls: SIGNED_DATA_CRLS
              }
            }).valueBlock.value
          }), new Set({
            value: [new Repeated({
              name: names.signerInfos || SIGNED_DATA_SIGNER_INFOS,
              value: SignerInfo.schema()
            })]
          })]
        });
      }
    }]);
  }(PkiObject);
  SignedData.CLASS_NAME = "SignedData";
  SignedData.ID_DATA = id_ContentType_Data;
  var VERSION$1 = "version";
  var AUTH_SAFE = "authSafe";
  var MAC_DATA = "macData";
  var PARSED_VALUE = "parsedValue";
  var CLERA_PROPS = [VERSION$1, AUTH_SAFE, MAC_DATA];
  var PFX = function (_PkiObject111) {
    function PFX() {
      var _this175;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, PFX);
      _this175 = _callSuper(this, PFX);
      _this175.version = getParametersValue(parameters, VERSION$1, PFX.defaultValues(VERSION$1));
      _this175.authSafe = getParametersValue(parameters, AUTH_SAFE, PFX.defaultValues(AUTH_SAFE));
      if (MAC_DATA in parameters) {
        _this175.macData = getParametersValue(parameters, MAC_DATA, PFX.defaultValues(MAC_DATA));
      }
      if (PARSED_VALUE in parameters) {
        _this175.parsedValue = getParametersValue(parameters, PARSED_VALUE, PFX.defaultValues(PARSED_VALUE));
      }
      if (parameters.schema) {
        _this175.fromSchema(parameters.schema);
      }
      return _this175;
    }
    _inherits(PFX, _PkiObject111);
    return _createClass(PFX, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLERA_PROPS);
        var asn1 = compareSchema(schema, schema, PFX.schema({
          names: {
            version: VERSION$1,
            authSafe: {
              names: {
                blockName: AUTH_SAFE
              }
            },
            macData: {
              names: {
                blockName: MAC_DATA
              }
            }
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result.version.valueBlock.valueDec;
        this.authSafe = new ContentInfo({
          schema: asn1.result.authSafe
        });
        if (MAC_DATA in asn1.result) this.macData = new MacData({
          schema: asn1.result.macData
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [new Integer({
          value: this.version
        }), this.authSafe.toSchema()];
        if (this.macData) {
          outputArray.push(this.macData.toSchema());
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var output = {
          version: this.version,
          authSafe: this.authSafe.toJSON()
        };
        if (this.macData) {
          output.macData = this.macData.toJSON();
        }
        return output;
      }
    }, {
      key: "makeInternalValues",
      value: function () {
        var _makeInternalValues3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee73() {
          var parameters,
            crypto,
            saltBuffer,
            saltView,
            data,
            _result10,
            toBeSigned,
            cmsSigned,
            _result11,
            signedAttr,
            _args73 = arguments;
          return _regeneratorRuntime().wrap(function _callee73$(_context73) {
            while (1) switch (_context73.prev = _context73.next) {
              case 0:
                parameters = _args73.length > 0 && _args73[0] !== undefined ? _args73[0] : {};
                crypto = _args73.length > 1 && _args73[1] !== undefined ? _args73[1] : getCrypto(true);
                ArgumentError.assert(parameters, "parameters", "object");
                if (this.parsedValue) {
                  _context73.next = 5;
                  break;
                }
                throw new Error("Please call \"parseValues\" function first in order to make \"parsedValue\" data");
              case 5:
                ParameterError.assertEmpty(this.parsedValue.integrityMode, "integrityMode", "parsedValue");
                ParameterError.assertEmpty(this.parsedValue.authenticatedSafe, "authenticatedSafe", "parsedValue");
                _context73.t0 = this.parsedValue.integrityMode;
                _context73.next = _context73.t0 === 0 ? 10 : _context73.t0 === 1 ? 25 : 43;
                break;
              case 10:
                if ("iterations" in parameters) {
                  _context73.next = 12;
                  break;
                }
                throw new ParameterError("iterations");
              case 12:
                ParameterError.assertEmpty(parameters.pbkdf2HashAlgorithm, "pbkdf2HashAlgorithm");
                ParameterError.assertEmpty(parameters.hmacHashAlgorithm, "hmacHashAlgorithm");
                ParameterError.assertEmpty(parameters.password, "password");
                saltBuffer = new ArrayBuffer(64);
                saltView = new Uint8Array(saltBuffer);
                crypto.getRandomValues(saltView);
                data = this.parsedValue.authenticatedSafe.toSchema().toBER(false);
                this.authSafe = new ContentInfo({
                  contentType: ContentInfo.DATA,
                  content: new OctetString({
                    valueHex: data
                  })
                });
                _context73.next = 22;
                return crypto.stampDataWithPassword({
                  password: parameters.password,
                  hashAlgorithm: parameters.hmacHashAlgorithm,
                  salt: saltBuffer,
                  iterationCount: parameters.iterations,
                  contentToStamp: data
                });
              case 22:
                _result10 = _context73.sent;
                this.macData = new MacData({
                  mac: new DigestInfo({
                    digestAlgorithm: new AlgorithmIdentifier({
                      algorithmId: crypto.getOIDByAlgorithm({
                        name: parameters.hmacHashAlgorithm
                      }, true, "hmacHashAlgorithm")
                    }),
                    digest: new OctetString({
                      valueHex: _result10
                    })
                  }),
                  macSalt: new OctetString({
                    valueHex: saltBuffer
                  }),
                  iterations: parameters.iterations
                });
                return _context73.abrupt("break", 44);
              case 25:
                if ("signingCertificate" in parameters) {
                  _context73.next = 27;
                  break;
                }
                throw new ParameterError("signingCertificate");
              case 27:
                ParameterError.assertEmpty(parameters.privateKey, "privateKey");
                ParameterError.assertEmpty(parameters.hashAlgorithm, "hashAlgorithm");
                toBeSigned = this.parsedValue.authenticatedSafe.toSchema().toBER(false);
                cmsSigned = new SignedData({
                  version: 1,
                  encapContentInfo: new EncapsulatedContentInfo({
                    eContentType: "1.2.840.113549.1.7.1",
                    eContent: new OctetString({
                      valueHex: toBeSigned
                    })
                  }),
                  certificates: [parameters.signingCertificate]
                });
                _context73.next = 33;
                return crypto.digest({
                  name: parameters.hashAlgorithm
                }, new Uint8Array(toBeSigned));
              case 33:
                _result11 = _context73.sent;
                signedAttr = [];
                signedAttr.push(new Attribute({
                  type: "1.2.840.113549.1.9.3",
                  values: [new ObjectIdentifier({
                    value: "1.2.840.113549.1.7.1"
                  })]
                }));
                signedAttr.push(new Attribute({
                  type: "1.2.840.113549.1.9.5",
                  values: [new UTCTime({
                    valueDate: new Date()
                  })]
                }));
                signedAttr.push(new Attribute({
                  type: "1.2.840.113549.1.9.4",
                  values: [new OctetString({
                    valueHex: _result11
                  })]
                }));
                cmsSigned.signerInfos.push(new SignerInfo({
                  version: 1,
                  sid: new IssuerAndSerialNumber({
                    issuer: parameters.signingCertificate.issuer,
                    serialNumber: parameters.signingCertificate.serialNumber
                  }),
                  signedAttrs: new SignedAndUnsignedAttributes({
                    type: 0,
                    attributes: signedAttr
                  })
                }));
                _context73.next = 41;
                return cmsSigned.sign(parameters.privateKey, 0, parameters.hashAlgorithm, undefined, crypto);
              case 41:
                this.authSafe = new ContentInfo({
                  contentType: "1.2.840.113549.1.7.2",
                  content: cmsSigned.toSchema(true)
                });
                return _context73.abrupt("break", 44);
              case 43:
                throw new Error("Parameter \"integrityMode\" has unknown value: ".concat(this.parsedValue.integrityMode));
              case 44:
              case "end":
                return _context73.stop();
            }
          }, _callee73, this);
        }));
        function makeInternalValues() {
          return _makeInternalValues3.apply(this, arguments);
        }
        return makeInternalValues;
      }()
    }, {
      key: "parseInternalValues",
      value: function () {
        var _parseInternalValues3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee74(parameters) {
          var crypto,
            authSafeContent,
            hashAlgorithm,
            _result12,
            cmsSigned,
            eContent,
            data,
            ok,
            _args74 = arguments;
          return _regeneratorRuntime().wrap(function _callee74$(_context74) {
            while (1) switch (_context74.prev = _context74.next) {
              case 0:
                crypto = _args74.length > 1 && _args74[1] !== undefined ? _args74[1] : getCrypto(true);
                ArgumentError.assert(parameters, "parameters", "object");
                if (parameters.checkIntegrity === undefined) {
                  parameters.checkIntegrity = true;
                }
                this.parsedValue = {};
                _context74.t0 = this.authSafe.contentType;
                _context74.next = _context74.t0 === ContentInfo.DATA ? 7 : _context74.t0 === ContentInfo.SIGNED_DATA ? 22 : 35;
                break;
              case 7:
                ParameterError.assertEmpty(parameters.password, "password");
                this.parsedValue.integrityMode = 0;
                ArgumentError.assert(this.authSafe.content, "authSafe.content", OctetString);
                authSafeContent = this.authSafe.content.getValue();
                this.parsedValue.authenticatedSafe = AuthenticatedSafe.fromBER(authSafeContent);
                if (!parameters.checkIntegrity) {
                  _context74.next = 21;
                  break;
                }
                if (this.macData) {
                  _context74.next = 15;
                  break;
                }
                throw new Error("Absent \"macData\" value, can not check PKCS#12 data integrity");
              case 15:
                hashAlgorithm = crypto.getAlgorithmByOID(this.macData.mac.digestAlgorithm.algorithmId, true, "digestAlgorithm");
                _context74.next = 18;
                return crypto.verifyDataStampedWithPassword({
                  password: parameters.password,
                  hashAlgorithm: hashAlgorithm.name,
                  salt: BufferSourceConverter.toArrayBuffer(this.macData.macSalt.valueBlock.valueHexView),
                  iterationCount: this.macData.iterations || 1,
                  contentToVerify: authSafeContent,
                  signatureToVerify: BufferSourceConverter.toArrayBuffer(this.macData.mac.digest.valueBlock.valueHexView)
                });
              case 18:
                _result12 = _context74.sent;
                if (_result12) {
                  _context74.next = 21;
                  break;
                }
                throw new Error("Integrity for the PKCS#12 data is broken!");
              case 21:
                return _context74.abrupt("break", 36);
              case 22:
                this.parsedValue.integrityMode = 1;
                cmsSigned = new SignedData({
                  schema: this.authSafe.content
                });
                eContent = cmsSigned.encapContentInfo.eContent;
                ParameterError.assert(eContent, "eContent", "cmsSigned.encapContentInfo");
                ArgumentError.assert(eContent, "eContent", OctetString);
                data = eContent.getValue();
                this.parsedValue.authenticatedSafe = AuthenticatedSafe.fromBER(data);
                _context74.next = 31;
                return cmsSigned.verify({
                  signer: 0,
                  checkChain: false
                }, crypto);
              case 31:
                ok = _context74.sent;
                if (ok) {
                  _context74.next = 34;
                  break;
                }
                throw new Error("Integrity for the PKCS#12 data is broken!");
              case 34:
                return _context74.abrupt("break", 36);
              case 35:
                throw new Error("Incorrect value for \"this.authSafe.contentType\": ".concat(this.authSafe.contentType));
              case 36:
              case "end":
                return _context74.stop();
            }
          }, _callee74, this);
        }));
        function parseInternalValues(_x103) {
          return _parseInternalValues3.apply(this, arguments);
        }
        return parseInternalValues;
      }()
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case VERSION$1:
            return 3;
          case AUTH_SAFE:
            return new ContentInfo();
          case MAC_DATA:
            return new MacData();
          case PARSED_VALUE:
            return {};
          default:
            return _superPropGet(PFX, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VERSION$1:
            return memberValue === PFX.defaultValues(memberName);
          case AUTH_SAFE:
            return ContentInfo.compareWithDefault("contentType", memberValue.contentType) && ContentInfo.compareWithDefault("content", memberValue.content);
          case MAC_DATA:
            return MacData.compareWithDefault("mac", memberValue.mac) && MacData.compareWithDefault("macSalt", memberValue.macSalt) && MacData.compareWithDefault("iterations", memberValue.iterations);
          case PARSED_VALUE:
            return memberValue instanceof Object && Object.keys(memberValue).length === 0;
          default:
            return _superPropGet(PFX, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Integer({
            name: names.version || VERSION$1
          }), ContentInfo.schema(names.authSafe || {
            names: {
              blockName: AUTH_SAFE
            }
          }), MacData.schema(names.macData || {
            names: {
              blockName: MAC_DATA,
              optional: true
            }
          })]
        });
      }
    }]);
  }(PkiObject);
  PFX.CLASS_NAME = "PFX";
  var STATUS$1 = "status";
  var STATUS_STRINGS = "statusStrings";
  var FAIL_INFO = "failInfo";
  var CLEAR_PROPS$2 = [STATUS$1, STATUS_STRINGS, FAIL_INFO];
  var PKIStatus;
  (function (PKIStatus) {
    PKIStatus[PKIStatus["granted"] = 0] = "granted";
    PKIStatus[PKIStatus["grantedWithMods"] = 1] = "grantedWithMods";
    PKIStatus[PKIStatus["rejection"] = 2] = "rejection";
    PKIStatus[PKIStatus["waiting"] = 3] = "waiting";
    PKIStatus[PKIStatus["revocationWarning"] = 4] = "revocationWarning";
    PKIStatus[PKIStatus["revocationNotification"] = 5] = "revocationNotification";
  })(PKIStatus || (PKIStatus = {}));
  var PKIStatusInfo = function (_PkiObject112) {
    function PKIStatusInfo() {
      var _this176;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, PKIStatusInfo);
      _this176 = _callSuper(this, PKIStatusInfo);
      _this176.status = getParametersValue(parameters, STATUS$1, PKIStatusInfo.defaultValues(STATUS$1));
      if (STATUS_STRINGS in parameters) {
        _this176.statusStrings = getParametersValue(parameters, STATUS_STRINGS, PKIStatusInfo.defaultValues(STATUS_STRINGS));
      }
      if (FAIL_INFO in parameters) {
        _this176.failInfo = getParametersValue(parameters, FAIL_INFO, PKIStatusInfo.defaultValues(FAIL_INFO));
      }
      if (parameters.schema) {
        _this176.fromSchema(parameters.schema);
      }
      return _this176;
    }
    _inherits(PKIStatusInfo, _PkiObject112);
    return _createClass(PKIStatusInfo, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$2);
        var asn1 = compareSchema(schema, schema, PKIStatusInfo.schema({
          names: {
            status: STATUS$1,
            statusStrings: STATUS_STRINGS,
            failInfo: FAIL_INFO
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        var _status = asn1.result.status;
        if (_status.valueBlock.isHexOnly === true || _status.valueBlock.valueDec < 0 || _status.valueBlock.valueDec > 5) throw new Error("PKIStatusInfo \"status\" has invalid value");
        this.status = _status.valueBlock.valueDec;
        if (STATUS_STRINGS in asn1.result) this.statusStrings = asn1.result.statusStrings;
        if (FAIL_INFO in asn1.result) this.failInfo = asn1.result.failInfo;
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        outputArray.push(new Integer({
          value: this.status
        }));
        if (this.statusStrings) {
          outputArray.push(new Sequence({
            optional: true,
            value: this.statusStrings
          }));
        }
        if (this.failInfo) {
          outputArray.push(this.failInfo);
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          status: this.status
        };
        if (this.statusStrings) {
          res.statusStrings = Array.from(this.statusStrings, function (o) {
            return o.toJSON();
          });
        }
        if (this.failInfo) {
          res.failInfo = this.failInfo.toJSON();
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case STATUS$1:
            return 2;
          case STATUS_STRINGS:
            return [];
          case FAIL_INFO:
            return new BitString();
          default:
            return _superPropGet(PKIStatusInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case STATUS$1:
            return memberValue === PKIStatusInfo.defaultValues(memberName);
          case STATUS_STRINGS:
            return memberValue.length === 0;
          case FAIL_INFO:
            return memberValue.isEqual(PKIStatusInfo.defaultValues(memberName));
          default:
            return _superPropGet(PKIStatusInfo, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [new Integer({
            name: names.status || EMPTY_STRING
          }), new Sequence({
            optional: true,
            value: [new Repeated({
              name: names.statusStrings || EMPTY_STRING,
              value: new Utf8String()
            })]
          }), new BitString({
            name: names.failInfo || EMPTY_STRING,
            optional: true
          })]
        });
      }
    }]);
  }(PkiObject);
  PKIStatusInfo.CLASS_NAME = "PKIStatusInfo";
  var VERSION = "version";
  var MESSAGE_IMPRINT = "messageImprint";
  var REQ_POLICY = "reqPolicy";
  var NONCE = "nonce";
  var CERT_REQ = "certReq";
  var EXTENSIONS = "extensions";
  var TIME_STAMP_REQ = "TimeStampReq";
  var TIME_STAMP_REQ_VERSION = "".concat(TIME_STAMP_REQ, ".").concat(VERSION);
  var TIME_STAMP_REQ_MESSAGE_IMPRINT = "".concat(TIME_STAMP_REQ, ".").concat(MESSAGE_IMPRINT);
  var TIME_STAMP_REQ_POLICY = "".concat(TIME_STAMP_REQ, ".").concat(REQ_POLICY);
  var TIME_STAMP_REQ_NONCE = "".concat(TIME_STAMP_REQ, ".").concat(NONCE);
  var TIME_STAMP_REQ_CERT_REQ = "".concat(TIME_STAMP_REQ, ".").concat(CERT_REQ);
  var TIME_STAMP_REQ_EXTENSIONS = "".concat(TIME_STAMP_REQ, ".").concat(EXTENSIONS);
  var CLEAR_PROPS$1 = [TIME_STAMP_REQ_VERSION, TIME_STAMP_REQ_MESSAGE_IMPRINT, TIME_STAMP_REQ_POLICY, TIME_STAMP_REQ_NONCE, TIME_STAMP_REQ_CERT_REQ, TIME_STAMP_REQ_EXTENSIONS];
  var TimeStampReq = function (_PkiObject113) {
    function TimeStampReq() {
      var _this177;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, TimeStampReq);
      _this177 = _callSuper(this, TimeStampReq);
      _this177.version = getParametersValue(parameters, VERSION, TimeStampReq.defaultValues(VERSION));
      _this177.messageImprint = getParametersValue(parameters, MESSAGE_IMPRINT, TimeStampReq.defaultValues(MESSAGE_IMPRINT));
      if (REQ_POLICY in parameters) {
        _this177.reqPolicy = getParametersValue(parameters, REQ_POLICY, TimeStampReq.defaultValues(REQ_POLICY));
      }
      if (NONCE in parameters) {
        _this177.nonce = getParametersValue(parameters, NONCE, TimeStampReq.defaultValues(NONCE));
      }
      if (CERT_REQ in parameters) {
        _this177.certReq = getParametersValue(parameters, CERT_REQ, TimeStampReq.defaultValues(CERT_REQ));
      }
      if (EXTENSIONS in parameters) {
        _this177.extensions = getParametersValue(parameters, EXTENSIONS, TimeStampReq.defaultValues(EXTENSIONS));
      }
      if (parameters.schema) {
        _this177.fromSchema(parameters.schema);
      }
      return _this177;
    }
    _inherits(TimeStampReq, _PkiObject113);
    return _createClass(TimeStampReq, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS$1);
        var asn1 = compareSchema(schema, schema, TimeStampReq.schema());
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result[TIME_STAMP_REQ_VERSION].valueBlock.valueDec;
        this.messageImprint = new MessageImprint({
          schema: asn1.result[TIME_STAMP_REQ_MESSAGE_IMPRINT]
        });
        if (TIME_STAMP_REQ_POLICY in asn1.result) this.reqPolicy = asn1.result[TIME_STAMP_REQ_POLICY].valueBlock.toString();
        if (TIME_STAMP_REQ_NONCE in asn1.result) this.nonce = asn1.result[TIME_STAMP_REQ_NONCE];
        if (TIME_STAMP_REQ_CERT_REQ in asn1.result) this.certReq = asn1.result[TIME_STAMP_REQ_CERT_REQ].valueBlock.value;
        if (TIME_STAMP_REQ_EXTENSIONS in asn1.result) this.extensions = Array.from(asn1.result[TIME_STAMP_REQ_EXTENSIONS], function (element) {
          return new Extension({
            schema: element
          });
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        outputArray.push(new Integer({
          value: this.version
        }));
        outputArray.push(this.messageImprint.toSchema());
        if (this.reqPolicy) outputArray.push(new ObjectIdentifier({
          value: this.reqPolicy
        }));
        if (this.nonce) outputArray.push(this.nonce);
        if (CERT_REQ in this && TimeStampReq.compareWithDefault(CERT_REQ, this.certReq) === false) outputArray.push(new Boolean$1({
          value: this.certReq
        }));
        if (this.extensions) {
          outputArray.push(new Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: Array.from(this.extensions, function (o) {
              return o.toSchema();
            })
          }));
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          version: this.version,
          messageImprint: this.messageImprint.toJSON()
        };
        if (this.reqPolicy !== undefined) res.reqPolicy = this.reqPolicy;
        if (this.nonce !== undefined) res.nonce = this.nonce.toJSON();
        if (this.certReq !== undefined && TimeStampReq.compareWithDefault(CERT_REQ, this.certReq) === false) res.certReq = this.certReq;
        if (this.extensions) {
          res.extensions = Array.from(this.extensions, function (o) {
            return o.toJSON();
          });
        }
        return res;
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case VERSION:
            return 0;
          case MESSAGE_IMPRINT:
            return new MessageImprint();
          case REQ_POLICY:
            return EMPTY_STRING;
          case NONCE:
            return new Integer();
          case CERT_REQ:
            return false;
          case EXTENSIONS:
            return [];
          default:
            return _superPropGet(TimeStampReq, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VERSION:
          case REQ_POLICY:
          case CERT_REQ:
            return memberValue === TimeStampReq.defaultValues(memberName);
          case MESSAGE_IMPRINT:
            return MessageImprint.compareWithDefault("hashAlgorithm", memberValue.hashAlgorithm) && MessageImprint.compareWithDefault("hashedMessage", memberValue.hashedMessage);
          case NONCE:
            return memberValue.isEqual(TimeStampReq.defaultValues(memberName));
          case EXTENSIONS:
            return memberValue.length === 0;
          default:
            return _superPropGet(TimeStampReq, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || TIME_STAMP_REQ,
          value: [new Integer({
            name: names.version || TIME_STAMP_REQ_VERSION
          }), MessageImprint.schema(names.messageImprint || {
            names: {
              blockName: TIME_STAMP_REQ_MESSAGE_IMPRINT
            }
          }), new ObjectIdentifier({
            name: names.reqPolicy || TIME_STAMP_REQ_POLICY,
            optional: true
          }), new Integer({
            name: names.nonce || TIME_STAMP_REQ_NONCE,
            optional: true
          }), new Boolean$1({
            name: names.certReq || TIME_STAMP_REQ_CERT_REQ,
            optional: true
          }), new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [new Repeated({
              name: names.extensions || TIME_STAMP_REQ_EXTENSIONS,
              value: Extension.schema()
            })]
          })]
        });
      }
    }]);
  }(PkiObject);
  TimeStampReq.CLASS_NAME = "TimeStampReq";
  var STATUS = "status";
  var TIME_STAMP_TOKEN = "timeStampToken";
  var TIME_STAMP_RESP = "TimeStampResp";
  var TIME_STAMP_RESP_STATUS = "".concat(TIME_STAMP_RESP, ".").concat(STATUS);
  var TIME_STAMP_RESP_TOKEN = "".concat(TIME_STAMP_RESP, ".").concat(TIME_STAMP_TOKEN);
  var CLEAR_PROPS = [TIME_STAMP_RESP_STATUS, TIME_STAMP_RESP_TOKEN];
  var TimeStampResp = function (_PkiObject114) {
    function TimeStampResp() {
      var _this178;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, TimeStampResp);
      _this178 = _callSuper(this, TimeStampResp);
      _this178.status = getParametersValue(parameters, STATUS, TimeStampResp.defaultValues(STATUS));
      if (TIME_STAMP_TOKEN in parameters) {
        _this178.timeStampToken = getParametersValue(parameters, TIME_STAMP_TOKEN, TimeStampResp.defaultValues(TIME_STAMP_TOKEN));
      }
      if (parameters.schema) {
        _this178.fromSchema(parameters.schema);
      }
      return _this178;
    }
    _inherits(TimeStampResp, _PkiObject114);
    return _createClass(TimeStampResp, [{
      key: "fromSchema",
      value: function fromSchema(schema) {
        clearProps(schema, CLEAR_PROPS);
        var asn1 = compareSchema(schema, schema, TimeStampResp.schema());
        AsnError.assertSchema(asn1, this.className);
        this.status = new PKIStatusInfo({
          schema: asn1.result[TIME_STAMP_RESP_STATUS]
        });
        if (TIME_STAMP_RESP_TOKEN in asn1.result) this.timeStampToken = new ContentInfo({
          schema: asn1.result[TIME_STAMP_RESP_TOKEN]
        });
      }
    }, {
      key: "toSchema",
      value: function toSchema() {
        var outputArray = [];
        outputArray.push(this.status.toSchema());
        if (this.timeStampToken) {
          outputArray.push(this.timeStampToken.toSchema());
        }
        return new Sequence({
          value: outputArray
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var res = {
          status: this.status.toJSON()
        };
        if (this.timeStampToken) {
          res.timeStampToken = this.timeStampToken.toJSON();
        }
        return res;
      }
    }, {
      key: "sign",
      value: function () {
        var _sign8 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee75(privateKey, hashAlgorithm) {
          var crypto,
            signed,
            _args75 = arguments;
          return _regeneratorRuntime().wrap(function _callee75$(_context75) {
            while (1) switch (_context75.prev = _context75.next) {
              case 0:
                crypto = _args75.length > 2 && _args75[2] !== undefined ? _args75[2] : getCrypto(true);
                this.assertContentType();
                signed = new SignedData({
                  schema: this.timeStampToken.content
                });
                return _context75.abrupt("return", signed.sign(privateKey, 0, hashAlgorithm, undefined, crypto));
              case 4:
              case "end":
                return _context75.stop();
            }
          }, _callee75, this);
        }));
        function sign(_x104, _x105) {
          return _sign8.apply(this, arguments);
        }
        return sign;
      }()
    }, {
      key: "verify",
      value: function () {
        var _verify11 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee76() {
          var verificationParameters,
            crypto,
            signed,
            _args76 = arguments;
          return _regeneratorRuntime().wrap(function _callee76$(_context76) {
            while (1) switch (_context76.prev = _context76.next) {
              case 0:
                verificationParameters = _args76.length > 0 && _args76[0] !== undefined ? _args76[0] : {
                  signer: 0,
                  trustedCerts: [],
                  data: EMPTY_BUFFER
                };
                crypto = _args76.length > 1 && _args76[1] !== undefined ? _args76[1] : getCrypto(true);
                this.assertContentType();
                signed = new SignedData({
                  schema: this.timeStampToken.content
                });
                return _context76.abrupt("return", signed.verify(verificationParameters, crypto));
              case 5:
              case "end":
                return _context76.stop();
            }
          }, _callee76, this);
        }));
        function verify() {
          return _verify11.apply(this, arguments);
        }
        return verify;
      }()
    }, {
      key: "assertContentType",
      value: function assertContentType() {
        if (!this.timeStampToken) {
          throw new Error("timeStampToken is absent in TSP response");
        }
        if (this.timeStampToken.contentType !== id_ContentType_SignedData) {
          throw new Error("Wrong format of timeStampToken: ".concat(this.timeStampToken.contentType));
        }
      }
    }], [{
      key: "defaultValues",
      value: function defaultValues(memberName) {
        switch (memberName) {
          case STATUS:
            return new PKIStatusInfo();
          case TIME_STAMP_TOKEN:
            return new ContentInfo();
          default:
            return _superPropGet(TimeStampResp, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "compareWithDefault",
      value: function compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case STATUS:
            return PKIStatusInfo.compareWithDefault(STATUS, memberValue.status) && "statusStrings" in memberValue === false && "failInfo" in memberValue === false;
          case TIME_STAMP_TOKEN:
            return memberValue.contentType === EMPTY_STRING && memberValue.content instanceof Any;
          default:
            return _superPropGet(TimeStampResp, "defaultValues", this, 2)([memberName]);
        }
      }
    }, {
      key: "schema",
      value: function schema() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var names = getParametersValue(parameters, "names", {});
        return new Sequence({
          name: names.blockName || TIME_STAMP_RESP,
          value: [PKIStatusInfo.schema(names.status || {
            names: {
              blockName: TIME_STAMP_RESP_STATUS
            }
          }), ContentInfo.schema(names.timeStampToken || {
            names: {
              blockName: TIME_STAMP_RESP_TOKEN,
              optional: true
            }
          })]
        });
      }
    }]);
  }(PkiObject);
  TimeStampResp.CLASS_NAME = "TimeStampResp";
  function initCryptoEngine() {
    if (typeof self !== "undefined") {
      if ("crypto" in self) {
        var engineName = "webcrypto";
        if ("webkitSubtle" in self.crypto) {
          engineName = "safari";
        }
        _setEngine(engineName, new CryptoEngine({
          name: engineName,
          crypto: crypto
        }));
      }
    } else if (typeof crypto !== "undefined" && "webcrypto" in crypto) {
      var name = "NodeJS ^15";
      var nodeCrypto = crypto.webcrypto;
      _setEngine(name, new CryptoEngine({
        name: name,
        crypto: nodeCrypto
      }));
    }
  }
  initCryptoEngine();
  var engineCrypto = null;
  var Application = function () {
    function Application() {
      _classCallCheck(this, Application);
    }
    return _createClass(Application, null, [{
      key: "setEngine",
      value: function setEngine(name, crypto) {
        engineCrypto = Object.assign(crypto, {
          name: name
        });
        _setEngine(name, new CryptoEngine({
          name: name,
          crypto: crypto
        }));
      }
    }, {
      key: "crypto",
      get: function get() {
        if (!engineCrypto) {
          throw new XmlError(XE.CRYPTOGRAPHIC_NO_MODULE);
        }
        return engineCrypto;
      }
    }, {
      key: "isNodePlugin",
      value: function isNodePlugin() {
        return typeof self === "undefined" && typeof window === "undefined";
      }
    }]);
  }();
  function init() {
    if (!Application.isNodePlugin()) {
      Application.setEngine("W3 WebCrypto module", self.crypto);
    }
  }
  init();
  var XmlAlgorithm = function () {
    function XmlAlgorithm() {
      _classCallCheck(this, XmlAlgorithm);
    }
    return _createClass(XmlAlgorithm, [{
      key: "getAlgorithmName",
      value: function getAlgorithmName() {
        return this.namespaceURI;
      }
    }]);
  }();
  var HashAlgorithm = function (_XmlAlgorithm) {
    function HashAlgorithm() {
      _classCallCheck(this, HashAlgorithm);
      return _callSuper(this, HashAlgorithm, arguments);
    }
    _inherits(HashAlgorithm, _XmlAlgorithm);
    return _createClass(HashAlgorithm, [{
      key: "Digest",
      value: function () {
        var _Digest = _asyncToGenerator(_regeneratorRuntime().mark(function _callee77(xml) {
          var buf, txt, hash;
          return _regeneratorRuntime().wrap(function _callee77$(_context77) {
            while (1) switch (_context77.prev = _context77.next) {
              case 0:
                if (typeof xml === "string") {
                  buf = Convert$1.FromString(xml, "utf8");
                } else if (ArrayBuffer.isView(xml)) {
                  buf = new Uint8Array(xml.buffer);
                } else if (xml instanceof ArrayBuffer) {
                  buf = new Uint8Array(xml);
                } else {
                  txt = new XMLSerializer().serializeToString(xml);
                  buf = Convert$1.FromString(txt, "utf8");
                }
                _context77.next = 3;
                return Application.crypto.subtle.digest(this.algorithm, buf);
              case 3:
                hash = _context77.sent;
                return _context77.abrupt("return", new Uint8Array(hash));
              case 5:
              case "end":
                return _context77.stop();
            }
          }, _callee77, this);
        }));
        function Digest(_x106) {
          return _Digest.apply(this, arguments);
        }
        return Digest;
      }()
    }]);
  }(XmlAlgorithm);
  var SignatureAlgorithm = function (_XmlAlgorithm2) {
    function SignatureAlgorithm() {
      _classCallCheck(this, SignatureAlgorithm);
      return _callSuper(this, SignatureAlgorithm, arguments);
    }
    _inherits(SignatureAlgorithm, _XmlAlgorithm2);
    return _createClass(SignatureAlgorithm, [{
      key: "Sign",
      value: function () {
        var _Sign = _asyncToGenerator(_regeneratorRuntime().mark(function _callee78(signedInfo, signingKey, algorithm) {
          var info;
          return _regeneratorRuntime().wrap(function _callee78$(_context78) {
            while (1) switch (_context78.prev = _context78.next) {
              case 0:
                info = Convert$1.FromString(signedInfo, "utf8");
                return _context78.abrupt("return", Application.crypto.subtle.sign(algorithm, signingKey, info));
              case 2:
              case "end":
                return _context78.stop();
            }
          }, _callee78);
        }));
        function Sign(_x107, _x108, _x109) {
          return _Sign.apply(this, arguments);
        }
        return Sign;
      }()
    }, {
      key: "Verify",
      value: function () {
        var _Verify = _asyncToGenerator(_regeneratorRuntime().mark(function _callee79(signedInfo, key, signatureValue, algorithm) {
          var info;
          return _regeneratorRuntime().wrap(function _callee79$(_context79) {
            while (1) switch (_context79.prev = _context79.next) {
              case 0:
                info = Convert$1.FromString(signedInfo, "utf8");
                return _context79.abrupt("return", Application.crypto.subtle.verify(algorithm || this.algorithm, key, signatureValue, info));
              case 2:
              case "end":
                return _context79.stop();
            }
          }, _callee79, this);
        }));
        function Verify(_x110, _x111, _x112, _x113) {
          return _Verify.apply(this, arguments);
        }
        return Verify;
      }()
    }]);
  }(XmlAlgorithm);
  var SHA1 = "SHA-1";
  var SHA256 = "SHA-256";
  var SHA384 = "SHA-384";
  var SHA512 = "SHA-512";
  var SHA1_NAMESPACE = "http://www.w3.org/2000/09/xmldsig#sha1";
  var SHA256_NAMESPACE = "http://www.w3.org/2001/04/xmlenc#sha256";
  var SHA384_NAMESPACE = "http://www.w3.org/2001/04/xmldsig-more#sha384";
  var SHA512_NAMESPACE = "http://www.w3.org/2001/04/xmlenc#sha512";
  var Sha1 = function (_HashAlgorithm) {
    function Sha1() {
      var _this179;
      _classCallCheck(this, Sha1);
      _this179 = _callSuper(this, Sha1, arguments);
      _this179.algorithm = {
        name: SHA1
      };
      _this179.namespaceURI = SHA1_NAMESPACE;
      return _this179;
    }
    _inherits(Sha1, _HashAlgorithm);
    return _createClass(Sha1);
  }(HashAlgorithm);
  var Sha256 = function (_HashAlgorithm2) {
    function Sha256() {
      var _this180;
      _classCallCheck(this, Sha256);
      _this180 = _callSuper(this, Sha256, arguments);
      _this180.algorithm = {
        name: SHA256
      };
      _this180.namespaceURI = SHA256_NAMESPACE;
      return _this180;
    }
    _inherits(Sha256, _HashAlgorithm2);
    return _createClass(Sha256);
  }(HashAlgorithm);
  var Sha384 = function (_HashAlgorithm3) {
    function Sha384() {
      var _this181;
      _classCallCheck(this, Sha384);
      _this181 = _callSuper(this, Sha384, arguments);
      _this181.algorithm = {
        name: SHA384
      };
      _this181.namespaceURI = SHA384_NAMESPACE;
      return _this181;
    }
    _inherits(Sha384, _HashAlgorithm3);
    return _createClass(Sha384);
  }(HashAlgorithm);
  var Sha512 = function (_HashAlgorithm4) {
    function Sha512() {
      var _this182;
      _classCallCheck(this, Sha512);
      _this182 = _callSuper(this, Sha512, arguments);
      _this182.algorithm = {
        name: SHA512
      };
      _this182.namespaceURI = SHA512_NAMESPACE;
      return _this182;
    }
    _inherits(Sha512, _HashAlgorithm4);
    return _createClass(Sha512);
  }(HashAlgorithm);
  var ECDSA = "ECDSA";
  var ECDSA_SHA1_NAMESPACE = "http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha1";
  var ECDSA_SHA256_NAMESPACE = "http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256";
  var ECDSA_SHA384_NAMESPACE = "http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha384";
  var ECDSA_SHA512_NAMESPACE = "http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha512";
  var EcdsaSha1 = function (_SignatureAlgorithm) {
    function EcdsaSha1() {
      var _this183;
      _classCallCheck(this, EcdsaSha1);
      _this183 = _callSuper(this, EcdsaSha1, arguments);
      _this183.algorithm = {
        name: ECDSA,
        hash: {
          name: SHA1
        }
      };
      _this183.namespaceURI = ECDSA_SHA1_NAMESPACE;
      return _this183;
    }
    _inherits(EcdsaSha1, _SignatureAlgorithm);
    return _createClass(EcdsaSha1);
  }(SignatureAlgorithm);
  var EcdsaSha256 = function (_SignatureAlgorithm2) {
    function EcdsaSha256() {
      var _this184;
      _classCallCheck(this, EcdsaSha256);
      _this184 = _callSuper(this, EcdsaSha256, arguments);
      _this184.algorithm = {
        name: ECDSA,
        hash: {
          name: SHA256
        }
      };
      _this184.namespaceURI = ECDSA_SHA256_NAMESPACE;
      return _this184;
    }
    _inherits(EcdsaSha256, _SignatureAlgorithm2);
    return _createClass(EcdsaSha256);
  }(SignatureAlgorithm);
  var EcdsaSha384 = function (_SignatureAlgorithm3) {
    function EcdsaSha384() {
      var _this185;
      _classCallCheck(this, EcdsaSha384);
      _this185 = _callSuper(this, EcdsaSha384, arguments);
      _this185.algorithm = {
        name: ECDSA,
        hash: {
          name: SHA384
        }
      };
      _this185.namespaceURI = ECDSA_SHA384_NAMESPACE;
      return _this185;
    }
    _inherits(EcdsaSha384, _SignatureAlgorithm3);
    return _createClass(EcdsaSha384);
  }(SignatureAlgorithm);
  var EcdsaSha512 = function (_SignatureAlgorithm4) {
    function EcdsaSha512() {
      var _this186;
      _classCallCheck(this, EcdsaSha512);
      _this186 = _callSuper(this, EcdsaSha512, arguments);
      _this186.algorithm = {
        name: ECDSA,
        hash: {
          name: SHA512
        }
      };
      _this186.namespaceURI = ECDSA_SHA512_NAMESPACE;
      return _this186;
    }
    _inherits(EcdsaSha512, _SignatureAlgorithm4);
    return _createClass(EcdsaSha512);
  }(SignatureAlgorithm);
  var HMAC = "HMAC";
  var HMAC_SHA1_NAMESPACE = "http://www.w3.org/2000/09/xmldsig#hmac-sha1";
  var HMAC_SHA256_NAMESPACE = "http://www.w3.org/2001/04/xmldsig-more#hmac-sha256";
  var HMAC_SHA384_NAMESPACE = "http://www.w3.org/2001/04/xmldsig-more#hmac-sha384";
  var HMAC_SHA512_NAMESPACE = "http://www.w3.org/2001/04/xmldsig-more#hmac-sha512";
  var HmacSha1 = function (_SignatureAlgorithm5) {
    function HmacSha1() {
      var _this187;
      _classCallCheck(this, HmacSha1);
      _this187 = _callSuper(this, HmacSha1, arguments);
      _this187.algorithm = {
        name: HMAC,
        hash: {
          name: SHA1
        }
      };
      _this187.namespaceURI = HMAC_SHA1_NAMESPACE;
      return _this187;
    }
    _inherits(HmacSha1, _SignatureAlgorithm5);
    return _createClass(HmacSha1);
  }(SignatureAlgorithm);
  var HmacSha256 = function (_SignatureAlgorithm6) {
    function HmacSha256() {
      var _this188;
      _classCallCheck(this, HmacSha256);
      _this188 = _callSuper(this, HmacSha256, arguments);
      _this188.algorithm = {
        name: HMAC,
        hash: {
          name: SHA256
        }
      };
      _this188.namespaceURI = HMAC_SHA256_NAMESPACE;
      return _this188;
    }
    _inherits(HmacSha256, _SignatureAlgorithm6);
    return _createClass(HmacSha256);
  }(SignatureAlgorithm);
  var HmacSha384 = function (_SignatureAlgorithm7) {
    function HmacSha384() {
      var _this189;
      _classCallCheck(this, HmacSha384);
      _this189 = _callSuper(this, HmacSha384, arguments);
      _this189.algorithm = {
        name: HMAC,
        hash: {
          name: SHA384
        }
      };
      _this189.namespaceURI = HMAC_SHA384_NAMESPACE;
      return _this189;
    }
    _inherits(HmacSha384, _SignatureAlgorithm7);
    return _createClass(HmacSha384);
  }(SignatureAlgorithm);
  var HmacSha512 = function (_SignatureAlgorithm8) {
    function HmacSha512() {
      var _this190;
      _classCallCheck(this, HmacSha512);
      _this190 = _callSuper(this, HmacSha512, arguments);
      _this190.algorithm = {
        name: HMAC,
        hash: {
          name: SHA512
        }
      };
      _this190.namespaceURI = HMAC_SHA512_NAMESPACE;
      return _this190;
    }
    _inherits(HmacSha512, _SignatureAlgorithm8);
    return _createClass(HmacSha512);
  }(SignatureAlgorithm);
  var RSA_PKCS1 = "RSASSA-PKCS1-v1_5";
  var RSA_PKCS1_SHA1_NAMESPACE = "http://www.w3.org/2000/09/xmldsig#rsa-sha1";
  var RSA_PKCS1_SHA256_NAMESPACE = "http://www.w3.org/2001/04/xmldsig-more#rsa-sha256";
  var RSA_PKCS1_SHA384_NAMESPACE = "http://www.w3.org/2001/04/xmldsig-more#rsa-sha384";
  var RSA_PKCS1_SHA512_NAMESPACE = "http://www.w3.org/2001/04/xmldsig-more#rsa-sha512";
  var RsaPkcs1Sha1 = function (_SignatureAlgorithm9) {
    function RsaPkcs1Sha1() {
      var _this191;
      _classCallCheck(this, RsaPkcs1Sha1);
      _this191 = _callSuper(this, RsaPkcs1Sha1, arguments);
      _this191.algorithm = {
        name: RSA_PKCS1,
        hash: {
          name: SHA1
        }
      };
      _this191.namespaceURI = RSA_PKCS1_SHA1_NAMESPACE;
      return _this191;
    }
    _inherits(RsaPkcs1Sha1, _SignatureAlgorithm9);
    return _createClass(RsaPkcs1Sha1);
  }(SignatureAlgorithm);
  var RsaPkcs1Sha256 = function (_SignatureAlgorithm10) {
    function RsaPkcs1Sha256() {
      var _this192;
      _classCallCheck(this, RsaPkcs1Sha256);
      _this192 = _callSuper(this, RsaPkcs1Sha256, arguments);
      _this192.algorithm = {
        name: RSA_PKCS1,
        hash: {
          name: SHA256
        }
      };
      _this192.namespaceURI = RSA_PKCS1_SHA256_NAMESPACE;
      return _this192;
    }
    _inherits(RsaPkcs1Sha256, _SignatureAlgorithm10);
    return _createClass(RsaPkcs1Sha256);
  }(SignatureAlgorithm);
  var RsaPkcs1Sha384 = function (_SignatureAlgorithm11) {
    function RsaPkcs1Sha384() {
      var _this193;
      _classCallCheck(this, RsaPkcs1Sha384);
      _this193 = _callSuper(this, RsaPkcs1Sha384, arguments);
      _this193.algorithm = {
        name: RSA_PKCS1,
        hash: {
          name: SHA384
        }
      };
      _this193.namespaceURI = RSA_PKCS1_SHA384_NAMESPACE;
      return _this193;
    }
    _inherits(RsaPkcs1Sha384, _SignatureAlgorithm11);
    return _createClass(RsaPkcs1Sha384);
  }(SignatureAlgorithm);
  var RsaPkcs1Sha512 = function (_SignatureAlgorithm12) {
    function RsaPkcs1Sha512() {
      var _this194;
      _classCallCheck(this, RsaPkcs1Sha512);
      _this194 = _callSuper(this, RsaPkcs1Sha512, arguments);
      _this194.algorithm = {
        name: RSA_PKCS1,
        hash: {
          name: SHA512
        }
      };
      _this194.namespaceURI = RSA_PKCS1_SHA512_NAMESPACE;
      return _this194;
    }
    _inherits(RsaPkcs1Sha512, _SignatureAlgorithm12);
    return _createClass(RsaPkcs1Sha512);
  }(SignatureAlgorithm);
  var RSA_PSS = "RSA-PSS";
  var RSA_PSS_WITH_PARAMS_NAMESPACE = "http://www.w3.org/2007/05/xmldsig-more#rsa-pss";
  var RsaPssBase = function (_SignatureAlgorithm13) {
    function RsaPssBase(saltLength) {
      var _this195;
      _classCallCheck(this, RsaPssBase);
      _this195 = _callSuper(this, RsaPssBase);
      _this195.algorithm = {
        name: RSA_PSS,
        hash: {
          name: SHA1
        }
      };
      _this195.namespaceURI = RSA_PSS_WITH_PARAMS_NAMESPACE;
      if (saltLength) {
        _this195.algorithm.saltLength = saltLength;
      }
      return _this195;
    }
    _inherits(RsaPssBase, _SignatureAlgorithm13);
    return _createClass(RsaPssBase);
  }(SignatureAlgorithm);
  var RsaPssSha1 = function (_RsaPssBase) {
    function RsaPssSha1(saltLength) {
      var _this196;
      _classCallCheck(this, RsaPssSha1);
      _this196 = _callSuper(this, RsaPssSha1, [saltLength]);
      _this196.algorithm.hash.name = SHA1;
      return _this196;
    }
    _inherits(RsaPssSha1, _RsaPssBase);
    return _createClass(RsaPssSha1);
  }(RsaPssBase);
  var RsaPssSha256 = function (_RsaPssBase2) {
    function RsaPssSha256(saltLength) {
      var _this197;
      _classCallCheck(this, RsaPssSha256);
      _this197 = _callSuper(this, RsaPssSha256, [saltLength]);
      _this197.algorithm.hash.name = SHA256;
      return _this197;
    }
    _inherits(RsaPssSha256, _RsaPssBase2);
    return _createClass(RsaPssSha256);
  }(RsaPssBase);
  var RsaPssSha384 = function (_RsaPssBase3) {
    function RsaPssSha384(saltLength) {
      var _this198;
      _classCallCheck(this, RsaPssSha384);
      _this198 = _callSuper(this, RsaPssSha384, [saltLength]);
      _this198.algorithm.hash.name = SHA384;
      return _this198;
    }
    _inherits(RsaPssSha384, _RsaPssBase3);
    return _createClass(RsaPssSha384);
  }(RsaPssBase);
  var RsaPssSha512 = function (_RsaPssBase4) {
    function RsaPssSha512(saltLength) {
      var _this199;
      _classCallCheck(this, RsaPssSha512);
      _this199 = _callSuper(this, RsaPssSha512, [saltLength]);
      _this199.algorithm.hash.name = SHA512;
      return _this199;
    }
    _inherits(RsaPssSha512, _RsaPssBase4);
    return _createClass(RsaPssSha512);
  }(RsaPssBase);
  var RSA_PSS_SHA1_NAMESPACE = "http://www.w3.org/2007/05/xmldsig-more#sha1-rsa-MGF1";
  var RSA_PSS_SHA256_NAMESPACE = "http://www.w3.org/2007/05/xmldsig-more#sha256-rsa-MGF1";
  var RSA_PSS_SHA384_NAMESPACE = "http://www.w3.org/2007/05/xmldsig-more#sha384-rsa-MGF1";
  var RSA_PSS_SHA512_NAMESPACE = "http://www.w3.org/2007/05/xmldsig-more#sha512-rsa-MGF1";
  var RsaPssWithoutParamsBase = function (_SignatureAlgorithm14) {
    function RsaPssWithoutParamsBase() {
      var _this200;
      _classCallCheck(this, RsaPssWithoutParamsBase);
      _this200 = _callSuper(this, RsaPssWithoutParamsBase);
      _this200.algorithm = {
        name: RSA_PSS,
        hash: {
          name: SHA1
        }
      };
      _this200.namespaceURI = RSA_PSS_SHA1_NAMESPACE;
      return _this200;
    }
    _inherits(RsaPssWithoutParamsBase, _SignatureAlgorithm14);
    return _createClass(RsaPssWithoutParamsBase);
  }(SignatureAlgorithm);
  var RsaPssWithoutParamsSha1 = function (_RsaPssWithoutParamsB) {
    function RsaPssWithoutParamsSha1() {
      var _this201;
      _classCallCheck(this, RsaPssWithoutParamsSha1);
      _this201 = _callSuper(this, RsaPssWithoutParamsSha1);
      _this201.algorithm.hash.name = SHA1;
      _this201.algorithm.saltLength = 20;
      return _this201;
    }
    _inherits(RsaPssWithoutParamsSha1, _RsaPssWithoutParamsB);
    return _createClass(RsaPssWithoutParamsSha1);
  }(RsaPssWithoutParamsBase);
  var RsaPssWithoutParamsSha256 = function (_RsaPssWithoutParamsB2) {
    function RsaPssWithoutParamsSha256() {
      var _this202;
      _classCallCheck(this, RsaPssWithoutParamsSha256);
      _this202 = _callSuper(this, RsaPssWithoutParamsSha256);
      _this202.algorithm.hash.name = SHA256;
      _this202.algorithm.saltLength = 32;
      return _this202;
    }
    _inherits(RsaPssWithoutParamsSha256, _RsaPssWithoutParamsB2);
    return _createClass(RsaPssWithoutParamsSha256);
  }(RsaPssWithoutParamsBase);
  var RsaPssWithoutParamsSha384 = function (_RsaPssWithoutParamsB3) {
    function RsaPssWithoutParamsSha384() {
      var _this203;
      _classCallCheck(this, RsaPssWithoutParamsSha384);
      _this203 = _callSuper(this, RsaPssWithoutParamsSha384);
      _this203.algorithm.hash.name = SHA384;
      _this203.algorithm.saltLength = 48;
      return _this203;
    }
    _inherits(RsaPssWithoutParamsSha384, _RsaPssWithoutParamsB3);
    return _createClass(RsaPssWithoutParamsSha384);
  }(RsaPssWithoutParamsBase);
  var RsaPssWithoutParamsSha512 = function (_RsaPssWithoutParamsB4) {
    function RsaPssWithoutParamsSha512() {
      var _this204;
      _classCallCheck(this, RsaPssWithoutParamsSha512);
      _this204 = _callSuper(this, RsaPssWithoutParamsSha512);
      _this204.algorithm.hash.name = SHA512;
      _this204.algorithm.saltLength = 64;
      return _this204;
    }
    _inherits(RsaPssWithoutParamsSha512, _RsaPssWithoutParamsB4);
    return _createClass(RsaPssWithoutParamsSha512);
  }(RsaPssWithoutParamsBase);
  exports.XmlCanonicalizerState = void 0;
  (function (XmlCanonicalizerState) {
    XmlCanonicalizerState[XmlCanonicalizerState["BeforeDocElement"] = 0] = "BeforeDocElement";
    XmlCanonicalizerState[XmlCanonicalizerState["InsideDocElement"] = 1] = "InsideDocElement";
    XmlCanonicalizerState[XmlCanonicalizerState["AfterDocElement"] = 2] = "AfterDocElement";
  })(exports.XmlCanonicalizerState || (exports.XmlCanonicalizerState = {}));
  var XmlCanonicalizer = function () {
    function XmlCanonicalizer(withComments, excC14N) {
      var propagatedNamespaces = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new NamespaceManager();
      _classCallCheck(this, XmlCanonicalizer);
      this.propagatedNamespaces = new NamespaceManager();
      this.result = [];
      this.visibleNamespaces = new NamespaceManager();
      this.inclusiveNamespacesPrefixList = [];
      this.state = exports.XmlCanonicalizerState.BeforeDocElement;
      this.withComments = withComments;
      this.exclusive = excC14N;
      this.propagatedNamespaces = propagatedNamespaces;
    }
    return _createClass(XmlCanonicalizer, [{
      key: "InclusiveNamespacesPrefixList",
      get: function get() {
        return this.inclusiveNamespacesPrefixList.join(" ");
      },
      set: function set(value) {
        this.inclusiveNamespacesPrefixList = value.split(" ");
      }
    }, {
      key: "Canonicalize",
      value: function Canonicalize(node) {
        if (!node) {
          throw new XmlError(XE.CRYPTOGRAPHIC, "Parameter 1 is not Node");
        }
        this.WriteNode(node);
        var res = this.result.join("");
        return res;
      }
    }, {
      key: "WriteNode",
      value: function WriteNode(node) {
        switch (node.nodeType) {
          case XmlNodeType.Document:
          case XmlNodeType.DocumentFragment:
            this.WriteDocumentNode(node);
            break;
          case XmlNodeType.Element:
            this.WriteElementNode(node);
            break;
          case XmlNodeType.CDATA:
          case XmlNodeType.SignificantWhitespace:
          case XmlNodeType.Text:
            if (!isDocument(node.parentNode)) {
              this.WriteTextNode(node);
            }
            break;
          case XmlNodeType.Whitespace:
            if (this.state === exports.XmlCanonicalizerState.InsideDocElement) {
              this.WriteTextNode(node);
            }
            break;
          case XmlNodeType.Comment:
            this.WriteCommentNode(node);
            break;
          case XmlNodeType.ProcessingInstruction:
            this.WriteProcessingInstructionNode(node);
            break;
          case XmlNodeType.EntityReference:
            for (var i = 0; i < node.childNodes.length; i++) {
              this.WriteNode(node.childNodes[i]);
            }
            break;
          case XmlNodeType.Attribute:
            throw new XmlError(XE.CRYPTOGRAPHIC, "Attribute node is impossible here");
          case XmlNodeType.EndElement:
            throw new XmlError(XE.CRYPTOGRAPHIC, "Attribute node is impossible here");
          case XmlNodeType.EndEntity:
            throw new XmlError(XE.CRYPTOGRAPHIC, "Attribute node is impossible here");
          case XmlNodeType.DocumentType:
          case XmlNodeType.Entity:
          case XmlNodeType.Notation:
          case XmlNodeType.XmlDeclaration:
            break;
        }
      }
    }, {
      key: "WriteDocumentNode",
      value: function WriteDocumentNode(node) {
        this.state = exports.XmlCanonicalizerState.BeforeDocElement;
        for (var child = node.firstChild; child != null; child = child.nextSibling) {
          this.WriteNode(child);
        }
      }
    }, {
      key: "WriteCommentNode",
      value: function WriteCommentNode(node) {
        if (this.withComments) {
          if (this.state === exports.XmlCanonicalizerState.AfterDocElement) {
            this.result.push(String.fromCharCode(10) + "<!--");
          } else {
            this.result.push("<!--");
          }
          this.result.push(this.NormalizeString(node.nodeValue, XmlNodeType.Comment));
          if (this.state === exports.XmlCanonicalizerState.BeforeDocElement) {
            this.result.push("-->" + String.fromCharCode(10));
          } else {
            this.result.push("-->");
          }
        }
      }
    }, {
      key: "WriteTextNode",
      value: function WriteTextNode(node) {
        this.result.push(this.NormalizeString(node.nodeValue, node.nodeType));
      }
    }, {
      key: "WriteProcessingInstructionNode",
      value: function WriteProcessingInstructionNode(node) {
        var nodeName = node.nodeName || node.tagName;
        if (nodeName === "xml") {
          return;
        }
        if (this.state === exports.XmlCanonicalizerState.AfterDocElement) {
          this.result.push("\n<?");
        } else {
          this.result.push("<?");
        }
        this.result.push(nodeName);
        if (node.nodeValue) {
          this.result.push(" ");
          this.result.push(this.NormalizeString(node.nodeValue, XmlNodeType.ProcessingInstruction));
        }
        if (this.state === exports.XmlCanonicalizerState.BeforeDocElement) {
          this.result.push("?>\n");
        } else {
          this.result.push("?>");
        }
      }
    }, {
      key: "WriteElementNode",
      value: function WriteElementNode(node) {
        var state = this.state;
        if (this.state === exports.XmlCanonicalizerState.BeforeDocElement) {
          this.state = exports.XmlCanonicalizerState.InsideDocElement;
        }
        this.result.push("<");
        this.result.push(node.nodeName);
        var visibleNamespacesCount = this.WriteNamespacesAxis(node);
        this.WriteAttributesAxis(node);
        this.result.push(">");
        for (var n = node.firstChild; n != null; n = n.nextSibling) {
          this.WriteNode(n);
        }
        this.result.push("</");
        this.result.push(node.nodeName);
        this.result.push(">");
        if (state === exports.XmlCanonicalizerState.BeforeDocElement) {
          this.state = exports.XmlCanonicalizerState.AfterDocElement;
        }
        while (visibleNamespacesCount--) {
          this.visibleNamespaces.Pop();
        }
      }
    }, {
      key: "WriteNamespacesAxis",
      value: function WriteNamespacesAxis(node) {
        var _this205 = this;
        var list = [];
        var visibleNamespacesCount = 0;
        for (var i = 0; i < node.attributes.length; i++) {
          var attribute = node.attributes[i];
          if (!IsNamespaceNode(attribute)) {
            if (attribute.prefix && !this.IsNamespaceRendered(attribute.prefix, attribute.namespaceURI)) {
              var ns = {
                prefix: attribute.prefix,
                namespace: attribute.namespaceURI
              };
              list.push(ns);
              this.visibleNamespaces.Add(ns);
              visibleNamespacesCount++;
            }
            continue;
          }
          if (attribute.localName === "xmlns" && !attribute.prefix && !attribute.nodeValue) {
            var _ns = {
              prefix: attribute.prefix,
              namespace: attribute.nodeValue
            };
            list.push(_ns);
            this.visibleNamespaces.Add(_ns);
            visibleNamespacesCount++;
          }
          var prefix = null;
          var matches = void 0;
          if (matches = /xmlns:([\w\.-]+)/.exec(attribute.nodeName)) {
            prefix = matches[1];
          }
          var printable = true;
          if (this.exclusive && !this.IsNamespaceInclusive(node, prefix)) {
            var used = IsNamespaceUsed(node, prefix);
            if (used > 1) {
              printable = false;
            } else if (used === 0) {
              continue;
            }
          }
          if (this.IsNamespaceRendered(prefix, attribute.nodeValue)) {
            continue;
          }
          if (printable) {
            var _ns2 = {
              prefix: prefix,
              namespace: attribute.nodeValue
            };
            list.push(_ns2);
            this.visibleNamespaces.Add(_ns2);
            visibleNamespacesCount++;
          }
        }
        if (!this.IsNamespaceRendered(node.prefix, node.namespaceURI) && node.namespaceURI !== "http://www.w3.org/2000/xmlns/") {
          var _ns3 = {
            prefix: node.prefix,
            namespace: node.namespaceURI
          };
          list.push(_ns3);
          this.visibleNamespaces.Add(_ns3);
          visibleNamespacesCount++;
        }
        list.sort(XmlDsigC14NTransformNamespacesComparer);
        var prevPrefix = null;
        list.forEach(function (n) {
          if (n.prefix === prevPrefix) {
            return;
          }
          prevPrefix = n.prefix;
          _this205.result.push(" xmlns");
          if (n.prefix) {
            _this205.result.push(":" + n.prefix);
          }
          _this205.result.push("=\"");
          _this205.result.push(n.namespace);
          _this205.result.push("\"");
        });
        return visibleNamespacesCount;
      }
    }, {
      key: "WriteAttributesAxis",
      value: function WriteAttributesAxis(node) {
        var _this206 = this;
        var list = [];
        for (var i = 0; i < node.attributes.length; i++) {
          var attribute = node.attributes[i];
          if (!IsNamespaceNode(attribute)) {
            list.push(attribute);
          }
        }
        list.sort(XmlDsigC14NTransformAttributesComparer);
        list.forEach(function (attribute) {
          if (attribute != null) {
            _this206.result.push(" ");
            _this206.result.push(attribute.nodeName);
            _this206.result.push("=\"");
            _this206.result.push(_this206.NormalizeString(attribute.nodeValue, XmlNodeType.Attribute));
            _this206.result.push("\"");
          }
        });
      }
    }, {
      key: "NormalizeString",
      value: function NormalizeString(input, type) {
        var sb = [];
        if (input) {
          for (var i = 0; i < input.length; i++) {
            var ch = input[i];
            if (ch === "<" && (type === XmlNodeType.Attribute || this.IsTextNode(type))) {
              sb.push("&lt;");
            } else if (ch === ">" && this.IsTextNode(type)) {
              sb.push("&gt;");
            } else if (ch === "&" && (type === XmlNodeType.Attribute || this.IsTextNode(type))) {
              sb.push("&amp;");
            } else if (ch === "\"" && type === XmlNodeType.Attribute) {
              sb.push("&quot;");
            } else if (ch === "\t" && type === XmlNodeType.Attribute) {
              sb.push("&#x9;");
            } else if (ch === "\n" && type === XmlNodeType.Attribute) {
              sb.push("&#xA;");
            } else if (ch === "\r") {
              sb.push("&#xD;");
            } else {
              sb.push(ch);
            }
          }
        }
        return sb.join("");
      }
    }, {
      key: "IsTextNode",
      value: function IsTextNode(type) {
        switch (type) {
          case XmlNodeType.Text:
          case XmlNodeType.CDATA:
          case XmlNodeType.SignificantWhitespace:
          case XmlNodeType.Whitespace:
            return true;
        }
        return false;
      }
    }, {
      key: "IsNamespaceInclusive",
      value: function IsNamespaceInclusive(node, prefix) {
        var prefix2 = prefix || null;
        if (node.prefix === prefix2) {
          return false;
        }
        return this.inclusiveNamespacesPrefixList.indexOf(prefix2 || "") !== -1;
      }
    }, {
      key: "IsNamespaceRendered",
      value: function IsNamespaceRendered(prefix, uri) {
        prefix = prefix || "";
        uri = uri || "";
        if (!prefix && !uri) {
          return true;
        }
        if (prefix === "xml" && uri === "http://www.w3.org/XML/1998/namespace") {
          return true;
        }
        var ns = this.visibleNamespaces.GetPrefix(prefix);
        if (ns) {
          return ns.namespace === uri;
        }
        return false;
      }
    }]);
  }();
  function XmlDsigC14NTransformNamespacesComparer(x, y) {
    if (x == y) {
      return 0;
    } else if (!x) {
      return -1;
    } else if (!y) {
      return 1;
    } else if (!x.prefix) {
      return -1;
    } else if (!y.prefix) {
      return 1;
    } else if (x.prefix < y.prefix) {
      return -1;
    } else if (x.prefix > y.prefix) {
      return 1;
    } else {
      return 0;
    }
  }
  function XmlDsigC14NTransformAttributesComparer(x, y) {
    if (!x.namespaceURI && y.namespaceURI) {
      return -1;
    }
    if (!y.namespaceURI && x.namespaceURI) {
      return 1;
    }
    var left = x.namespaceURI + x.localName;
    var right = y.namespaceURI + y.localName;
    if (left === right) {
      return 0;
    } else if (left < right) {
      return -1;
    } else {
      return 1;
    }
  }
  function IsNamespaceUsed(node, prefix) {
    var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var prefix2 = prefix || null;
    if (node.prefix === prefix2) {
      return ++result;
    }
    if (node.attributes) {
      for (var i = 0; i < node.attributes.length; i++) {
        var attr = node.attributes[i];
        if (!IsNamespaceNode(attr) && prefix && node.attributes[i].prefix === prefix) {
          return ++result;
        }
      }
    }
    for (var n = node.firstChild; !!n; n = n.nextSibling) {
      if (n.nodeType === XmlNodeType.Element) {
        var el = n;
        var res = IsNamespaceUsed(el, prefix, result);
        if (n.nodeType === XmlNodeType.Element && res) {
          return ++result + res;
        }
      }
    }
    return result;
  }
  function IsNamespaceNode(node) {
    var reg = /xmlns:/;
    if (node !== null && node.nodeType === XmlNodeType.Attribute && (node.nodeName === "xmlns" || reg.test(node.nodeName))) {
      return true;
    }
    return false;
  }
  function __decorate(decorators, target, key, desc) {
    var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  }
  typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };
  var XmlSignature = {
    DefaultCanonMethod: "http://www.w3.org/TR/2001/REC-xml-c14n-20010315",
    DefaultDigestMethod: "http://www.w3.org/2001/04/xmlenc#sha256",
    DefaultPrefix: "ds",
    ElementNames: {
      CanonicalizationMethod: "CanonicalizationMethod",
      DigestMethod: "DigestMethod",
      DigestValue: "DigestValue",
      DSAKeyValue: "DSAKeyValue",
      DomainParameters: "DomainParameters",
      EncryptedKey: "EncryptedKey",
      HMACOutputLength: "HMACOutputLength",
      RSAPSSParams: "RSAPSSParams",
      MaskGenerationFunction: "MaskGenerationFunction",
      SaltLength: "SaltLength",
      KeyInfo: "KeyInfo",
      KeyName: "KeyName",
      KeyValue: "KeyValue",
      Modulus: "Modulus",
      Exponent: "Exponent",
      Manifest: "Manifest",
      Object: "Object",
      Reference: "Reference",
      RetrievalMethod: "RetrievalMethod",
      RSAKeyValue: "RSAKeyValue",
      ECDSAKeyValue: "ECDSAKeyValue",
      NamedCurve: "NamedCurve",
      PublicKey: "PublicKey",
      Signature: "Signature",
      SignatureMethod: "SignatureMethod",
      SignatureValue: "SignatureValue",
      SignedInfo: "SignedInfo",
      Transform: "Transform",
      Transforms: "Transforms",
      X509Data: "X509Data",
      PGPData: "PGPData",
      SPKIData: "SPKIData",
      SPKIexp: "SPKIexp",
      MgmtData: "MgmtData",
      X509IssuerSerial: "X509IssuerSerial",
      X509IssuerName: "X509IssuerName",
      X509SerialNumber: "X509SerialNumber",
      X509SKI: "X509SKI",
      X509SubjectName: "X509SubjectName",
      X509Certificate: "X509Certificate",
      X509CRL: "X509CRL",
      XPath: "XPath",
      X: "X",
      Y: "Y"
    },
    AttributeNames: {
      Algorithm: "Algorithm",
      Encoding: "Encoding",
      Id: "Id",
      MimeType: "MimeType",
      Type: "Type",
      URI: "URI"
    },
    AlgorithmNamespaces: {
      XmlDsigBase64Transform: "http://www.w3.org/2000/09/xmldsig#base64",
      XmlDsigC14NTransform: "http://www.w3.org/TR/2001/REC-xml-c14n-20010315",
      XmlDsigC14NWithCommentsTransform: "http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments",
      XmlDsigEnvelopedSignatureTransform: "http://www.w3.org/2000/09/xmldsig#enveloped-signature",
      XmlDsigXPathTransform: "http://www.w3.org/TR/1999/REC-xpath-19991116",
      XmlDsigXsltTransform: "http://www.w3.org/TR/1999/REC-xslt-19991116",
      XmlDsigExcC14NTransform: "http://www.w3.org/2001/10/xml-exc-c14n#",
      XmlDsigExcC14NWithCommentsTransform: "http://www.w3.org/2001/10/xml-exc-c14n#WithComments",
      XmlDecryptionTransform: "http://www.w3.org/2002/07/decrypt#XML",
      XmlLicenseTransform: "urn:mpeg:mpeg21:2003:01-REL-R-NS:licenseTransform"
    },
    Uri: {
      Manifest: "http://www.w3.org/2000/09/xmldsig#Manifest"
    },
    NamespaceURI: "http://www.w3.org/2000/09/xmldsig#",
    NamespaceURIMore: "http://www.w3.org/2007/05/xmldsig-more#",
    NamespaceURIPss: "http://www.example.org/xmldsig-pss/#"
  };
  exports.XmlSignatureObject = function (_XmlObject2) {
    function XmlSignatureObject() {
      _classCallCheck(this, XmlSignatureObject);
      return _callSuper(this, XmlSignatureObject, arguments);
    }
    _inherits(XmlSignatureObject, _XmlObject2);
    return _createClass(XmlSignatureObject);
  }(XmlObject);
  exports.XmlSignatureObject = __decorate([XmlElement({
    localName: "xmldsig",
    namespaceURI: XmlSignature.NamespaceURI,
    prefix: XmlSignature.DefaultPrefix
  })], exports.XmlSignatureObject);
  exports.XmlSignatureCollection = function (_XmlCollection) {
    function XmlSignatureCollection() {
      _classCallCheck(this, XmlSignatureCollection);
      return _callSuper(this, XmlSignatureCollection, arguments);
    }
    _inherits(XmlSignatureCollection, _XmlCollection);
    return _createClass(XmlSignatureCollection);
  }(XmlCollection);
  exports.XmlSignatureCollection = __decorate([XmlElement({
    localName: "xmldsig_collection",
    namespaceURI: XmlSignature.NamespaceURI,
    prefix: XmlSignature.DefaultPrefix
  })], exports.XmlSignatureCollection);
  var KeyInfoClause = function (_XmlSignatureObject) {
    function KeyInfoClause() {
      _classCallCheck(this, KeyInfoClause);
      return _callSuper(this, KeyInfoClause, arguments);
    }
    _inherits(KeyInfoClause, _XmlSignatureObject);
    return _createClass(KeyInfoClause);
  }(exports.XmlSignatureObject);
  exports.CanonicalizationMethod = function (_XmlSignatureObject2) {
    function CanonicalizationMethod() {
      _classCallCheck(this, CanonicalizationMethod);
      return _callSuper(this, CanonicalizationMethod, arguments);
    }
    _inherits(CanonicalizationMethod, _XmlSignatureObject2);
    return _createClass(CanonicalizationMethod);
  }(exports.XmlSignatureObject);
  __decorate([XmlAttribute({
    localName: XmlSignature.AttributeNames.Algorithm,
    required: true,
    defaultValue: XmlSignature.DefaultCanonMethod
  })], exports.CanonicalizationMethod.prototype, "Algorithm", void 0);
  exports.CanonicalizationMethod = __decorate([XmlElement({
    localName: XmlSignature.ElementNames.CanonicalizationMethod
  })], exports.CanonicalizationMethod);
  exports.DataObject = function (_XmlSignatureObject3) {
    function DataObject() {
      _classCallCheck(this, DataObject);
      return _callSuper(this, DataObject, arguments);
    }
    _inherits(DataObject, _XmlSignatureObject3);
    return _createClass(DataObject);
  }(exports.XmlSignatureObject);
  __decorate([XmlAttribute({
    localName: XmlSignature.AttributeNames.Id,
    defaultValue: ""
  })], exports.DataObject.prototype, "Id", void 0);
  __decorate([XmlAttribute({
    localName: XmlSignature.AttributeNames.MimeType,
    defaultValue: ""
  })], exports.DataObject.prototype, "MimeType", void 0);
  __decorate([XmlAttribute({
    localName: XmlSignature.AttributeNames.Encoding,
    defaultValue: ""
  })], exports.DataObject.prototype, "Encoding", void 0);
  exports.DataObject = __decorate([XmlElement({
    localName: XmlSignature.ElementNames.Object
  })], exports.DataObject);
  exports.DataObjects = function (_XmlSignatureCollecti) {
    function DataObjects() {
      _classCallCheck(this, DataObjects);
      return _callSuper(this, DataObjects, arguments);
    }
    _inherits(DataObjects, _XmlSignatureCollecti);
    return _createClass(DataObjects);
  }(exports.XmlSignatureCollection);
  exports.DataObjects = __decorate([XmlElement({
    localName: "xmldsig_objects",
    parser: exports.DataObject
  })], exports.DataObjects);
  exports.DigestMethod = function (_XmlSignatureObject4) {
    function DigestMethod(hashNamespace) {
      var _this207;
      _classCallCheck(this, DigestMethod);
      _this207 = _callSuper(this, DigestMethod);
      if (hashNamespace) {
        _this207.Algorithm = hashNamespace;
      }
      return _this207;
    }
    _inherits(DigestMethod, _XmlSignatureObject4);
    return _createClass(DigestMethod);
  }(exports.XmlSignatureObject);
  __decorate([XmlAttribute({
    localName: XmlSignature.AttributeNames.Algorithm,
    required: true,
    defaultValue: XmlSignature.DefaultDigestMethod
  })], exports.DigestMethod.prototype, "Algorithm", void 0);
  exports.DigestMethod = __decorate([XmlElement({
    localName: XmlSignature.ElementNames.DigestMethod
  })], exports.DigestMethod);
  exports.KeyInfo = function (_XmlSignatureCollecti2) {
    function KeyInfo() {
      _classCallCheck(this, KeyInfo);
      return _callSuper(this, KeyInfo, arguments);
    }
    _inherits(KeyInfo, _XmlSignatureCollecti2);
    return _createClass(KeyInfo, [{
      key: "OnLoadXml",
      value: function OnLoadXml(element) {
        for (var i = 0; i < element.childNodes.length; i++) {
          var node = element.childNodes.item(i);
          if (node.nodeType !== XmlNodeType.Element) {
            continue;
          }
          var KeyInfoClass = null;
          switch (node.localName) {
            case XmlSignature.ElementNames.KeyValue:
              KeyInfoClass = exports.KeyValue;
              break;
            case XmlSignature.ElementNames.X509Data:
              KeyInfoClass = exports.KeyInfoX509Data;
              break;
            case XmlSignature.ElementNames.SPKIData:
              KeyInfoClass = exports.SPKIData;
              break;
            case XmlSignature.ElementNames.KeyName:
            case XmlSignature.ElementNames.RetrievalMethod:
            case XmlSignature.ElementNames.PGPData:
            case XmlSignature.ElementNames.MgmtData:
          }
          if (KeyInfoClass) {
            var item = new KeyInfoClass();
            item.LoadXml(node);
            this.Add(item);
          }
        }
      }
    }]);
  }(exports.XmlSignatureCollection);
  __decorate([XmlAttribute({
    localName: XmlSignature.AttributeNames.Id,
    defaultValue: ""
  })], exports.KeyInfo.prototype, "Id", void 0);
  exports.KeyInfo = __decorate([XmlElement({
    localName: XmlSignature.ElementNames.KeyInfo
  })], exports.KeyInfo);
  exports.Transform = function (_XmlSignatureObject5) {
    function Transform() {
      var _this208;
      _classCallCheck(this, Transform);
      _this208 = _callSuper(this, Transform, arguments);
      _this208.innerXml = null;
      return _this208;
    }
    _inherits(Transform, _XmlSignatureObject5);
    return _createClass(Transform, [{
      key: "GetOutput",
      value: function GetOutput() {
        throw new XmlError(XE.METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "LoadInnerXml",
      value: function LoadInnerXml(node) {
        if (!node) {
          throw new XmlError(XE.PARAM_REQUIRED, "node");
        }
        this.innerXml = node;
      }
    }, {
      key: "GetInnerXml",
      value: function GetInnerXml() {
        return this.innerXml;
      }
    }]);
  }(exports.XmlSignatureObject);
  __decorate([XmlAttribute({
    localName: XmlSignature.AttributeNames.Algorithm,
    defaultValue: ""
  })], exports.Transform.prototype, "Algorithm", void 0);
  __decorate([XmlChildElement({
    localName: XmlSignature.ElementNames.XPath,
    defaultValue: ""
  })], exports.Transform.prototype, "XPath", void 0);
  exports.Transform = __decorate([XmlElement({
    localName: XmlSignature.ElementNames.Transform
  })], exports.Transform);
  var XmlDsigBase64Transform = function (_Transform) {
    function XmlDsigBase64Transform() {
      var _this209;
      _classCallCheck(this, XmlDsigBase64Transform);
      _this209 = _callSuper(this, XmlDsigBase64Transform, arguments);
      _this209.Algorithm = XmlSignature.AlgorithmNamespaces.XmlDsigBase64Transform;
      return _this209;
    }
    _inherits(XmlDsigBase64Transform, _Transform);
    return _createClass(XmlDsigBase64Transform, [{
      key: "GetOutput",
      value: function GetOutput() {
        if (!this.innerXml) {
          throw new XmlError(XE.PARAM_REQUIRED, "innerXml");
        }
        return Convert$1.FromString(this.innerXml.textContent || "", "base64");
      }
    }]);
  }(exports.Transform);
  var XmlDsigC14NTransform = function (_Transform2) {
    function XmlDsigC14NTransform() {
      var _this210;
      _classCallCheck(this, XmlDsigC14NTransform);
      _this210 = _callSuper(this, XmlDsigC14NTransform, arguments);
      _this210.Algorithm = "http://www.w3.org/TR/2001/REC-xml-c14n-20010315";
      _this210.xmlCanonicalizer = new XmlCanonicalizer(false, false);
      return _this210;
    }
    _inherits(XmlDsigC14NTransform, _Transform2);
    return _createClass(XmlDsigC14NTransform, [{
      key: "GetOutput",
      value: function GetOutput() {
        if (!this.innerXml) {
          throw new XmlError(XE.PARAM_REQUIRED, "innerXml");
        }
        return this.xmlCanonicalizer.Canonicalize(this.innerXml);
      }
    }]);
  }(exports.Transform);
  var XmlDsigC14NWithCommentsTransform = function (_XmlDsigC14NTransform) {
    function XmlDsigC14NWithCommentsTransform() {
      var _this211;
      _classCallCheck(this, XmlDsigC14NWithCommentsTransform);
      _this211 = _callSuper(this, XmlDsigC14NWithCommentsTransform, arguments);
      _this211.Algorithm = "http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments";
      _this211.xmlCanonicalizer = new XmlCanonicalizer(true, false);
      return _this211;
    }
    _inherits(XmlDsigC14NWithCommentsTransform, _XmlDsigC14NTransform);
    return _createClass(XmlDsigC14NWithCommentsTransform);
  }(XmlDsigC14NTransform);
  var XmlDsigEnvelopedSignatureTransform = function (_Transform3) {
    function XmlDsigEnvelopedSignatureTransform() {
      var _this212;
      _classCallCheck(this, XmlDsigEnvelopedSignatureTransform);
      _this212 = _callSuper(this, XmlDsigEnvelopedSignatureTransform, arguments);
      _this212.Algorithm = "http://www.w3.org/2000/09/xmldsig#enveloped-signature";
      return _this212;
    }
    _inherits(XmlDsigEnvelopedSignatureTransform, _Transform3);
    return _createClass(XmlDsigEnvelopedSignatureTransform, [{
      key: "GetOutput",
      value: function GetOutput() {
        var _a;
        if (!this.innerXml) {
          throw new XmlError(XE.PARAM_REQUIRED, "innerXml");
        }
        var child = this.innerXml.firstChild;
        var signatures = [];
        while (child) {
          if (isElement(child) && child.localName === XmlSignature.ElementNames.Signature && child.namespaceURI === XmlSignature.NamespaceURI) {
            signatures.push(child);
          }
          child = child.nextSibling;
        }
        for (var _i44 = 0, _signatures = signatures; _i44 < _signatures.length; _i44++) {
          var signature = _signatures[_i44];
          (_a = signature.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(signature);
        }
        return this.innerXml;
      }
    }]);
  }(exports.Transform);
  var XmlDsigExcC14NTransform = function (_Transform4) {
    function XmlDsigExcC14NTransform() {
      var _this213;
      _classCallCheck(this, XmlDsigExcC14NTransform);
      _this213 = _callSuper(this, XmlDsigExcC14NTransform, arguments);
      _this213.Algorithm = "http://www.w3.org/2001/10/xml-exc-c14n#";
      _this213.xmlCanonicalizer = new XmlCanonicalizer(false, true);
      return _this213;
    }
    _inherits(XmlDsigExcC14NTransform, _Transform4);
    return _createClass(XmlDsigExcC14NTransform, [{
      key: "InclusiveNamespacesPrefixList",
      get: function get() {
        return this.xmlCanonicalizer.InclusiveNamespacesPrefixList;
      },
      set: function set(value) {
        this.xmlCanonicalizer.InclusiveNamespacesPrefixList = value;
      }
    }, {
      key: "LoadXml",
      value: function LoadXml(param) {
        _superPropGet(XmlDsigExcC14NTransform, "LoadXml", this, 3)([param]);
        if (this.Element && this.Element.childNodes) {
          for (var i = 0; i < this.Element.childNodes.length; i++) {
            var element = this.Element.childNodes[i];
            if (element && element.nodeType === 1) {
              switch (element.localName) {
                case 'InclusiveNamespaces':
                  this.setInclusiveNamespacesElement(element);
                  break;
              }
            }
          }
        }
      }
    }, {
      key: "GetOutput",
      value: function GetOutput() {
        if (!this.innerXml) {
          throw new XmlError(XE.PARAM_REQUIRED, "innerXml");
        }
        return this.xmlCanonicalizer.Canonicalize(this.innerXml);
      }
    }, {
      key: "setInclusiveNamespacesElement",
      value: function setInclusiveNamespacesElement(element) {
        var prefixList = element.getAttribute('PrefixList');
        if (prefixList && prefixList.length > 0) {
          this.xmlCanonicalizer.InclusiveNamespacesPrefixList = prefixList;
        }
      }
    }]);
  }(exports.Transform);
  var XmlDsigExcC14NWithCommentsTransform = function (_XmlDsigExcC14NTransf) {
    function XmlDsigExcC14NWithCommentsTransform() {
      var _this214;
      _classCallCheck(this, XmlDsigExcC14NWithCommentsTransform);
      _this214 = _callSuper(this, XmlDsigExcC14NWithCommentsTransform, arguments);
      _this214.Algorithm = "http://www.w3.org/2001/10/xml-exc-c14n#WithComments";
      _this214.xmlCanonicalizer = new XmlCanonicalizer(true, true);
      return _this214;
    }
    _inherits(XmlDsigExcC14NWithCommentsTransform, _XmlDsigExcC14NTransf);
    return _createClass(XmlDsigExcC14NWithCommentsTransform);
  }(XmlDsigExcC14NTransform);
  function lookupParentNode(node) {
    return node.parentNode ? lookupParentNode(node.parentNode) : node;
  }
  var XmlDsigXPathTransform = function (_Transform5) {
    function XmlDsigXPathTransform() {
      var _this215;
      _classCallCheck(this, XmlDsigXPathTransform);
      _this215 = _callSuper(this, XmlDsigXPathTransform, arguments);
      _this215.Algorithm = XmlSignature.AlgorithmNamespaces.XmlDsigXPathTransform;
      return _this215;
    }
    _inherits(XmlDsigXPathTransform, _Transform5);
    return _createClass(XmlDsigXPathTransform, [{
      key: "GetOutput",
      value: function GetOutput() {
        if (!this.innerXml) {
          throw new XmlError(XE.PARAM_REQUIRED, "innerXml");
        }
        this.Filter(lookupParentNode(this.innerXml), this.XPath);
      }
    }, {
      key: "Filter",
      value: function Filter(node, xpath) {
        var _this216 = this;
        var childNodes = node.childNodes;
        var nodes = [];
        for (var i = 0; childNodes && i < childNodes.length; i++) {
          var child = childNodes.item(i);
          nodes.push(child);
        }
        nodes.forEach(function (child) {
          if (_this216.Evaluate(child, xpath)) {
            if (child.parentNode) {
              child.parentNode.removeChild(child);
            }
          } else {
            _this216.Filter(child, xpath);
          }
        });
      }
    }, {
      key: "GetEvaluator",
      value: function GetEvaluator(node) {
        if (typeof self !== "undefined") {
          return node.ownerDocument == null ? node : node.ownerDocument;
        } else {
          return require("xpath");
        }
      }
    }, {
      key: "Evaluate",
      value: function Evaluate(node, xpath) {
        try {
          var evaluator = this.GetEvaluator(node);
          var xpathEl = this.GetXml().firstChild;
          var xPath = "boolean(".concat(xpath, ")");
          var xpathResult = evaluator.evaluate(xPath, node, {
            lookupNamespaceURI: function lookupNamespaceURI(prefix) {
              return xpathEl.lookupNamespaceURI(prefix);
            }
          }, (typeof self === "undefined" ? require("xpath") : self).XPathResult.ANY_TYPE, null);
          return !xpathResult.booleanValue;
        } catch (e) {
          return false;
        }
      }
    }]);
  }(exports.Transform);
  __decorate([XmlChildElement({
    localName: XmlSignature.ElementNames.XPath,
    namespaceURI: XmlSignature.NamespaceURI,
    prefix: XmlSignature.DefaultPrefix,
    required: true
  })], XmlDsigXPathTransform.prototype, "XPath", void 0);
  exports.Transforms = function (_XmlSignatureCollecti3) {
    function Transforms() {
      _classCallCheck(this, Transforms);
      return _callSuper(this, Transforms, arguments);
    }
    _inherits(Transforms, _XmlSignatureCollecti3);
    return _createClass(Transforms, [{
      key: "OnLoadXml",
      value: function OnLoadXml(element) {
        _superPropGet(Transforms, "OnLoadXml", this, 3)([element]);
        this.items = this.GetIterator().map(function (item) {
          switch (item.Algorithm) {
            case XmlSignature.AlgorithmNamespaces.XmlDsigEnvelopedSignatureTransform:
              return ChangeTransform(item, XmlDsigEnvelopedSignatureTransform);
            case XmlSignature.AlgorithmNamespaces.XmlDsigC14NTransform:
              return ChangeTransform(item, XmlDsigC14NTransform);
            case XmlSignature.AlgorithmNamespaces.XmlDsigC14NWithCommentsTransform:
              return ChangeTransform(item, XmlDsigC14NWithCommentsTransform);
            case XmlSignature.AlgorithmNamespaces.XmlDsigExcC14NTransform:
              return ChangeTransform(item, XmlDsigExcC14NTransform);
            case XmlSignature.AlgorithmNamespaces.XmlDsigExcC14NWithCommentsTransform:
              return ChangeTransform(item, XmlDsigExcC14NWithCommentsTransform);
            case XmlSignature.AlgorithmNamespaces.XmlDsigBase64Transform:
              return ChangeTransform(item, XmlDsigBase64Transform);
            case XmlSignature.AlgorithmNamespaces.XmlDsigXPathTransform:
              return ChangeTransform(item, XmlDsigXPathTransform);
            default:
              throw new XmlError(XE.CRYPTOGRAPHIC_UNKNOWN_TRANSFORM, item.Algorithm);
          }
        });
      }
    }]);
  }(exports.XmlSignatureCollection);
  exports.Transforms = __decorate([XmlElement({
    localName: XmlSignature.ElementNames.Transforms,
    parser: exports.Transform
  })], exports.Transforms);
  function ChangeTransform(t1, t2) {
    var t = new t2();
    t.LoadXml(t1.Element);
    return t;
  }
  exports.Reference = function (_XmlSignatureObject6) {
    function Reference(uri) {
      var _this217;
      _classCallCheck(this, Reference);
      _this217 = _callSuper(this, Reference);
      _this217.DigestMethod = new exports.DigestMethod();
      if (uri) {
        _this217.Uri = uri;
      }
      return _this217;
    }
    _inherits(Reference, _XmlSignatureObject6);
    return _createClass(Reference);
  }(exports.XmlSignatureObject);
  __decorate([XmlAttribute({
    defaultValue: ""
  })], exports.Reference.prototype, "Id", void 0);
  __decorate([XmlAttribute({
    localName: XmlSignature.AttributeNames.URI
  })], exports.Reference.prototype, "Uri", void 0);
  __decorate([XmlAttribute({
    localName: XmlSignature.AttributeNames.Type,
    defaultValue: ""
  })], exports.Reference.prototype, "Type", void 0);
  __decorate([XmlChildElement({
    parser: exports.Transforms
  })], exports.Reference.prototype, "Transforms", void 0);
  __decorate([XmlChildElement({
    required: true,
    parser: exports.DigestMethod
  })], exports.Reference.prototype, "DigestMethod", void 0);
  __decorate([XmlChildElement({
    required: true,
    localName: XmlSignature.ElementNames.DigestValue,
    namespaceURI: XmlSignature.NamespaceURI,
    prefix: XmlSignature.DefaultPrefix,
    converter: XmlBase64Converter
  })], exports.Reference.prototype, "DigestValue", void 0);
  exports.Reference = __decorate([XmlElement({
    localName: XmlSignature.ElementNames.Reference
  })], exports.Reference);
  exports.References = function (_XmlSignatureCollecti4) {
    function References() {
      _classCallCheck(this, References);
      return _callSuper(this, References, arguments);
    }
    _inherits(References, _XmlSignatureCollecti4);
    return _createClass(References);
  }(exports.XmlSignatureCollection);
  exports.References = __decorate([XmlElement({
    localName: "References",
    parser: exports.Reference
  })], exports.References);
  exports.SignatureMethodOther = function (_XmlSignatureCollecti5) {
    function SignatureMethodOther() {
      _classCallCheck(this, SignatureMethodOther);
      return _callSuper(this, SignatureMethodOther, arguments);
    }
    _inherits(SignatureMethodOther, _XmlSignatureCollecti5);
    return _createClass(SignatureMethodOther, [{
      key: "OnLoadXml",
      value: function OnLoadXml(element) {
        for (var i = 0; i < element.childNodes.length; i++) {
          var node = element.childNodes.item(i);
          if (node.nodeType !== XmlNodeType.Element || node.nodeName === XmlSignature.ElementNames.HMACOutputLength) {
            continue;
          }
          var ParserClass = void 0;
          switch (node.localName) {
            case XmlSignature.ElementNames.RSAPSSParams:
              ParserClass = exports.PssAlgorithmParams;
              break;
          }
          if (ParserClass) {
            var xml = new ParserClass();
            xml.LoadXml(node);
            this.Add(xml);
          }
        }
      }
    }]);
  }(exports.XmlSignatureCollection);
  exports.SignatureMethodOther = __decorate([XmlElement({
    localName: "Other"
  })], exports.SignatureMethodOther);
  exports.SignatureMethod = function (_XmlSignatureObject7) {
    function SignatureMethod() {
      _classCallCheck(this, SignatureMethod);
      return _callSuper(this, SignatureMethod, arguments);
    }
    _inherits(SignatureMethod, _XmlSignatureObject7);
    return _createClass(SignatureMethod);
  }(exports.XmlSignatureObject);
  __decorate([XmlAttribute({
    localName: XmlSignature.AttributeNames.Algorithm,
    required: true,
    defaultValue: ""
  })], exports.SignatureMethod.prototype, "Algorithm", void 0);
  __decorate([XmlChildElement({
    localName: XmlSignature.ElementNames.HMACOutputLength,
    namespaceURI: XmlSignature.NamespaceURI,
    prefix: XmlSignature.DefaultPrefix,
    converter: XmlNumberConverter
  })], exports.SignatureMethod.prototype, "HMACOutputLength", void 0);
  __decorate([XmlChildElement({
    parser: exports.SignatureMethodOther,
    noRoot: true,
    minOccurs: 0
  })], exports.SignatureMethod.prototype, "Any", void 0);
  exports.SignatureMethod = __decorate([XmlElement({
    localName: XmlSignature.ElementNames.SignatureMethod
  })], exports.SignatureMethod);
  exports.SignedInfo = function (_XmlSignatureObject8) {
    function SignedInfo() {
      _classCallCheck(this, SignedInfo);
      return _callSuper(this, SignedInfo, arguments);
    }
    _inherits(SignedInfo, _XmlSignatureObject8);
    return _createClass(SignedInfo);
  }(exports.XmlSignatureObject);
  __decorate([XmlAttribute({
    localName: XmlSignature.AttributeNames.Id,
    defaultValue: ""
  })], exports.SignedInfo.prototype, "Id", void 0);
  __decorate([XmlChildElement({
    parser: exports.CanonicalizationMethod,
    required: true
  })], exports.SignedInfo.prototype, "CanonicalizationMethod", void 0);
  __decorate([XmlChildElement({
    parser: exports.SignatureMethod,
    required: true
  })], exports.SignedInfo.prototype, "SignatureMethod", void 0);
  __decorate([XmlChildElement({
    parser: exports.References,
    minOccurs: 1,
    noRoot: true
  })], exports.SignedInfo.prototype, "References", void 0);
  exports.SignedInfo = __decorate([XmlElement({
    localName: XmlSignature.ElementNames.SignedInfo
  })], exports.SignedInfo);
  exports.Signature = function (_XmlSignatureObject9) {
    function Signature() {
      _classCallCheck(this, Signature);
      return _callSuper(this, Signature, arguments);
    }
    _inherits(Signature, _XmlSignatureObject9);
    return _createClass(Signature);
  }(exports.XmlSignatureObject);
  __decorate([XmlAttribute({
    localName: XmlSignature.AttributeNames.Id,
    defaultValue: ""
  })], exports.Signature.prototype, "Id", void 0);
  __decorate([XmlChildElement({
    parser: exports.SignedInfo,
    required: true
  })], exports.Signature.prototype, "SignedInfo", void 0);
  __decorate([XmlChildElement({
    localName: XmlSignature.ElementNames.SignatureValue,
    namespaceURI: XmlSignature.NamespaceURI,
    prefix: XmlSignature.DefaultPrefix,
    required: true,
    converter: XmlBase64Converter,
    defaultValue: null
  })], exports.Signature.prototype, "SignatureValue", void 0);
  __decorate([XmlChildElement({
    parser: exports.KeyInfo
  })], exports.Signature.prototype, "KeyInfo", void 0);
  __decorate([XmlChildElement({
    parser: exports.DataObjects,
    noRoot: true
  })], exports.Signature.prototype, "ObjectList", void 0);
  exports.Signature = __decorate([XmlElement({
    localName: XmlSignature.ElementNames.Signature
  })], exports.Signature);
  var NAMESPACE_URI$1 = "http://www.w3.org/2001/04/xmldsig-more#";
  var PREFIX$1 = "ecdsa";
  exports.EcdsaPublicKey = function (_XmlObject3) {
    function EcdsaPublicKey() {
      _classCallCheck(this, EcdsaPublicKey);
      return _callSuper(this, EcdsaPublicKey, arguments);
    }
    _inherits(EcdsaPublicKey, _XmlObject3);
    return _createClass(EcdsaPublicKey);
  }(XmlObject);
  __decorate([XmlChildElement({
    localName: XmlSignature.ElementNames.X,
    namespaceURI: NAMESPACE_URI$1,
    prefix: PREFIX$1,
    required: true,
    converter: XmlBase64Converter
  })], exports.EcdsaPublicKey.prototype, "X", void 0);
  __decorate([XmlChildElement({
    localName: XmlSignature.ElementNames.Y,
    namespaceURI: NAMESPACE_URI$1,
    prefix: PREFIX$1,
    required: true,
    converter: XmlBase64Converter
  })], exports.EcdsaPublicKey.prototype, "Y", void 0);
  exports.EcdsaPublicKey = __decorate([XmlElement({
    localName: XmlSignature.ElementNames.PublicKey,
    namespaceURI: NAMESPACE_URI$1,
    prefix: PREFIX$1
  })], exports.EcdsaPublicKey);
  exports.NamedCurve = function (_XmlObject4) {
    function NamedCurve() {
      _classCallCheck(this, NamedCurve);
      return _callSuper(this, NamedCurve, arguments);
    }
    _inherits(NamedCurve, _XmlObject4);
    return _createClass(NamedCurve);
  }(XmlObject);
  __decorate([XmlAttribute({
    localName: XmlSignature.AttributeNames.URI,
    required: true
  })], exports.NamedCurve.prototype, "Uri", void 0);
  exports.NamedCurve = __decorate([XmlElement({
    localName: XmlSignature.ElementNames.NamedCurve,
    namespaceURI: NAMESPACE_URI$1,
    prefix: PREFIX$1
  })], exports.NamedCurve);
  exports.DomainParameters = function (_XmlObject5) {
    function DomainParameters() {
      _classCallCheck(this, DomainParameters);
      return _callSuper(this, DomainParameters, arguments);
    }
    _inherits(DomainParameters, _XmlObject5);
    return _createClass(DomainParameters);
  }(XmlObject);
  __decorate([XmlChildElement({
    parser: exports.NamedCurve
  })], exports.DomainParameters.prototype, "NamedCurve", void 0);
  exports.DomainParameters = __decorate([XmlElement({
    localName: XmlSignature.ElementNames.DomainParameters,
    namespaceURI: NAMESPACE_URI$1,
    prefix: PREFIX$1
  })], exports.DomainParameters);
  exports.EcdsaKeyValue = function (_KeyInfoClause) {
    function EcdsaKeyValue() {
      var _this218;
      _classCallCheck(this, EcdsaKeyValue);
      _this218 = _callSuper(this, EcdsaKeyValue, arguments);
      _this218.name = XmlSignature.ElementNames.ECDSAKeyValue;
      _this218.key = null;
      _this218.jwk = null;
      _this218.keyUsage = null;
      return _this218;
    }
    _inherits(EcdsaKeyValue, _KeyInfoClause);
    return _createClass(EcdsaKeyValue, [{
      key: "NamedCurve",
      get: function get() {
        return GetNamedCurveOid(this.DomainParameters.NamedCurve.Uri);
      }
    }, {
      key: "importKey",
      value: function () {
        var _importKey3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee80(key) {
          var jwk;
          return _regeneratorRuntime().wrap(function _callee80$(_context80) {
            while (1) switch (_context80.prev = _context80.next) {
              case 0:
                if (!(key.algorithm.name.toUpperCase() !== "ECDSA")) {
                  _context80.next = 2;
                  break;
                }
                throw new XmlError(XE.ALGORITHM_WRONG_NAME, key.algorithm.name);
              case 2:
                _context80.next = 4;
                return Application.crypto.subtle.exportKey("jwk", key);
              case 4:
                jwk = _context80.sent;
                this.key = key;
                this.jwk = jwk;
                this.PublicKey = new exports.EcdsaPublicKey();
                this.PublicKey.X = Convert$1.FromString(jwk.x, "base64url");
                this.PublicKey.Y = Convert$1.FromString(jwk.y, "base64url");
                if (!this.DomainParameters) {
                  this.DomainParameters = new exports.DomainParameters();
                }
                if (!this.DomainParameters.NamedCurve) {
                  this.DomainParameters.NamedCurve = new exports.NamedCurve();
                }
                this.DomainParameters.NamedCurve.Uri = GetNamedCurveOid(jwk.crv);
                this.keyUsage = key.usages;
                return _context80.abrupt("return", this);
              case 15:
              case "end":
                return _context80.stop();
            }
          }, _callee80, this);
        }));
        function importKey(_x114) {
          return _importKey3.apply(this, arguments);
        }
        return importKey;
      }()
    }, {
      key: "exportKey",
      value: function () {
        var _exportKey2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee81(alg) {
          var x, y, crv, jwk, key;
          return _regeneratorRuntime().wrap(function _callee81$(_context81) {
            while (1) switch (_context81.prev = _context81.next) {
              case 0:
                if (!this.key) {
                  _context81.next = 2;
                  break;
                }
                return _context81.abrupt("return", this.key);
              case 2:
                x = Convert$1.ToBase64Url(this.PublicKey.X);
                y = Convert$1.ToBase64Url(this.PublicKey.Y);
                crv = GetNamedCurveFromOid(this.DomainParameters.NamedCurve.Uri);
                jwk = {
                  kty: "EC",
                  crv: crv,
                  x: x,
                  y: y,
                  ext: true
                };
                this.keyUsage = ["verify"];
                _context81.next = 9;
                return Application.crypto.subtle.importKey("jwk", jwk, {
                  name: "ECDSA",
                  namedCurve: crv
                }, true, this.keyUsage);
              case 9:
                key = _context81.sent;
                this.key = key;
                return _context81.abrupt("return", this.key);
              case 12:
              case "end":
                return _context81.stop();
            }
          }, _callee81, this);
        }));
        function exportKey(_x115) {
          return _exportKey2.apply(this, arguments);
        }
        return exportKey;
      }()
    }]);
  }(KeyInfoClause);
  __decorate([XmlChildElement({
    parser: exports.DomainParameters
  })], exports.EcdsaKeyValue.prototype, "DomainParameters", void 0);
  __decorate([XmlChildElement({
    parser: exports.EcdsaPublicKey,
    required: true
  })], exports.EcdsaKeyValue.prototype, "PublicKey", void 0);
  exports.EcdsaKeyValue = __decorate([XmlElement({
    localName: XmlSignature.ElementNames.ECDSAKeyValue,
    namespaceURI: NAMESPACE_URI$1,
    prefix: PREFIX$1
  })], exports.EcdsaKeyValue);
  function GetNamedCurveOid(namedCurve) {
    switch (namedCurve) {
      case "P-256":
        return "urn:oid:1.2.840.10045.3.1.7";
      case "P-384":
        return "urn:oid:1.3.132.0.34";
      case "P-521":
        return "urn:oid:1.3.132.0.35";
    }
    throw new XmlError(XE.CRYPTOGRAPHIC, "Unknown NamedCurve");
  }
  function GetNamedCurveFromOid(oid) {
    switch (oid) {
      case "urn:oid:1.2.840.10045.3.1.7":
        return "P-256";
      case "urn:oid:1.3.132.0.34":
        return "P-384";
      case "urn:oid:1.3.132.0.35":
        return "P-521";
    }
    throw new XmlError(XE.CRYPTOGRAPHIC, "Unknown NamedCurve OID");
  }
  var PssAlgorithmParams_1;
  var DEFAULT_ALGORITHM = {
    name: "RSASSA-PKCS1-v1_5",
    hash: {
      name: "SHA-256"
    }
  };
  exports.RsaKeyValue = function (_KeyInfoClause2) {
    function RsaKeyValue() {
      var _this219;
      _classCallCheck(this, RsaKeyValue);
      _this219 = _callSuper(this, RsaKeyValue, arguments);
      _this219.key = null;
      _this219.jwk = null;
      _this219.keyUsage = [];
      return _this219;
    }
    _inherits(RsaKeyValue, _KeyInfoClause2);
    return _createClass(RsaKeyValue, [{
      key: "importKey",
      value: function () {
        var _importKey4 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee82(key) {
          var algName, jwk;
          return _regeneratorRuntime().wrap(function _callee82$(_context82) {
            while (1) switch (_context82.prev = _context82.next) {
              case 0:
                algName = key.algorithm.name.toUpperCase();
                if (!(algName !== RSA_PKCS1.toUpperCase() && algName !== RSA_PSS.toUpperCase())) {
                  _context82.next = 3;
                  break;
                }
                throw new XmlError(XE.ALGORITHM_WRONG_NAME, key.algorithm.name);
              case 3:
                this.key = key;
                _context82.next = 6;
                return Application.crypto.subtle.exportKey("jwk", key);
              case 6:
                jwk = _context82.sent;
                this.jwk = jwk;
                this.Modulus = Convert$1.FromBase64Url(jwk.n);
                this.Exponent = Convert$1.FromBase64Url(jwk.e);
                this.keyUsage = key.usages;
                return _context82.abrupt("return", this);
              case 12:
              case "end":
                return _context82.stop();
            }
          }, _callee82, this);
        }));
        function importKey(_x116) {
          return _importKey4.apply(this, arguments);
        }
        return importKey;
      }()
    }, {
      key: "exportKey",
      value: function () {
        var _exportKey3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee83() {
          var alg,
            modulus,
            exponent,
            algJwk,
            jwk,
            _args83 = arguments;
          return _regeneratorRuntime().wrap(function _callee83$(_context83) {
            while (1) switch (_context83.prev = _context83.next) {
              case 0:
                alg = _args83.length > 0 && _args83[0] !== undefined ? _args83[0] : DEFAULT_ALGORITHM;
                if (!this.key) {
                  _context83.next = 3;
                  break;
                }
                return _context83.abrupt("return", this.key);
              case 3:
                if (this.Modulus) {
                  _context83.next = 5;
                  break;
                }
                throw new XmlError(XE.CRYPTOGRAPHIC, "RsaKeyValue has no Modulus");
              case 5:
                modulus = Convert$1.ToBase64Url(this.Modulus);
                if (this.Exponent) {
                  _context83.next = 8;
                  break;
                }
                throw new XmlError(XE.CRYPTOGRAPHIC, "RsaKeyValue has no Exponent");
              case 8:
                exponent = Convert$1.ToBase64Url(this.Exponent);
                _context83.t0 = alg.name.toUpperCase();
                _context83.next = _context83.t0 === RSA_PKCS1.toUpperCase() ? 12 : _context83.t0 === RSA_PSS.toUpperCase() ? 14 : 16;
                break;
              case 12:
                algJwk = "R";
                return _context83.abrupt("break", 17);
              case 14:
                algJwk = "P";
                return _context83.abrupt("break", 17);
              case 16:
                throw new XmlError(XE.ALGORITHM_NOT_SUPPORTED, alg.name);
              case 17:
                _context83.t1 = alg.hash.name.toUpperCase();
                _context83.next = _context83.t1 === SHA1 ? 20 : _context83.t1 === SHA256 ? 22 : _context83.t1 === SHA384 ? 24 : _context83.t1 === SHA512 ? 26 : 28;
                break;
              case 20:
                algJwk += "S1";
                return _context83.abrupt("break", 28);
              case 22:
                algJwk += "S256";
                return _context83.abrupt("break", 28);
              case 24:
                algJwk += "S384";
                return _context83.abrupt("break", 28);
              case 26:
                algJwk += "S512";
                return _context83.abrupt("break", 28);
              case 28:
                jwk = {
                  kty: "RSA",
                  alg: algJwk,
                  n: modulus,
                  e: exponent,
                  ext: true
                };
                return _context83.abrupt("return", Application.crypto.subtle.importKey("jwk", jwk, alg, true, this.keyUsage));
              case 30:
              case "end":
                return _context83.stop();
            }
          }, _callee83, this);
        }));
        function exportKey() {
          return _exportKey3.apply(this, arguments);
        }
        return exportKey;
      }()
    }, {
      key: "LoadXml",
      value: function LoadXml(node) {
        _superPropGet(RsaKeyValue, "LoadXml", this, 3)([node]);
        this.keyUsage = ["verify"];
      }
    }]);
  }(KeyInfoClause);
  __decorate([XmlChildElement({
    localName: XmlSignature.ElementNames.Modulus,
    prefix: XmlSignature.DefaultPrefix,
    namespaceURI: XmlSignature.NamespaceURI,
    required: true,
    converter: XmlBase64Converter
  })], exports.RsaKeyValue.prototype, "Modulus", void 0);
  __decorate([XmlChildElement({
    localName: XmlSignature.ElementNames.Exponent,
    prefix: XmlSignature.DefaultPrefix,
    namespaceURI: XmlSignature.NamespaceURI,
    required: true,
    converter: XmlBase64Converter
  })], exports.RsaKeyValue.prototype, "Exponent", void 0);
  exports.RsaKeyValue = __decorate([XmlElement({
    localName: XmlSignature.ElementNames.RSAKeyValue
  })], exports.RsaKeyValue);
  var NAMESPACE_URI = "http://www.w3.org/2007/05/xmldsig-more#";
  var PREFIX = "pss";
  exports.MaskGenerationFunction = function (_XmlObject6) {
    function MaskGenerationFunction() {
      _classCallCheck(this, MaskGenerationFunction);
      return _callSuper(this, MaskGenerationFunction, arguments);
    }
    _inherits(MaskGenerationFunction, _XmlObject6);
    return _createClass(MaskGenerationFunction);
  }(XmlObject);
  __decorate([XmlChildElement({
    parser: exports.DigestMethod
  })], exports.MaskGenerationFunction.prototype, "DigestMethod", void 0);
  __decorate([XmlAttribute({
    localName: XmlSignature.AttributeNames.Algorithm,
    defaultValue: "http://www.w3.org/2007/05/xmldsig-more#MGF1"
  })], exports.MaskGenerationFunction.prototype, "Algorithm", void 0);
  exports.MaskGenerationFunction = __decorate([XmlElement({
    localName: XmlSignature.ElementNames.MaskGenerationFunction,
    prefix: PREFIX,
    namespaceURI: NAMESPACE_URI
  })], exports.MaskGenerationFunction);
  exports.PssAlgorithmParams = PssAlgorithmParams_1 = function (_XmlObject7) {
    function PssAlgorithmParams(algorithm) {
      var _this220;
      _classCallCheck(this, PssAlgorithmParams);
      _this220 = _callSuper(this, PssAlgorithmParams);
      if (algorithm) {
        _this220.FromAlgorithm(algorithm);
      }
      return _this220;
    }
    _inherits(PssAlgorithmParams, _XmlObject7);
    return _createClass(PssAlgorithmParams, [{
      key: "FromAlgorithm",
      value: function FromAlgorithm(algorithm) {
        this.DigestMethod = new exports.DigestMethod();
        var digest = CryptoConfig.GetHashAlgorithm(algorithm.hash);
        this.DigestMethod.Algorithm = digest.namespaceURI;
        if (algorithm.saltLength) {
          this.SaltLength = algorithm.saltLength;
        }
      }
    }], [{
      key: "FromAlgorithm",
      value: function FromAlgorithm(algorithm) {
        return new PssAlgorithmParams_1(algorithm);
      }
    }]);
  }(XmlObject);
  __decorate([XmlChildElement({
    parser: exports.DigestMethod
  })], exports.PssAlgorithmParams.prototype, "DigestMethod", void 0);
  __decorate([XmlChildElement({
    parser: exports.MaskGenerationFunction
  })], exports.PssAlgorithmParams.prototype, "MGF", void 0);
  __decorate([XmlChildElement({
    converter: XmlNumberConverter,
    prefix: PREFIX,
    namespaceURI: NAMESPACE_URI
  })], exports.PssAlgorithmParams.prototype, "SaltLength", void 0);
  __decorate([XmlChildElement({
    converter: XmlNumberConverter
  })], exports.PssAlgorithmParams.prototype, "TrailerField", void 0);
  exports.PssAlgorithmParams = PssAlgorithmParams_1 = __decorate([XmlElement({
    localName: XmlSignature.ElementNames.RSAPSSParams,
    prefix: PREFIX,
    namespaceURI: NAMESPACE_URI
  })], exports.PssAlgorithmParams);
  exports.KeyValue = function (_KeyInfoClause3) {
    function KeyValue(value) {
      var _this221;
      _classCallCheck(this, KeyValue);
      _this221 = _callSuper(this, KeyValue);
      if (value) {
        _this221.Value = value;
      }
      return _this221;
    }
    _inherits(KeyValue, _KeyInfoClause3);
    return _createClass(KeyValue, [{
      key: "Value",
      get: function get() {
        return this.value;
      },
      set: function set(v) {
        this.element = null;
        this.value = v;
      }
    }, {
      key: "importKey",
      value: function () {
        var _importKey5 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee84(key) {
          return _regeneratorRuntime().wrap(function _callee84$(_context84) {
            while (1) switch (_context84.prev = _context84.next) {
              case 0:
                _context84.t0 = key.algorithm.name.toUpperCase();
                _context84.next = _context84.t0 === RSA_PSS.toUpperCase() ? 3 : _context84.t0 === RSA_PKCS1.toUpperCase() ? 3 : _context84.t0 === ECDSA.toUpperCase() ? 7 : 11;
                break;
              case 3:
                this.Value = new exports.RsaKeyValue();
                _context84.next = 6;
                return this.Value.importKey(key);
              case 6:
                return _context84.abrupt("break", 12);
              case 7:
                this.Value = new exports.EcdsaKeyValue();
                _context84.next = 10;
                return this.Value.importKey(key);
              case 10:
                return _context84.abrupt("break", 12);
              case 11:
                throw new XmlError(XE.ALGORITHM_NOT_SUPPORTED, key.algorithm.name);
              case 12:
                return _context84.abrupt("return", this);
              case 13:
              case "end":
                return _context84.stop();
            }
          }, _callee84, this);
        }));
        function importKey(_x117) {
          return _importKey5.apply(this, arguments);
        }
        return importKey;
      }()
    }, {
      key: "exportKey",
      value: function () {
        var _exportKey4 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee85(alg) {
          return _regeneratorRuntime().wrap(function _callee85$(_context85) {
            while (1) switch (_context85.prev = _context85.next) {
              case 0:
                if (this.Value) {
                  _context85.next = 2;
                  break;
                }
                throw new XmlError(XE.NULL_REFERENCE);
              case 2:
                return _context85.abrupt("return", this.Value.exportKey(alg));
              case 3:
              case "end":
                return _context85.stop();
            }
          }, _callee85, this);
        }));
        function exportKey(_x118) {
          return _exportKey4.apply(this, arguments);
        }
        return exportKey;
      }()
    }, {
      key: "OnGetXml",
      value: function OnGetXml(element) {
        if (!this.Value) {
          throw new XmlError(XE.CRYPTOGRAPHIC, "KeyValue has empty value");
        }
        var node = this.Value.GetXml();
        if (node) {
          element.appendChild(node);
        }
      }
    }, {
      key: "OnLoadXml",
      value: function OnLoadXml(element) {
        var keyValueTypes = [exports.RsaKeyValue, exports.EcdsaKeyValue];
        for (var _i45 = 0, _keyValueTypes = keyValueTypes; _i45 < _keyValueTypes.length; _i45++) {
          var keyValueType = _keyValueTypes[_i45];
          try {
            var keyValue = new keyValueType();
            for (var i = 0; i < element.childNodes.length; i++) {
              var nodeKey = element.childNodes.item(i);
              if (!isElement(nodeKey)) {
                continue;
              }
              keyValue.LoadXml(nodeKey);
              this.value = keyValue;
              return;
            }
          } catch (e) {}
        }
        throw new XmlError(XE.CRYPTOGRAPHIC, "Unsupported KeyValue in use");
      }
    }]);
  }(KeyInfoClause);
  exports.KeyValue = __decorate([XmlElement({
    localName: XmlSignature.ElementNames.KeyValue
  })], exports.KeyValue);
  var OID = {
    "2.5.4.3": {
      short: "CN",
      long: "CommonName"
    },
    "2.5.4.6": {
      short: "C",
      long: "Country"
    },
    "2.5.4.5": {
      long: "DeviceSerialNumber"
    },
    "0.9.2342.19200300.100.1.25": {
      short: "DC",
      long: "DomainComponent"
    },
    "1.2.840.113549.1.9.1": {
      short: "E",
      long: "EMail"
    },
    "2.5.4.42": {
      short: "G",
      long: "GivenName"
    },
    "2.5.4.43": {
      short: "I",
      long: "Initials"
    },
    "2.5.4.7": {
      short: "L",
      long: "Locality"
    },
    "2.5.4.10": {
      short: "O",
      long: "Organization"
    },
    "2.5.4.11": {
      short: "OU",
      long: "OrganizationUnit"
    },
    "2.5.4.8": {
      short: "ST",
      long: "State"
    },
    "2.5.4.9": {
      short: "Street",
      long: "StreetAddress"
    },
    "2.5.4.4": {
      short: "SN",
      long: "SurName"
    },
    "2.5.4.12": {
      short: "T",
      long: "Title"
    },
    "1.2.840.113549.1.9.8": {
      long: "UnstructuredAddress"
    },
    "1.2.840.113549.1.9.2": {
      long: "UnstructuredName"
    }
  };
  var X509Certificate = function () {
    function X509Certificate(rawData) {
      _classCallCheck(this, X509Certificate);
      this.publicKey = null;
      if (rawData) {
        var buf = new Uint8Array(rawData);
        this.LoadRaw(buf);
        this.raw = buf;
      }
    }
    return _createClass(X509Certificate, [{
      key: "SerialNumber",
      get: function get() {
        return this.simpl.serialNumber.valueBlock.toString();
      }
    }, {
      key: "Issuer",
      get: function get() {
        return this.NameToString(this.simpl.issuer);
      }
    }, {
      key: "Subject",
      get: function get() {
        return this.NameToString(this.simpl.subject);
      }
    }, {
      key: "Thumbprint",
      value: function () {
        var _Thumbprint = _asyncToGenerator(_regeneratorRuntime().mark(function _callee86() {
          var algName,
            _args86 = arguments;
          return _regeneratorRuntime().wrap(function _callee86$(_context86) {
            while (1) switch (_context86.prev = _context86.next) {
              case 0:
                algName = _args86.length > 0 && _args86[0] !== undefined ? _args86[0] : "SHA-1";
                return _context86.abrupt("return", Application.crypto.subtle.digest(algName, this.raw));
              case 2:
              case "end":
                return _context86.stop();
            }
          }, _callee86, this);
        }));
        function Thumbprint() {
          return _Thumbprint.apply(this, arguments);
        }
        return Thumbprint;
      }()
    }, {
      key: "PublicKey",
      get: function get() {
        return this.publicKey;
      }
    }, {
      key: "GetRaw",
      value: function GetRaw() {
        return this.raw;
      }
    }, {
      key: "exportKey",
      value: function () {
        var _exportKey5 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee87(algorithm) {
          var alg, json, key;
          return _regeneratorRuntime().wrap(function _callee87$(_context87) {
            while (1) switch (_context87.prev = _context87.next) {
              case 0:
                if (!algorithm) {
                  _context87.next = 15;
                  break;
                }
                alg = {
                  algorithm: algorithm,
                  usages: ["verify"]
                };
                if (!(alg.algorithm.name.toUpperCase() === ECDSA)) {
                  _context87.next = 9;
                  break;
                }
                json = this.simpl.subjectPublicKeyInfo.toJSON();
                if (!("crv" in json && json.crv)) {
                  _context87.next = 8;
                  break;
                }
                alg.algorithm.namedCurve = json.crv;
                _context87.next = 9;
                break;
              case 8:
                throw new Error("Cannot get Curved name from the ECDSA public key");
              case 9:
                if (this.isHashedAlgorithm(alg.algorithm)) {
                  if (typeof alg.algorithm.hash === "string") {
                    alg.algorithm.hash = {
                      name: alg.algorithm.hash
                    };
                  }
                }
                _context87.next = 12;
                return this.simpl.getPublicKey({
                  algorithm: alg
                });
              case 12:
                key = _context87.sent;
                this.publicKey = key;
                return _context87.abrupt("return", key);
              case 15:
                if (!(this.simpl.subjectPublicKeyInfo.algorithm.algorithmId === "1.2.840.113549.1.1.1")) {
                  _context87.next = 21;
                  break;
                }
                _context87.next = 18;
                return this.simpl.getPublicKey({
                  algorithm: {
                    algorithm: {
                      name: "RSASSA-PKCS1-v1_5",
                      hash: {
                        name: "SHA-256"
                      }
                    },
                    usages: ["verify"]
                  }
                });
              case 18:
                this.publicKey = _context87.sent;
                _context87.next = 24;
                break;
              case 21:
                _context87.next = 23;
                return this.simpl.getPublicKey();
              case 23:
                this.publicKey = _context87.sent;
              case 24:
                return _context87.abrupt("return", this.publicKey);
              case 25:
              case "end":
                return _context87.stop();
            }
          }, _callee87, this);
        }));
        function exportKey(_x119) {
          return _exportKey5.apply(this, arguments);
        }
        return exportKey;
      }()
    }, {
      key: "NameToString",
      value: function NameToString(name) {
        var splitter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ",";
        var res = [];
        name.typesAndValues.forEach(function (typeAndValue) {
          var type = typeAndValue.type;
          var oid = OID[type.toString()];
          var name2 = oid ? oid.short : null;
          res.push("".concat(name2 ? name2 : type, "=").concat(typeAndValue.value.valueBlock.value));
        });
        return res.join(splitter + " ");
      }
    }, {
      key: "LoadRaw",
      value: function LoadRaw(rawData) {
        this.raw = new Uint8Array(rawData);
        var asn1 = _fromBER(this.raw.buffer);
        this.simpl = new Certificate({
          schema: asn1.result
        });
      }
    }, {
      key: "isHashedAlgorithm",
      value: function isHashedAlgorithm(alg) {
        return !!alg["hash"];
      }
    }]);
  }();
  exports.X509IssuerSerial = function (_XmlSignatureObject10) {
    function X509IssuerSerial() {
      _classCallCheck(this, X509IssuerSerial);
      return _callSuper(this, X509IssuerSerial, arguments);
    }
    _inherits(X509IssuerSerial, _XmlSignatureObject10);
    return _createClass(X509IssuerSerial);
  }(exports.XmlSignatureObject);
  __decorate([XmlChildElement({
    localName: XmlSignature.ElementNames.X509IssuerName,
    namespaceURI: XmlSignature.NamespaceURI,
    prefix: XmlSignature.DefaultPrefix,
    required: true
  })], exports.X509IssuerSerial.prototype, "X509IssuerName", void 0);
  __decorate([XmlChildElement({
    localName: XmlSignature.ElementNames.X509SerialNumber,
    namespaceURI: XmlSignature.NamespaceURI,
    prefix: XmlSignature.DefaultPrefix,
    required: true
  })], exports.X509IssuerSerial.prototype, "X509SerialNumber", void 0);
  exports.X509IssuerSerial = __decorate([XmlElement({
    localName: XmlSignature.ElementNames.X509IssuerSerial
  })], exports.X509IssuerSerial);
  exports.X509IncludeOption = void 0;
  (function (X509IncludeOption) {
    X509IncludeOption[X509IncludeOption["None"] = 0] = "None";
    X509IncludeOption[X509IncludeOption["EndCertOnly"] = 1] = "EndCertOnly";
    X509IncludeOption[X509IncludeOption["ExcludeRoot"] = 2] = "ExcludeRoot";
    X509IncludeOption[X509IncludeOption["WholeChain"] = 3] = "WholeChain";
  })(exports.X509IncludeOption || (exports.X509IncludeOption = {}));
  exports.KeyInfoX509Data = function (_KeyInfoClause4) {
    function KeyInfoX509Data(cert) {
      var _this222;
      var includeOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : exports.X509IncludeOption.None;
      _classCallCheck(this, KeyInfoX509Data);
      _this222 = _callSuper(this, KeyInfoX509Data);
      _this222.x509crl = null;
      _this222.SubjectKeyIdList = [];
      if (cert) {
        if (cert instanceof Uint8Array) {
          _this222.AddCertificate(new X509Certificate(cert));
        } else if (cert instanceof X509Certificate) {
          switch (includeOptions) {
            case exports.X509IncludeOption.None:
            case exports.X509IncludeOption.EndCertOnly:
              _this222.AddCertificate(cert);
              break;
            case exports.X509IncludeOption.ExcludeRoot:
              _this222.AddCertificatesChainFrom(cert, false);
              break;
            case exports.X509IncludeOption.WholeChain:
              _this222.AddCertificatesChainFrom(cert, true);
              break;
          }
        }
      }
      return _this222;
    }
    _inherits(KeyInfoX509Data, _KeyInfoClause4);
    return _createClass(KeyInfoX509Data, [{
      key: "importKey",
      value: function () {
        var _importKey6 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee88(key) {
          return _regeneratorRuntime().wrap(function _callee88$(_context88) {
            while (1) switch (_context88.prev = _context88.next) {
              case 0:
                throw new XmlError(XE.METHOD_NOT_SUPPORTED);
              case 1:
              case "end":
                return _context88.stop();
            }
          }, _callee88);
        }));
        function importKey(_x120) {
          return _importKey6.apply(this, arguments);
        }
        return importKey;
      }()
    }, {
      key: "exportKey",
      value: function () {
        var _exportKey6 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee89(alg) {
          return _regeneratorRuntime().wrap(function _callee89$(_context89) {
            while (1) switch (_context89.prev = _context89.next) {
              case 0:
                if (this.Certificates.length) {
                  _context89.next = 2;
                  break;
                }
                throw new XmlError(XE.NULL_REFERENCE);
              case 2:
                _context89.next = 4;
                return this.Certificates[0].exportKey(alg);
              case 4:
                this.Key = _context89.sent;
                return _context89.abrupt("return", this.Key);
              case 6:
              case "end":
                return _context89.stop();
            }
          }, _callee89, this);
        }));
        function exportKey(_x121) {
          return _exportKey6.apply(this, arguments);
        }
        return exportKey;
      }()
    }, {
      key: "Certificates",
      get: function get() {
        return this.X509CertificateList;
      }
    }, {
      key: "CRL",
      get: function get() {
        return this.x509crl;
      },
      set: function set(value) {
        this.x509crl = value;
      }
    }, {
      key: "IssuerSerials",
      get: function get() {
        return this.IssuerSerialList;
      }
    }, {
      key: "SubjectKeyIds",
      get: function get() {
        return this.SubjectKeyIdList;
      }
    }, {
      key: "SubjectNames",
      get: function get() {
        return this.SubjectNameList;
      }
    }, {
      key: "AddCertificate",
      value: function AddCertificate(certificate) {
        if (!certificate) {
          throw new XmlError(XE.PARAM_REQUIRED, "certificate");
        }
        if (!this.X509CertificateList) {
          this.X509CertificateList = [];
        }
        this.X509CertificateList.push(certificate);
      }
    }, {
      key: "AddIssuerSerial",
      value: function AddIssuerSerial(issuerName, serialNumber) {
        if (issuerName == null) {
          throw new XmlError(XE.PARAM_REQUIRED, "issuerName");
        }
        if (this.IssuerSerialList == null) {
          this.IssuerSerialList = [];
        }
        var xis = {
          issuerName: issuerName,
          serialNumber: serialNumber
        };
        this.IssuerSerialList.push(xis);
      }
    }, {
      key: "AddSubjectKeyId",
      value: function AddSubjectKeyId(subjectKeyId) {
        if (this.SubjectKeyIdList) {
          this.SubjectKeyIdList = [];
        }
        if (typeof subjectKeyId === "string") {
          if (subjectKeyId != null) {
            var id;
            id = Convert$1.FromBase64(subjectKeyId);
            this.SubjectKeyIdList.push(id);
          }
        } else {
          this.SubjectKeyIdList.push(subjectKeyId);
        }
      }
    }, {
      key: "AddSubjectName",
      value: function AddSubjectName(subjectName) {
        if (this.SubjectNameList == null) {
          this.SubjectNameList = [];
        }
        this.SubjectNameList.push(subjectName);
      }
    }, {
      key: "GetXml",
      value: function GetXml() {
        var doc = this.CreateDocument();
        var xel = this.CreateElement(doc);
        var prefix = this.GetPrefix();
        if (this.IssuerSerialList != null && this.IssuerSerialList.length > 0) {
          this.IssuerSerialList.forEach(function (iser) {
            var isl = doc.createElementNS(XmlSignature.NamespaceURI, prefix + XmlSignature.ElementNames.X509IssuerSerial);
            var xin = doc.createElementNS(XmlSignature.NamespaceURI, prefix + XmlSignature.ElementNames.X509IssuerName);
            xin.textContent = iser.issuerName;
            isl.appendChild(xin);
            var xsn = doc.createElementNS(XmlSignature.NamespaceURI, prefix + XmlSignature.ElementNames.X509SerialNumber);
            xsn.textContent = iser.serialNumber;
            isl.appendChild(xsn);
            xel.appendChild(isl);
          });
        }
        if (this.SubjectKeyIdList != null && this.SubjectKeyIdList.length > 0) {
          this.SubjectKeyIdList.forEach(function (skid) {
            var ski = doc.createElementNS(XmlSignature.NamespaceURI, prefix + XmlSignature.ElementNames.X509SKI);
            ski.textContent = Convert$1.ToBase64(skid);
            xel.appendChild(ski);
          });
        }
        if (this.SubjectNameList != null && this.SubjectNameList.length > 0) {
          this.SubjectNameList.forEach(function (subject) {
            var sn = doc.createElementNS(XmlSignature.NamespaceURI, prefix + XmlSignature.ElementNames.X509SubjectName);
            sn.textContent = subject;
            xel.appendChild(sn);
          });
        }
        if (this.X509CertificateList != null && this.X509CertificateList.length > 0) {
          this.X509CertificateList.forEach(function (x509) {
            var cert = doc.createElementNS(XmlSignature.NamespaceURI, prefix + XmlSignature.ElementNames.X509Certificate);
            cert.textContent = Convert$1.ToBase64(x509.GetRaw());
            xel.appendChild(cert);
          });
        }
        if (this.x509crl != null) {
          var crl = doc.createElementNS(XmlSignature.NamespaceURI, prefix + XmlSignature.ElementNames.X509CRL);
          crl.textContent = Convert$1.ToBase64(this.x509crl);
          xel.appendChild(crl);
        }
        return xel;
      }
    }, {
      key: "LoadXml",
      value: function LoadXml(element) {
        var _this223 = this;
        _superPropGet(KeyInfoX509Data, "LoadXml", this, 3)([element]);
        if (this.IssuerSerialList) {
          this.IssuerSerialList = [];
        }
        if (this.SubjectKeyIdList) {
          this.SubjectKeyIdList = [];
        }
        if (this.SubjectNameList) {
          this.SubjectNameList = [];
        }
        if (this.X509CertificateList) {
          this.X509CertificateList = [];
        }
        this.x509crl = null;
        var xnl = this.GetChildren(XmlSignature.ElementNames.X509IssuerSerial);
        if (xnl) {
          xnl.forEach(function (xel) {
            var issuer = exports.XmlSignatureObject.GetChild(xel, XmlSignature.ElementNames.X509IssuerName, XmlSignature.NamespaceURI, true);
            var serial = exports.XmlSignatureObject.GetChild(xel, XmlSignature.ElementNames.X509SerialNumber, XmlSignature.NamespaceURI, true);
            if (issuer && issuer.textContent && serial && serial.textContent) {
              _this223.AddIssuerSerial(issuer.textContent, serial.textContent);
            }
          });
        }
        xnl = this.GetChildren(XmlSignature.ElementNames.X509SKI);
        if (xnl) {
          xnl.forEach(function (xel) {
            if (xel.textContent) {
              var skid = Convert$1.FromBase64(xel.textContent);
              _this223.AddSubjectKeyId(skid);
            }
          });
        }
        xnl = this.GetChildren(XmlSignature.ElementNames.X509SubjectName);
        if (xnl != null) {
          xnl.forEach(function (xel) {
            if (xel.textContent) {
              _this223.AddSubjectName(xel.textContent);
            }
          });
        }
        xnl = this.GetChildren(XmlSignature.ElementNames.X509Certificate);
        if (xnl) {
          xnl.forEach(function (xel) {
            if (xel.textContent) {
              var cert = Convert$1.FromBase64(xel.textContent);
              _this223.AddCertificate(new X509Certificate(cert));
            }
          });
        }
        var x509el = this.GetChild(XmlSignature.ElementNames.X509CRL, false);
        if (x509el && x509el.textContent) {
          this.x509crl = Convert$1.FromBase64(x509el.textContent);
        }
      }
    }, {
      key: "AddCertificatesChainFrom",
      value: function AddCertificatesChainFrom(cert, root) {
        throw new XmlError(XE.METHOD_NOT_IMPLEMENTED);
      }
    }]);
  }(KeyInfoClause);
  exports.KeyInfoX509Data = __decorate([XmlElement({
    localName: XmlSignature.ElementNames.X509Data
  })], exports.KeyInfoX509Data);
  exports.SPKIData = function (_KeyInfoClause5) {
    function SPKIData() {
      _classCallCheck(this, SPKIData);
      return _callSuper(this, SPKIData, arguments);
    }
    _inherits(SPKIData, _KeyInfoClause5);
    return _createClass(SPKIData, [{
      key: "importKey",
      value: function () {
        var _importKey7 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee90(key) {
          var spki;
          return _regeneratorRuntime().wrap(function _callee90$(_context90) {
            while (1) switch (_context90.prev = _context90.next) {
              case 0:
                _context90.next = 2;
                return Application.crypto.subtle.exportKey("spki", key);
              case 2:
                spki = _context90.sent;
                this.SPKIexp = new Uint8Array(spki);
                this.Key = key;
                return _context90.abrupt("return", this);
              case 6:
              case "end":
                return _context90.stop();
            }
          }, _callee90, this);
        }));
        function importKey(_x122) {
          return _importKey7.apply(this, arguments);
        }
        return importKey;
      }()
    }, {
      key: "exportKey",
      value: function () {
        var _exportKey7 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee91(alg) {
          var key;
          return _regeneratorRuntime().wrap(function _callee91$(_context91) {
            while (1) switch (_context91.prev = _context91.next) {
              case 0:
                _context91.next = 2;
                return Application.crypto.subtle.importKey("spki", this.SPKIexp, alg, true, ["verify"]);
              case 2:
                key = _context91.sent;
                this.Key = key;
                return _context91.abrupt("return", key);
              case 5:
              case "end":
                return _context91.stop();
            }
          }, _callee91, this);
        }));
        function exportKey(_x123) {
          return _exportKey7.apply(this, arguments);
        }
        return exportKey;
      }()
    }]);
  }(KeyInfoClause);
  __decorate([XmlChildElement({
    localName: XmlSignature.ElementNames.SPKIexp,
    namespaceURI: XmlSignature.NamespaceURI,
    prefix: XmlSignature.DefaultPrefix,
    required: true,
    converter: XmlBase64Converter
  })], exports.SPKIData.prototype, "SPKIexp", void 0);
  exports.SPKIData = __decorate([XmlElement({
    localName: XmlSignature.ElementNames.SPKIData
  })], exports.SPKIData);
  var SignatureAlgorithms = {};
  SignatureAlgorithms[RSA_PKCS1_SHA1_NAMESPACE] = RsaPkcs1Sha1;
  SignatureAlgorithms[RSA_PKCS1_SHA256_NAMESPACE] = RsaPkcs1Sha256;
  SignatureAlgorithms[RSA_PKCS1_SHA384_NAMESPACE] = RsaPkcs1Sha384;
  SignatureAlgorithms[RSA_PKCS1_SHA512_NAMESPACE] = RsaPkcs1Sha512;
  SignatureAlgorithms[ECDSA_SHA1_NAMESPACE] = EcdsaSha1;
  SignatureAlgorithms[ECDSA_SHA256_NAMESPACE] = EcdsaSha256;
  SignatureAlgorithms[ECDSA_SHA384_NAMESPACE] = EcdsaSha384;
  SignatureAlgorithms[ECDSA_SHA512_NAMESPACE] = EcdsaSha512;
  SignatureAlgorithms[HMAC_SHA1_NAMESPACE] = HmacSha1;
  SignatureAlgorithms[HMAC_SHA256_NAMESPACE] = HmacSha256;
  SignatureAlgorithms[HMAC_SHA384_NAMESPACE] = HmacSha384;
  SignatureAlgorithms[HMAC_SHA512_NAMESPACE] = HmacSha512;
  SignatureAlgorithms[RSA_PSS_SHA1_NAMESPACE] = RsaPssWithoutParamsSha1;
  SignatureAlgorithms[RSA_PSS_SHA256_NAMESPACE] = RsaPssWithoutParamsSha256;
  SignatureAlgorithms[RSA_PSS_SHA384_NAMESPACE] = RsaPssWithoutParamsSha384;
  SignatureAlgorithms[RSA_PSS_SHA512_NAMESPACE] = RsaPssWithoutParamsSha512;
  var HashAlgorithms = {};
  HashAlgorithms[SHA1_NAMESPACE] = Sha1;
  HashAlgorithms[SHA256_NAMESPACE] = Sha256;
  HashAlgorithms[SHA384_NAMESPACE] = Sha384;
  HashAlgorithms[SHA512_NAMESPACE] = Sha512;
  var CryptoConfig = function () {
    function CryptoConfig() {
      _classCallCheck(this, CryptoConfig);
    }
    return _createClass(CryptoConfig, null, [{
      key: "CreateFromName",
      value: function CreateFromName(name) {
        var transform;
        switch (name) {
          case XmlSignature.AlgorithmNamespaces.XmlDsigBase64Transform:
            transform = new XmlDsigBase64Transform();
            break;
          case XmlSignature.AlgorithmNamespaces.XmlDsigC14NTransform:
            transform = new XmlDsigC14NTransform();
            break;
          case XmlSignature.AlgorithmNamespaces.XmlDsigC14NWithCommentsTransform:
            transform = new XmlDsigC14NWithCommentsTransform();
            break;
          case XmlSignature.AlgorithmNamespaces.XmlDsigEnvelopedSignatureTransform:
            transform = new XmlDsigEnvelopedSignatureTransform();
            break;
          case XmlSignature.AlgorithmNamespaces.XmlDsigXPathTransform:
            throw new XmlError(XE.ALGORITHM_NOT_SUPPORTED, name);
          case XmlSignature.AlgorithmNamespaces.XmlDsigXsltTransform:
            throw new XmlError(XE.ALGORITHM_NOT_SUPPORTED, name);
          case XmlSignature.AlgorithmNamespaces.XmlDsigExcC14NTransform:
            transform = new XmlDsigExcC14NTransform();
            break;
          case XmlSignature.AlgorithmNamespaces.XmlDsigExcC14NWithCommentsTransform:
            transform = new XmlDsigExcC14NWithCommentsTransform();
            break;
          case XmlSignature.AlgorithmNamespaces.XmlDecryptionTransform:
            throw new XmlError(XE.ALGORITHM_NOT_SUPPORTED, name);
          default:
            throw new XmlError(XE.ALGORITHM_NOT_SUPPORTED, name);
        }
        return transform;
      }
    }, {
      key: "CreateSignatureAlgorithm",
      value: function CreateSignatureAlgorithm(method) {
        var alg = SignatureAlgorithms[method.Algorithm] || null;
        if (alg) {
          return new alg();
        } else if (method.Algorithm === RSA_PSS_WITH_PARAMS_NAMESPACE) {
          var pssParams;
          method.Any.Some(function (item) {
            if (item instanceof exports.PssAlgorithmParams) {
              pssParams = item;
            }
            return !!pssParams;
          });
          if (pssParams) {
            switch (pssParams.DigestMethod.Algorithm) {
              case SHA1_NAMESPACE:
                return new RsaPssSha1(pssParams.SaltLength);
              case SHA256_NAMESPACE:
                return new RsaPssSha256(pssParams.SaltLength);
              case SHA384_NAMESPACE:
                return new RsaPssSha384(pssParams.SaltLength);
              case SHA512_NAMESPACE:
                return new RsaPssSha512(pssParams.SaltLength);
            }
          }
          throw new XmlError(XE.CRYPTOGRAPHIC, "Cannot get params for RSA-PSS algoriithm");
        }
        throw new Error("signature algorithm '".concat(method.Algorithm, "' is not supported"));
      }
    }, {
      key: "CreateHashAlgorithm",
      value: function CreateHashAlgorithm(namespace) {
        var alg = HashAlgorithms[namespace];
        if (alg) {
          return new alg();
        } else {
          throw new Error("hash algorithm '" + namespace + "' is not supported");
        }
      }
    }, {
      key: "GetHashAlgorithm",
      value: function GetHashAlgorithm(algorithm) {
        var alg = typeof algorithm === "string" ? {
          name: algorithm
        } : algorithm;
        switch (alg.name.toUpperCase()) {
          case SHA1:
            return new Sha1();
          case SHA256:
            return new Sha256();
          case SHA384:
            return new Sha384();
          case SHA512:
            return new Sha512();
          default:
            throw new XmlError(XE.ALGORITHM_NOT_SUPPORTED, alg.name);
        }
      }
    }, {
      key: "GetSignatureAlgorithm",
      value: function GetSignatureAlgorithm(algorithm) {
        if (typeof algorithm.hash === "string") {
          algorithm.hash = {
            name: algorithm.hash
          };
        }
        var hashName = algorithm.hash.name;
        if (!hashName) {
          throw new Error("Signing algorithm doesn't have name for hash");
        }
        var alg;
        switch (algorithm.name.toUpperCase()) {
          case RSA_PKCS1.toUpperCase():
            switch (hashName.toUpperCase()) {
              case SHA1:
                alg = new RsaPkcs1Sha1();
                break;
              case SHA256:
                alg = new RsaPkcs1Sha256();
                break;
              case SHA384:
                alg = new RsaPkcs1Sha384();
                break;
              case SHA512:
                alg = new RsaPkcs1Sha512();
                break;
              default:
                throw new XmlError(XE.ALGORITHM_NOT_SUPPORTED, "".concat(algorithm.name, ":").concat(hashName));
            }
            break;
          case RSA_PSS.toUpperCase():
            var saltLength = algorithm.saltLength;
            switch (hashName.toUpperCase()) {
              case SHA1:
                alg = saltLength ? new RsaPssSha1(saltLength) : new RsaPssWithoutParamsSha1();
                break;
              case SHA256:
                alg = saltLength ? new RsaPssSha256(saltLength) : new RsaPssWithoutParamsSha256();
                break;
              case SHA384:
                alg = saltLength ? new RsaPssSha384(saltLength) : new RsaPssWithoutParamsSha384();
                break;
              case SHA512:
                alg = saltLength ? new RsaPssSha512(saltLength) : new RsaPssWithoutParamsSha512();
                break;
              default:
                throw new XmlError(XE.ALGORITHM_NOT_SUPPORTED, "".concat(algorithm.name, ":").concat(hashName));
            }
            algorithm.saltLength = alg.algorithm.saltLength;
            break;
          case ECDSA:
            switch (hashName.toUpperCase()) {
              case SHA1:
                alg = new EcdsaSha1();
                break;
              case SHA256:
                alg = new EcdsaSha256();
                break;
              case SHA384:
                alg = new EcdsaSha384();
                break;
              case SHA512:
                alg = new EcdsaSha512();
                break;
              default:
                throw new XmlError(XE.ALGORITHM_NOT_SUPPORTED, "".concat(algorithm.name, ":").concat(hashName));
            }
            break;
          case HMAC:
            switch (hashName.toUpperCase()) {
              case SHA1:
                alg = new HmacSha1();
                break;
              case SHA256:
                alg = new HmacSha256();
                break;
              case SHA384:
                alg = new HmacSha384();
                break;
              case SHA512:
                alg = new HmacSha512();
                break;
              default:
                throw new XmlError(XE.ALGORITHM_NOT_SUPPORTED, "".concat(algorithm.name, ":").concat(hashName));
            }
            break;
          default:
            throw new XmlError(XE.ALGORITHM_NOT_SUPPORTED, algorithm.name);
        }
        return alg;
      }
    }]);
  }();
  var SignedXml = function () {
    function SignedXml(node) {
      _classCallCheck(this, SignedXml);
      this.signature = new exports.Signature();
      this.replaceCanonicalization = false;
      if (node && node.nodeType === XmlNodeType.Document) {
        this.document = node;
      } else if (node && node.nodeType === XmlNodeType.Element) {
        var xmlText = new XMLSerializer().serializeToString(node);
        this.document = new DOMParser().parseFromString(xmlText, APPLICATION_XML);
      }
    }
    return _createClass(SignedXml, [{
      key: "XmlSignature",
      get: function get() {
        return this.signature;
      }
    }, {
      key: "Signature",
      get: function get() {
        return this.XmlSignature.SignatureValue;
      }
    }, {
      key: "Sign",
      value: function () {
        var _Sign2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee92(algorithm, key, data) {
          var options,
            alg,
            signedInfo,
            signingAlg,
            alg2,
            params,
            outputLength,
            hmacAlg,
            si,
            signature,
            _args92 = arguments;
          return _regeneratorRuntime().wrap(function _callee92$(_context92) {
            while (1) switch (_context92.prev = _context92.next) {
              case 0:
                options = _args92.length > 3 && _args92[3] !== undefined ? _args92[3] : {};
                if (isDocument(data)) {
                  data = data.cloneNode(true).documentElement;
                } else if (isElement(data)) {
                  data = data.cloneNode(true);
                }
                signingAlg = assign({}, algorithm);
                if (key.algorithm["hash"]) {
                  signingAlg.hash = key.algorithm["hash"];
                }
                alg = CryptoConfig.GetSignatureAlgorithm(signingAlg);
                _context92.next = 7;
                return this.ApplySignOptions(this.XmlSignature, algorithm, key, options);
              case 7:
                signedInfo = this.XmlSignature.SignedInfo;
                _context92.next = 10;
                return this.DigestReferences(data);
              case 10:
                signedInfo.SignatureMethod.Algorithm = alg.namespaceURI;
                if (!(alg instanceof RsaPssBase)) {
                  _context92.next = 18;
                  break;
                }
                alg2 = assign({}, key.algorithm, signingAlg);
                if (typeof alg2.hash === "string") {
                  alg2.hash = {
                    name: alg2.hash
                  };
                }
                params = new exports.PssAlgorithmParams(alg2);
                this.XmlSignature.SignedInfo.SignatureMethod.Any.Add(params);
                _context92.next = 33;
                break;
              case 18:
                if (!(HMAC.toUpperCase() === algorithm.name.toUpperCase())) {
                  _context92.next = 33;
                  break;
                }
                outputLength = 0;
                hmacAlg = key.algorithm;
                _context92.t0 = hmacAlg.hash.name.toUpperCase();
                _context92.next = _context92.t0 === SHA1 ? 24 : _context92.t0 === SHA256 ? 26 : _context92.t0 === SHA384 ? 28 : _context92.t0 === SHA512 ? 30 : 32;
                break;
              case 24:
                outputLength = hmacAlg.length || 160;
                return _context92.abrupt("break", 32);
              case 26:
                outputLength = hmacAlg.length || 256;
                return _context92.abrupt("break", 32);
              case 28:
                outputLength = hmacAlg.length || 384;
                return _context92.abrupt("break", 32);
              case 30:
                outputLength = hmacAlg.length || 512;
                return _context92.abrupt("break", 32);
              case 32:
                this.XmlSignature.SignedInfo.SignatureMethod.HMACOutputLength = outputLength;
              case 33:
                si = this.TransformSignedInfo(data);
                _context92.next = 36;
                return alg.Sign(si, key, signingAlg);
              case 36:
                signature = _context92.sent;
                this.Key = key;
                this.Algorithm = algorithm;
                this.XmlSignature.SignatureValue = new Uint8Array(signature);
                if (isElement(data)) {
                  this.document = data.ownerDocument;
                }
                return _context92.abrupt("return", this.XmlSignature);
              case 42:
              case "end":
                return _context92.stop();
            }
          }, _callee92, this);
        }));
        function Sign(_x124, _x125, _x126) {
          return _Sign2.apply(this, arguments);
        }
        return Sign;
      }()
    }, {
      key: "reimportKey",
      value: function () {
        var _reimportKey = _asyncToGenerator(_regeneratorRuntime().mark(function _callee93(key, alg) {
          var spki;
          return _regeneratorRuntime().wrap(function _callee93$(_context93) {
            while (1) switch (_context93.prev = _context93.next) {
              case 0:
                _context93.next = 2;
                return Application.crypto.subtle.exportKey("spki", key);
              case 2:
                spki = _context93.sent;
                return _context93.abrupt("return", Application.crypto.subtle.importKey("spki", spki, alg, true, ["verify"]));
              case 4:
              case "end":
                return _context93.stop();
            }
          }, _callee93);
        }));
        function reimportKey(_x127, _x128) {
          return _reimportKey.apply(this, arguments);
        }
        return reimportKey;
      }()
    }, {
      key: "Verify",
      value: function () {
        var _Verify2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee94(params) {
          var content, key, xml, res, keys;
          return _regeneratorRuntime().wrap(function _callee94$(_context94) {
            while (1) switch (_context94.prev = _context94.next) {
              case 0:
                if (params) {
                  if ("algorithm" in params && "usages" in params && "type" in params) {
                    key = params;
                  } else {
                    key = params.key;
                    content = params.content;
                  }
                }
                if (!(key && key.type === "public" && this.Algorithm)) {
                  _context94.next = 5;
                  break;
                }
                _context94.next = 4;
                return this.reimportKey(key, this.Algorithm);
              case 4:
                key = _context94.sent;
              case 5:
                if (content) {
                  _context94.next = 10;
                  break;
                }
                xml = this.document;
                if (xml && xml.documentElement) {
                  _context94.next = 9;
                  break;
                }
                throw new XmlError(XE.NULL_PARAM, "SignedXml", "document");
              case 9:
                content = xml.documentElement;
              case 10:
                if (isDocument(content) || isElement(content)) {
                  content = content.cloneNode(true);
                }
                _context94.next = 13;
                return this.ValidateReferences(content);
              case 13:
                res = _context94.sent;
                if (!res) {
                  _context94.next = 26;
                  break;
                }
                if (!key) {
                  _context94.next = 19;
                  break;
                }
                _context94.t0 = [key];
                _context94.next = 22;
                break;
              case 19:
                _context94.next = 21;
                return this.GetPublicKeys();
              case 21:
                _context94.t0 = _context94.sent;
              case 22:
                keys = _context94.t0;
                return _context94.abrupt("return", this.ValidateSignatureValue(keys));
              case 26:
                return _context94.abrupt("return", false);
              case 27:
              case "end":
                return _context94.stop();
            }
          }, _callee94, this);
        }));
        function Verify(_x129) {
          return _Verify2.apply(this, arguments);
        }
        return Verify;
      }()
    }, {
      key: "GetXml",
      value: function GetXml() {
        return this.signature.GetXml();
      }
    }, {
      key: "LoadXml",
      value: function LoadXml(value) {
        this.signature = exports.Signature.LoadXml(value);
        this.Algorithm = CryptoConfig.CreateSignatureAlgorithm(this.XmlSignature.SignedInfo.SignatureMethod).algorithm;
      }
    }, {
      key: "toString",
      value: function toString() {
        var signature = this.XmlSignature;
        var enveloped = signature.SignedInfo.References && signature.SignedInfo.References.Some(function (r) {
          return r.Transforms && r.Transforms.Some(function (t) {
            return t instanceof XmlDsigEnvelopedSignatureTransform;
          });
        });
        if (enveloped) {
          var doc = this.document.documentElement.cloneNode(true);
          var node = this.XmlSignature.GetXml();
          if (!node) {
            throw new XmlError(XE.XML_EXCEPTION, "Cannot get Xml element from Signature");
          }
          var sig = node.cloneNode(true);
          doc.appendChild(sig);
          return new XMLSerializer().serializeToString(doc);
        }
        return this.XmlSignature.toString();
      }
    }, {
      key: "GetPublicKeys",
      value: function () {
        var _GetPublicKeys = _asyncToGenerator(_regeneratorRuntime().mark(function _callee95() {
          var keys, alg, _iterator44, _step44, kic, _iterator45, _step45, cert, _key12, _key13, i, key, spki, updatedKey;
          return _regeneratorRuntime().wrap(function _callee95$(_context95) {
            while (1) switch (_context95.prev = _context95.next) {
              case 0:
                keys = [];
                alg = CryptoConfig.CreateSignatureAlgorithm(this.XmlSignature.SignedInfo.SignatureMethod);
                _iterator44 = _createForOfIteratorHelper(this.XmlSignature.KeyInfo.GetIterator());
                _context95.prev = 3;
                _iterator44.s();
              case 5:
                if ((_step44 = _iterator44.n()).done) {
                  _context95.next = 35;
                  break;
                }
                kic = _step44.value;
                if (!(kic instanceof exports.KeyInfoX509Data)) {
                  _context95.next = 29;
                  break;
                }
                _iterator45 = _createForOfIteratorHelper(kic.Certificates);
                _context95.prev = 9;
                _iterator45.s();
              case 11:
                if ((_step45 = _iterator45.n()).done) {
                  _context95.next = 19;
                  break;
                }
                cert = _step45.value;
                _context95.next = 15;
                return cert.exportKey();
              case 15:
                _key12 = _context95.sent;
                keys.push(_key12);
              case 17:
                _context95.next = 11;
                break;
              case 19:
                _context95.next = 24;
                break;
              case 21:
                _context95.prev = 21;
                _context95.t0 = _context95["catch"](9);
                _iterator45.e(_context95.t0);
              case 24:
                _context95.prev = 24;
                _iterator45.f();
                return _context95.finish(24);
              case 27:
                _context95.next = 33;
                break;
              case 29:
                _context95.next = 31;
                return kic.exportKey();
              case 31:
                _key13 = _context95.sent;
                keys.push(_key13);
              case 33:
                _context95.next = 5;
                break;
              case 35:
                _context95.next = 40;
                break;
              case 37:
                _context95.prev = 37;
                _context95.t1 = _context95["catch"](3);
                _iterator44.e(_context95.t1);
              case 40:
                _context95.prev = 40;
                _iterator44.f();
                return _context95.finish(40);
              case 43:
                if (!alg.algorithm.name.startsWith("RSA")) {
                  _context95.next = 58;
                  break;
                }
                i = 0;
              case 45:
                if (!(i < keys.length)) {
                  _context95.next = 58;
                  break;
                }
                key = keys[i];
                if (!key.algorithm.name.startsWith("RSA")) {
                  _context95.next = 55;
                  break;
                }
                _context95.next = 50;
                return Application.crypto.subtle.exportKey("spki", key);
              case 50:
                spki = _context95.sent;
                _context95.next = 53;
                return Application.crypto.subtle.importKey("spki", spki, alg.algorithm, true, ["verify"]);
              case 53:
                updatedKey = _context95.sent;
                keys[i] = updatedKey;
              case 55:
                i++;
                _context95.next = 45;
                break;
              case 58:
                return _context95.abrupt("return", keys);
              case 59:
              case "end":
                return _context95.stop();
            }
          }, _callee95, this, [[3, 37, 40, 43], [9, 21, 24, 27]]);
        }));
        function GetPublicKeys() {
          return _GetPublicKeys.apply(this, arguments);
        }
        return GetPublicKeys;
      }()
    }, {
      key: "GetSignatureNamespaces",
      value: function GetSignatureNamespaces() {
        var namespaces = {};
        if (this.XmlSignature.NamespaceURI) {
          namespaces[this.XmlSignature.Prefix || ""] = this.XmlSignature.NamespaceURI;
        }
        return namespaces;
      }
    }, {
      key: "CopyNamespaces",
      value: function CopyNamespaces(src, dst, ignoreDefault) {
        this.InjectNamespaces(SelectRootNamespaces(src), dst, ignoreDefault);
      }
    }, {
      key: "InjectNamespaces",
      value: function InjectNamespaces(namespaces, target, ignoreDefault) {
        for (var i in namespaces) {
          var uri = namespaces[i];
          if (ignoreDefault && i === "") {
            continue;
          }
          target.setAttribute("xmlns" + (i ? ":" + i : ""), uri);
        }
      }
    }, {
      key: "DigestReference",
      value: function () {
        var _DigestReference = _asyncToGenerator(_regeneratorRuntime().mark(function _callee96(source, reference, checkHmac) {
          var content, objectName, uri, found, xmlSignatureObjects, _i46, _xmlSignatureObjects, xmlSignatureObject, el, parent, _el, canonOutput, excC14N, digest;
          return _regeneratorRuntime().wrap(function _callee96$(_context96) {
            while (1) switch (_context96.prev = _context96.next) {
              case 0:
                if (!this.contentHandler) {
                  _context96.next = 5;
                  break;
                }
                _context96.next = 3;
                return this.contentHandler(reference, this);
              case 3:
                content = _context96.sent;
                if (content) {
                  source = isDocument(content) ? content.documentElement : content;
                }
              case 5:
                if (!reference.Uri) {
                  _context96.next = 30;
                  break;
                }
                if (!reference.Uri.indexOf("#xpointer")) {
                  uri = reference.Uri;
                  uri = uri.substring(9).replace(/[\r\n\t\s]/g, "");
                  if (uri.length < 2 || uri[0] !== "(" || uri[uri.length - 1] !== ")") {
                    uri = "";
                  } else {
                    uri = uri.substring(1, uri.length - 1);
                  }
                  if (uri.length > 6 && uri.indexOf("id(") === 0 && uri[uri.length - 1] === ")") {
                    objectName = uri.substring(4, uri.length - 2);
                  }
                } else if (reference.Uri[0] === "#") {
                  objectName = reference.Uri.substring(1);
                }
                if (!objectName) {
                  _context96.next = 30;
                  break;
                }
                found = null;
                xmlSignatureObjects = [this.XmlSignature.KeyInfo.GetXml()];
                this.XmlSignature.ObjectList.ForEach(function (object) {
                  xmlSignatureObjects.push(object.GetXml());
                });
                _i46 = 0, _xmlSignatureObjects = xmlSignatureObjects;
              case 12:
                if (!(_i46 < _xmlSignatureObjects.length)) {
                  _context96.next = 27;
                  break;
                }
                xmlSignatureObject = _xmlSignatureObjects[_i46];
                if (!xmlSignatureObject) {
                  _context96.next = 24;
                  break;
                }
                found = findById(xmlSignatureObject, objectName);
                if (!found) {
                  _context96.next = 24;
                  break;
                }
                el = found.cloneNode(true);
                if (isElement(source)) {
                  this.CopyNamespaces(source, el, false);
                }
                if (this.Parent) {
                  parent = this.Parent instanceof XmlObject ? this.Parent.GetXml() : this.Parent;
                  this.CopyNamespaces(parent, el, true);
                }
                this.CopyNamespaces(found, el, false);
                this.InjectNamespaces(this.GetSignatureNamespaces(), el, true);
                source = el;
                return _context96.abrupt("break", 27);
              case 24:
                _i46++;
                _context96.next = 12;
                break;
              case 27:
                if (!found && source && isElement(source)) {
                  found = XmlObject.GetElementById(source, objectName);
                  if (found) {
                    _el = found.cloneNode(true);
                    this.CopyNamespaces(found, _el, false);
                    this.CopyNamespaces(source, _el, false);
                    source = _el;
                  }
                }
                if (!(found == null)) {
                  _context96.next = 30;
                  break;
                }
                throw new XmlError(XE.CRYPTOGRAPHIC, "Cannot get object by reference: ".concat(objectName));
              case 30:
                canonOutput = null;
                if (!(reference.Transforms && reference.Transforms.Count)) {
                  _context96.next = 37;
                  break;
                }
                if (!BufferSourceConverter.isBufferSource(source)) {
                  _context96.next = 34;
                  break;
                }
                throw new Error("Transformation for argument 'source' of type BufferSource is not implemented");
              case 34:
                canonOutput = this.ApplyTransforms(reference.Transforms, source);
                _context96.next = 51;
                break;
              case 37:
                if (!(reference.Uri && reference.Uri[0] !== "#")) {
                  _context96.next = 47;
                  break;
                }
                if (!isElement(source)) {
                  _context96.next = 44;
                  break;
                }
                if (source.ownerDocument) {
                  _context96.next = 41;
                  break;
                }
                throw new Error("Cannot get ownerDocument from the XML document");
              case 41:
                canonOutput = new XMLSerializer().serializeToString(source.ownerDocument);
                _context96.next = 45;
                break;
              case 44:
                canonOutput = BufferSourceConverter.toArrayBuffer(source);
              case 45:
                _context96.next = 51;
                break;
              case 47:
                excC14N = new XmlDsigC14NTransform();
                if (BufferSourceConverter.isBufferSource(source)) {
                  source = Parse(Convert.ToUtf8String(source)).documentElement;
                }
                excC14N.LoadInnerXml(source);
                canonOutput = excC14N.GetOutput();
              case 51:
                if (reference.DigestMethod.Algorithm) {
                  _context96.next = 53;
                  break;
                }
                throw new XmlError(XE.NULL_PARAM, "Reference", "DigestMethod");
              case 53:
                digest = CryptoConfig.CreateHashAlgorithm(reference.DigestMethod.Algorithm);
                return _context96.abrupt("return", digest.Digest(canonOutput));
              case 55:
              case "end":
                return _context96.stop();
            }
          }, _callee96, this);
        }));
        function DigestReference(_x130, _x131, _x132) {
          return _DigestReference.apply(this, arguments);
        }
        return DigestReference;
      }()
    }, {
      key: "DigestReferences",
      value: function () {
        var _DigestReferences = _asyncToGenerator(_regeneratorRuntime().mark(function _callee97(data) {
          var _iterator46, _step46, ref, hash;
          return _regeneratorRuntime().wrap(function _callee97$(_context97) {
            while (1) switch (_context97.prev = _context97.next) {
              case 0:
                _iterator46 = _createForOfIteratorHelper(this.XmlSignature.SignedInfo.References.GetIterator());
                _context97.prev = 1;
                _iterator46.s();
              case 3:
                if ((_step46 = _iterator46.n()).done) {
                  _context97.next = 14;
                  break;
                }
                ref = _step46.value;
                if (!ref.DigestValue) {
                  _context97.next = 7;
                  break;
                }
                return _context97.abrupt("continue", 12);
              case 7:
                if (!ref.DigestMethod.Algorithm) {
                  ref.DigestMethod.Algorithm = new Sha256().namespaceURI;
                }
                _context97.next = 10;
                return this.DigestReference(data, ref, false);
              case 10:
                hash = _context97.sent;
                ref.DigestValue = hash;
              case 12:
                _context97.next = 3;
                break;
              case 14:
                _context97.next = 19;
                break;
              case 16:
                _context97.prev = 16;
                _context97.t0 = _context97["catch"](1);
                _iterator46.e(_context97.t0);
              case 19:
                _context97.prev = 19;
                _iterator46.f();
                return _context97.finish(19);
              case 22:
              case "end":
                return _context97.stop();
            }
          }, _callee97, this, [[1, 16, 19, 22]]);
        }));
        function DigestReferences(_x133) {
          return _DigestReferences.apply(this, arguments);
        }
        return DigestReferences;
      }()
    }, {
      key: "TransformSignedInfo",
      value: function TransformSignedInfo(data) {
        var t = CryptoConfig.CreateFromName(this.XmlSignature.SignedInfo.CanonicalizationMethod.Algorithm);
        var xml = this.XmlSignature.SignedInfo.GetXml();
        if (!xml) {
          throw new XmlError(XE.XML_EXCEPTION, "Cannot get Xml element from SignedInfo");
        }
        var node = xml.cloneNode(true);
        this.CopyNamespaces(xml, node, false);
        if (data && !BufferSourceConverter.isBufferSource(data)) {
          if (data.nodeType === XmlNodeType.Document) {
            this.CopyNamespaces(data.documentElement, node, false);
          } else {
            this.CopyNamespaces(data, node, false);
          }
        }
        if (this.Parent) {
          var parentXml = this.Parent instanceof XmlObject ? this.Parent.GetXml() : this.Parent;
          if (parentXml) {
            this.CopyNamespaces(parentXml, node, false);
          }
        }
        var childNamespaces = SelectNamespaces(xml);
        for (var i in childNamespaces) {
          var uri = childNamespaces[i];
          if (i === node.prefix) {
            continue;
          }
          node.setAttribute("xmlns" + (i ? ":" + i : ""), uri);
        }
        t.LoadInnerXml(node);
        var res = t.GetOutput();
        return res;
      }
    }, {
      key: "ResolveTransform",
      value: function ResolveTransform(transform) {
        if (typeof transform === "string") {
          switch (transform) {
            case "enveloped":
              return new XmlDsigEnvelopedSignatureTransform();
            case "c14n":
              return new XmlDsigC14NTransform();
            case "c14n-com":
              return new XmlDsigC14NWithCommentsTransform();
            case "exc-c14n":
              return new XmlDsigExcC14NTransform();
            case "exc-c14n-com":
              return new XmlDsigExcC14NWithCommentsTransform();
            case "base64":
              return new XmlDsigBase64Transform();
            default:
              throw new XmlError(XE.CRYPTOGRAPHIC_UNKNOWN_TRANSFORM, transform);
          }
        }
        switch (transform.name) {
          case "xpath":
            {
              var xpathTransform = new XmlDsigXPathTransform();
              xpathTransform.XPath = transform.selector;
              var transformEl = xpathTransform.GetXml();
              if (transformEl && transform.namespaces) {
                for (var _i47 = 0, _Object$entries2 = Object.entries(transform.namespaces); _i47 < _Object$entries2.length; _i47++) {
                  var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i47], 2),
                    prefix = _Object$entries2$_i[0],
                    namespace = _Object$entries2$_i[1];
                  transformEl.firstChild.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:".concat(prefix), namespace);
                }
              }
              return xpathTransform;
            }
          default:
            throw new XmlError(XE.CRYPTOGRAPHIC_UNKNOWN_TRANSFORM, transform.name);
        }
      }
    }, {
      key: "ApplyTransforms",
      value: function ApplyTransforms(transforms, input) {
        var _this224 = this;
        var output = null;
        transforms.Sort(function (a, b) {
          var c14nTransforms = [XmlDsigC14NTransform, XmlDsigC14NWithCommentsTransform, XmlDsigExcC14NTransform, XmlDsigExcC14NWithCommentsTransform];
          if (c14nTransforms.some(function (t) {
            return a instanceof t;
          })) {
            return 1;
          }
          if (c14nTransforms.some(function (t) {
            return b instanceof t;
          })) {
            return -1;
          }
          return 0;
        }).ForEach(function (transform) {
          if (_this224.replaceCanonicalization) {
            if (transform instanceof XmlDsigExcC14NWithCommentsTransform) {
              transform = new XmlDsigExcC14NTransform();
            } else if (transform instanceof XmlDsigC14NWithCommentsTransform) {
              transform = new XmlDsigC14NTransform();
            }
          }
          transform.LoadInnerXml(input);
          if (transform instanceof XmlDsigXPathTransform) {
            transform.GetOutput();
          } else {
            output = transform.GetOutput();
          }
        });
        if (transforms.Count === 1 && transforms.Item(0) instanceof XmlDsigEnvelopedSignatureTransform) {
          var c14n = new XmlDsigC14NTransform();
          c14n.LoadInnerXml(input);
          output = c14n.GetOutput();
        }
        return output;
      }
    }, {
      key: "ApplySignOptions",
      value: function () {
        var _ApplySignOptions = _asyncToGenerator(_regeneratorRuntime().mark(function _callee98(signature, algorithm, key, options) {
          var _this225 = this;
          var keyInfo, keyValue, _keyInfo2, reference;
          return _regeneratorRuntime().wrap(function _callee98$(_context98) {
            while (1) switch (_context98.prev = _context98.next) {
              case 0:
                if (options.id) {
                  this.XmlSignature.Id = options.id;
                }
                if (!(options.keyValue && key.algorithm.name.toUpperCase() !== HMAC)) {
                  _context98.next = 8;
                  break;
                }
                if (!signature.KeyInfo) {
                  signature.KeyInfo = new exports.KeyInfo();
                }
                keyInfo = signature.KeyInfo;
                keyValue = new exports.KeyValue();
                keyInfo.Add(keyValue);
                _context98.next = 8;
                return keyValue.importKey(options.keyValue);
              case 8:
                if (options.x509) {
                  if (!signature.KeyInfo) {
                    signature.KeyInfo = new exports.KeyInfo();
                  }
                  _keyInfo2 = signature.KeyInfo;
                  options.x509.forEach(function (x509) {
                    var raw = Convert$1.FromBase64(x509);
                    var x509Data = new exports.KeyInfoX509Data(raw);
                    _keyInfo2.Add(x509Data);
                  });
                }
                if (options.references) {
                  options.references.forEach(function (item) {
                    var reference = new exports.Reference();
                    if (item.id) {
                      reference.Id = item.id;
                    }
                    if (item.uri !== null && item.uri !== undefined) {
                      reference.Uri = item.uri;
                    }
                    if (item.type) {
                      reference.Type = item.type;
                    }
                    var digestAlgorithm = CryptoConfig.GetHashAlgorithm(item.hash);
                    reference.DigestMethod.Algorithm = digestAlgorithm.namespaceURI;
                    if (item.transforms && item.transforms.length) {
                      var transforms = new exports.Transforms();
                      item.transforms.forEach(function (transform) {
                        transforms.Add(_this225.ResolveTransform(transform));
                      });
                      reference.Transforms = transforms;
                    }
                    if (!signature.SignedInfo.References) {
                      signature.SignedInfo.References = new exports.References();
                    }
                    signature.SignedInfo.References.Add(reference);
                  });
                }
                if (!signature.SignedInfo.References.Count) {
                  reference = new exports.Reference();
                  signature.SignedInfo.References.Add(reference);
                }
              case 11:
              case "end":
                return _context98.stop();
            }
          }, _callee98, this);
        }));
        function ApplySignOptions(_x134, _x135, _x136, _x137) {
          return _ApplySignOptions.apply(this, arguments);
        }
        return ApplySignOptions;
      }()
    }, {
      key: "ValidateReferences",
      value: function () {
        var _ValidateReferences = _asyncToGenerator(_regeneratorRuntime().mark(function _callee99(doc) {
          var _iterator47, _step47, ref, digest, b64Digest, b64DigestValue, errText;
          return _regeneratorRuntime().wrap(function _callee99$(_context99) {
            while (1) switch (_context99.prev = _context99.next) {
              case 0:
                _iterator47 = _createForOfIteratorHelper(this.XmlSignature.SignedInfo.References.GetIterator());
                _context99.prev = 1;
                _iterator47.s();
              case 3:
                if ((_step47 = _iterator47.n()).done) {
                  _context99.next = 15;
                  break;
                }
                ref = _step47.value;
                _context99.next = 7;
                return this.DigestReference(doc, ref, false);
              case 7:
                digest = _context99.sent;
                b64Digest = Convert$1.ToBase64(digest);
                b64DigestValue = Convert$1.ToString(ref.DigestValue, "base64");
                if (!(b64Digest !== b64DigestValue)) {
                  _context99.next = 13;
                  break;
                }
                errText = "Invalid digest for uri '".concat(ref.Uri, "'. Calculated digest is ").concat(b64Digest, " but the xml to validate supplies digest ").concat(b64DigestValue);
                throw new XmlError(XE.CRYPTOGRAPHIC, errText);
              case 13:
                _context99.next = 3;
                break;
              case 15:
                _context99.next = 20;
                break;
              case 17:
                _context99.prev = 17;
                _context99.t0 = _context99["catch"](1);
                _iterator47.e(_context99.t0);
              case 20:
                _context99.prev = 20;
                _iterator47.f();
                return _context99.finish(20);
              case 23:
                return _context99.abrupt("return", true);
              case 24:
              case "end":
                return _context99.stop();
            }
          }, _callee99, this, [[1, 17, 20, 23]]);
        }));
        function ValidateReferences(_x138) {
          return _ValidateReferences.apply(this, arguments);
        }
        return ValidateReferences;
      }()
    }, {
      key: "ValidateSignatureValue",
      value: function () {
        var _ValidateSignatureValue = _asyncToGenerator(_regeneratorRuntime().mark(function _callee100(keys) {
          var signer, signedInfoCanon, _iterator48, _step48, key, ok;
          return _regeneratorRuntime().wrap(function _callee100$(_context100) {
            while (1) switch (_context100.prev = _context100.next) {
              case 0:
                signedInfoCanon = this.TransformSignedInfo(this.document);
                signer = CryptoConfig.CreateSignatureAlgorithm(this.XmlSignature.SignedInfo.SignatureMethod);
                _iterator48 = _createForOfIteratorHelper(keys);
                _context100.prev = 3;
                _iterator48.s();
              case 5:
                if ((_step48 = _iterator48.n()).done) {
                  _context100.next = 14;
                  break;
                }
                key = _step48.value;
                _context100.next = 9;
                return signer.Verify(signedInfoCanon, key, this.Signature);
              case 9:
                ok = _context100.sent;
                if (!ok) {
                  _context100.next = 12;
                  break;
                }
                return _context100.abrupt("return", true);
              case 12:
                _context100.next = 5;
                break;
              case 14:
                _context100.next = 19;
                break;
              case 16:
                _context100.prev = 16;
                _context100.t0 = _context100["catch"](3);
                _iterator48.e(_context100.t0);
              case 19:
                _context100.prev = 19;
                _iterator48.f();
                return _context100.finish(19);
              case 22:
                return _context100.abrupt("return", false);
              case 23:
              case "end":
                return _context100.stop();
            }
          }, _callee100, this, [[3, 16, 19, 22]]);
        }));
        function ValidateSignatureValue(_x139) {
          return _ValidateSignatureValue.apply(this, arguments);
        }
        return ValidateSignatureValue;
      }()
    }]);
  }();
  function findById(element, id) {
    if (element.nodeType !== XmlNodeType.Element) {
      return null;
    }
    if (element.hasAttribute("Id") && element.getAttribute("Id") === id) {
      return element;
    }
    if (element.childNodes && element.childNodes.length) {
      for (var i = 0; i < element.childNodes.length; i++) {
        var el = findById(element.childNodes[i], id);
        if (el) {
          return el;
        }
      }
    }
    return null;
  }
  function addNamespace(selectedNodes, name, namespace) {
    if (!(name in selectedNodes)) {
      selectedNodes[name] = namespace;
    }
  }
  function _SelectRootNamespaces(node) {
    var selectedNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (isElement(node)) {
      if (node.namespaceURI && node.namespaceURI !== "http://www.w3.org/XML/1998/namespace") {
        addNamespace(selectedNodes, node.prefix ? node.prefix : "", node.namespaceURI);
      }
      for (var i = 0; i < node.attributes.length; i++) {
        var attr = node.attributes.item(i);
        if (attr && attr.prefix === "xmlns") {
          addNamespace(selectedNodes, attr.localName ? attr.localName : "", attr.value);
        }
      }
      if (node.parentNode) {
        _SelectRootNamespaces(node.parentNode, selectedNodes);
      }
    }
  }
  function SelectRootNamespaces(node) {
    var attrs = {};
    _SelectRootNamespaces(node, attrs);
    return attrs;
  }

  exports.Application = Application;
  exports.CryptoConfig = CryptoConfig;
  exports.ECDSA = ECDSA;
  exports.ECDSA_SHA1_NAMESPACE = ECDSA_SHA1_NAMESPACE;
  exports.ECDSA_SHA256_NAMESPACE = ECDSA_SHA256_NAMESPACE;
  exports.ECDSA_SHA384_NAMESPACE = ECDSA_SHA384_NAMESPACE;
  exports.ECDSA_SHA512_NAMESPACE = ECDSA_SHA512_NAMESPACE;
  exports.EcdsaSha1 = EcdsaSha1;
  exports.EcdsaSha256 = EcdsaSha256;
  exports.EcdsaSha384 = EcdsaSha384;
  exports.EcdsaSha512 = EcdsaSha512;
  exports.HMAC = HMAC;
  exports.HMAC_SHA1_NAMESPACE = HMAC_SHA1_NAMESPACE;
  exports.HMAC_SHA256_NAMESPACE = HMAC_SHA256_NAMESPACE;
  exports.HMAC_SHA384_NAMESPACE = HMAC_SHA384_NAMESPACE;
  exports.HMAC_SHA512_NAMESPACE = HMAC_SHA512_NAMESPACE;
  exports.HmacSha1 = HmacSha1;
  exports.HmacSha256 = HmacSha256;
  exports.HmacSha384 = HmacSha384;
  exports.HmacSha512 = HmacSha512;
  exports.KeyInfoClause = KeyInfoClause;
  exports.Parse = Parse;
  exports.RSA_PKCS1 = RSA_PKCS1;
  exports.RSA_PKCS1_SHA1_NAMESPACE = RSA_PKCS1_SHA1_NAMESPACE;
  exports.RSA_PKCS1_SHA256_NAMESPACE = RSA_PKCS1_SHA256_NAMESPACE;
  exports.RSA_PKCS1_SHA384_NAMESPACE = RSA_PKCS1_SHA384_NAMESPACE;
  exports.RSA_PKCS1_SHA512_NAMESPACE = RSA_PKCS1_SHA512_NAMESPACE;
  exports.RSA_PSS = RSA_PSS;
  exports.RSA_PSS_SHA1_NAMESPACE = RSA_PSS_SHA1_NAMESPACE;
  exports.RSA_PSS_SHA256_NAMESPACE = RSA_PSS_SHA256_NAMESPACE;
  exports.RSA_PSS_SHA384_NAMESPACE = RSA_PSS_SHA384_NAMESPACE;
  exports.RSA_PSS_SHA512_NAMESPACE = RSA_PSS_SHA512_NAMESPACE;
  exports.RSA_PSS_WITH_PARAMS_NAMESPACE = RSA_PSS_WITH_PARAMS_NAMESPACE;
  exports.RsaPkcs1Sha1 = RsaPkcs1Sha1;
  exports.RsaPkcs1Sha256 = RsaPkcs1Sha256;
  exports.RsaPkcs1Sha384 = RsaPkcs1Sha384;
  exports.RsaPkcs1Sha512 = RsaPkcs1Sha512;
  exports.RsaPssBase = RsaPssBase;
  exports.RsaPssSha1 = RsaPssSha1;
  exports.RsaPssSha256 = RsaPssSha256;
  exports.RsaPssSha384 = RsaPssSha384;
  exports.RsaPssSha512 = RsaPssSha512;
  exports.RsaPssWithoutParamsBase = RsaPssWithoutParamsBase;
  exports.RsaPssWithoutParamsSha1 = RsaPssWithoutParamsSha1;
  exports.RsaPssWithoutParamsSha256 = RsaPssWithoutParamsSha256;
  exports.RsaPssWithoutParamsSha384 = RsaPssWithoutParamsSha384;
  exports.RsaPssWithoutParamsSha512 = RsaPssWithoutParamsSha512;
  exports.SHA1 = SHA1;
  exports.SHA1_NAMESPACE = SHA1_NAMESPACE;
  exports.SHA256 = SHA256;
  exports.SHA256_NAMESPACE = SHA256_NAMESPACE;
  exports.SHA384 = SHA384;
  exports.SHA384_NAMESPACE = SHA384_NAMESPACE;
  exports.SHA512 = SHA512;
  exports.SHA512_NAMESPACE = SHA512_NAMESPACE;
  exports.Select = Select;
  exports.SelectRootNamespaces = SelectRootNamespaces;
  exports.Sha1 = Sha1;
  exports.Sha256 = Sha256;
  exports.Sha384 = Sha384;
  exports.Sha512 = Sha512;
  exports.SignedXml = SignedXml;
  exports.Stringify = Stringify;
  exports.X509Certificate = X509Certificate;
  exports.XmlCanonicalizer = XmlCanonicalizer;
  exports.XmlDsigBase64Transform = XmlDsigBase64Transform;
  exports.XmlDsigC14NTransform = XmlDsigC14NTransform;
  exports.XmlDsigC14NWithCommentsTransform = XmlDsigC14NWithCommentsTransform;
  exports.XmlDsigEnvelopedSignatureTransform = XmlDsigEnvelopedSignatureTransform;
  exports.XmlDsigExcC14NTransform = XmlDsigExcC14NTransform;
  exports.XmlDsigExcC14NWithCommentsTransform = XmlDsigExcC14NWithCommentsTransform;
  exports.XmlDsigXPathTransform = XmlDsigXPathTransform;
  exports.XmlSignature = XmlSignature;

  return exports;

})({});
